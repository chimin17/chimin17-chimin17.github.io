{"meta":{"title":"Chimin's Blog","subtitle":"Chimin's 技術分享筆記","description":"you are never wrong to do the right thing","author":"Chi-Min Chiu","url":"https://chimin17.github.io"},"pages":[{"title":"About","date":"2018-02-21T14:52:51.000Z","updated":"2018-11-02T02:28:14.190Z","comments":true,"path":"about/index.html","permalink":"https://chimin17.github.io/about/index.html","excerpt":"","text":"Chi-Min Chiu Data Engineer in TomTom GIS, web, maching learning location: Taipei, TW page: https://github.com/chimin17/ email: milochiou@gmail.com Hi! here is Chi-Min, I am currently a GIS Engineer from TomTom."},{"title":"All categories","date":"2017-12-22T04:39:04.000Z","updated":"2018-02-21T14:52:36.836Z","comments":true,"path":"categories/index.html","permalink":"https://chimin17.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-22T04:39:04.000Z","updated":"2018-02-21T14:51:24.425Z","comments":true,"path":"tags/index.html","permalink":"https://chimin17.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"鐵人賽2019 Day17 Geogig GIS版本控制","slug":"ironman-2019-day17","date":"2018-11-01T13:59:49.000Z","updated":"2018-11-02T02:21:14.877Z","comments":true,"path":"2018/11/01/ironman-2019-day17/","link":"","permalink":"https://chimin17.github.io/2018/11/01/ironman-2019-day17/","excerpt":"今天的主題與Python較於無關，這陣子遇到資料版本控制的需求，有搜尋並測試了一下geogig這個軟體，在此稍微紀錄一下。 geogig是個開源專案，使用JAVA開發並以BSD授權，主要目的是做GIS資料的版本控制，整個操作經驗與git類似，支援的GIS資料包含shapefile、PostGIS、SpatiaLite等，對每一次commit的GIS追蹤管理，也可對資料開分支、遠端分支等等功能。 今天就記錄一下比較基本的步驟。","text":"今天的主題與Python較於無關，這陣子遇到資料版本控制的需求，有搜尋並測試了一下geogig這個軟體，在此稍微紀錄一下。 geogig是個開源專案，使用JAVA開發並以BSD授權，主要目的是做GIS資料的版本控制，整個操作經驗與git類似，支援的GIS資料包含shapefile、PostGIS、SpatiaLite等，對每一次commit的GIS追蹤管理，也可對資料開分支、遠端分支等等功能。 今天就記錄一下比較基本的步驟。 安裝Geogig官網以包好exe，前往官網下載GeoGig by LocationTech 解壓縮到D:\\後，把路徑加入系統環境變數中 我們測試一下，打開cmd 1geogig 設定好路徑並有反應了，我們可以開始操作Geogig了 初始化初始化一個repo，這邊的初始化跟git一樣：1geogig init 我們把rail.shp加入一個commit，在這之前要先用shp import1geogig shp import rail.shp -d rail 上面的import跟一般git比等於是多一步，import之後可以add，這個動作跟git add .一樣1geogig add 然後，就可以commit了，這邊的commit跟git也是一樣的1geogig commit -m &quot;init&quot; 這邊操作的時候跳了一個錯，因為第一次操作時，Geogig會要求輸入user config，跟git一樣，如果遇到就這步驟設定就好了 成功操作 如果要update資料我們進入QGIS給資料一些異動，我們直接修改資料的屬性(修改數筆DEFINITION) 要再提供一次commit 要把shp import跟add 在操作一次1geogig shp import rail.shp -d rail add，這邊可以看到一些異動資訊1geogig add commit，然後第二個版本的資料就被記錄上去了1geogig commit -m &quot;second round&quot; 從上可以看到版本間的異動 基本資訊接下來來看看repo與commit的資訊 觀看repo內容用ls看到目前的repo中的資料集1geogig ls log 看版本的歷史過程1geogig log 後記Geogig在QGIS與Geoserver有外掛可以使用，今天先以git的觀點進行基本操作，有興趣者可操作看看！","categories":[],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"2019鐵人賽-30天精通GIS資料分析-使用Python","slug":"2019鐵人賽-30天精通GIS資料分析-使用Python","permalink":"https://chimin17.github.io/tags/2019鐵人賽-30天精通GIS資料分析-使用Python/"}]},{"title":"鐵人賽2019 Day16 WKT與PostGIS的運算","slug":"ironman-2019-day16","date":"2018-10-31T14:02:39.000Z","updated":"2018-11-02T02:19:41.260Z","comments":true,"path":"2018/10/31/ironman-2019-day16/","link":"","permalink":"https://chimin17.github.io/2018/10/31/ironman-2019-day16/","excerpt":"在昨天的文章中，我們要把資料倒入PostGIS前，需要使用geoalchemy2把坐標資料轉成WKT element，今天來理解一下WKT WKTWKT的全寫是(Well Known Text)，是OGC SFS（Simple Features Interface Standard）對於資料庫中GIS資料的架構定義，全文可從連結下載，另外SQL語法對於GIS處理的定義，也是在這份文件中定義，大多數GIS資料庫都有提供SFS的基本定義及功能。 有關SFS的幾何類型參考下圖：(取自OGC)","text":"在昨天的文章中，我們要把資料倒入PostGIS前，需要使用geoalchemy2把坐標資料轉成WKT element，今天來理解一下WKT WKTWKT的全寫是(Well Known Text)，是OGC SFS（Simple Features Interface Standard）對於資料庫中GIS資料的架構定義，全文可從連結下載，另外SQL語法對於GIS處理的定義，也是在這份文件中定義，大多數GIS資料庫都有提供SFS的基本定義及功能。 有關SFS的幾何類型參考下圖：(取自OGC) WKT是以文字方式表達幾何，以下從網站上擷取一些類型(取自WIKI) WKBWKB(Well Known Binary)顧名思義就是將WKT加以binary編碼，[1]有對於WKB位數儲存有一些說明，而WKB主要是讓WKT更加緊湊。 WKT與GeoDataFramePostGIS的空間屬性是根據OGC SFS，前幾天有提到Geopandas的空間資料是使用shapely的定義，昨天的範例主要是透過geoalchemy2將shapely的geometry轉為PostGIS的geometry，以方便幾何資料的ORM12345from geoalchemy2 import Geometry, WKTElementgdf=gpd.read_file(&apos;data/Rail/Rail.shp&apos;,encoding=&apos;utf-8&apos;)gdf[&apos;geom&apos;] = gdf[&apos;geometry&apos;].apply(lambda x: WKTElement(x.wkt, srid=3826))gdf.drop(&apos;geometry&apos;, 1, inplace=True)type(gdf.at[0,&apos;geom&apos;] ) 結果為geoalchemy2.elements.WKTElement to_sql1234from sqlalchemy import create_engineengine = create_engine(&apos;postgresql://postgres:postgres@localhost:5432/public&apos;)gdf.to_sql(&apos;rail&apos;, engine, if_exists=&apos;replace&apos;, index=False, schema=&apos;public&apos; ,dtype=&#123;&apos;geom&apos;: Geometry(&apos;LINESTRING&apos;, srid= 3826)&#125;) PostGISOGC SFS有定義幾何運算的實踐，在PostGIS可以進行操作，大致包含了(取自OGC) 我們把SQL語法執行並直接用GeoDataFrame接，例如我們要對每一個線段做buffer123sql=&apos;select ST_buffer(rail.geom,0.0001) as geometry from public.rail &apos;df = gpd.GeoDataFrame.from_postgis(sql, engine, geom_col=&apos;geometry&apos; )df 而其他的幾何操作，可以參考PostGIS Reference","categories":[],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"2019鐵人賽-30天精通GIS資料分析-使用Python","slug":"2019鐵人賽-30天精通GIS資料分析-使用Python","permalink":"https://chimin17.github.io/tags/2019鐵人賽-30天精通GIS資料分析-使用Python/"}]},{"title":"鐵人賽2019 Day15 PostGIS與Geopandas","slug":"ironman-2019-day15","date":"2018-10-30T13:20:40.000Z","updated":"2018-11-02T02:18:25.947Z","comments":true,"path":"2018/10/30/ironman-2019-day15/","link":"","permalink":"https://chimin17.github.io/2018/10/30/ironman-2019-day15/","excerpt":"昨天安裝完了PostGIS，今天我們就在GeoPandas做資料讀寫，另外QGIS對於PostGIS支援度也很高，把資料匯入後，也可以使用QGIS對資料做讀寫。 ps. 安裝完PostGIS，我們需要在DB中啟用若未啟用postgis安裝完後在pgAdmin4或是psql輸入postgres=# CREATE EXTENSION postgis;","text":"昨天安裝完了PostGIS，今天我們就在GeoPandas做資料讀寫，另外QGIS對於PostGIS支援度也很高，把資料匯入後，也可以使用QGIS對資料做讀寫。 ps. 安裝完PostGIS，我們需要在DB中啟用若未啟用postgis安裝完後在pgAdmin4或是psql輸入postgres=# CREATE EXTENSION postgis; 為了用PostGIS讀寫資料我們使用data/Rail/Rail.shp123456import geopandas as gpdrail=gpd.read_file(&apos;data/Rail/Rail.shp&apos;,encoding=&apos;utf-8&apos;)rail.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; rail=rail.to_crs(epsg=4326)rail.head() 在GeoPandas，可以使用sqlalchemy建立資料庫連線的instance，對資料庫IO 12from sqlalchemy import create_engineengine = create_engine(&apos;postgresql://postgres:postgres@localhost:5432/postgres&apos;) 接著，使用to_sql這個方法，其中呢必須把geometry包成wkt element，由於一般使用geom作為PostGIS的空間屬性，這邊也一並處理123from geoalchemy2 import Geometry, WKTElementrail[&apos;geom&apos;] = rail[&apos;geometry&apos;].apply(lambda x: WKTElement(x.wkt, srid=4326))rail.drop(&apos;geometry&apos;, 1, inplace=True) 在to_sql的時候要設定連線實體、dtype(空間資料的坐標系統及幾何類型，如下：123rail.to_sql(&apos;rail&apos;, engine, if_exists=&apos;replace&apos;, index=False, schema=&apos;public&apos;, dtype=&#123;&apos;geom&apos;: Geometry(&apos;LINESTRING&apos;, srid= 4326)&#125;) 如果是其他的型別如，Point或Polygon，記得要修改 資料進PostGIS後，可以使用QGIS瀏覽、處理資料，有時需要編輯幾何資料的時候，使用QGIS很方便，熟悉QGIS的邦友可以使用DB Manager對PostGIS做操作 而剛剛的資料也可以在讀回Geopandas 123sql=&apos;select * from public.rail &apos;df = gpd.GeoDataFrame.from_postgis(sql, engine, geom_col=&apos;geom&apos; )df 使用資料庫是資料處理及資料分析不可或缺的一環，在空間資料庫中，PostGIS非常方便，建議大家使用！","categories":[],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"2019鐵人賽-30天精通GIS資料分析-使用Python","slug":"2019鐵人賽-30天精通GIS資料分析-使用Python","permalink":"https://chimin17.github.io/tags/2019鐵人賽-30天精通GIS資料分析-使用Python/"}]},{"title":"鐵人賽2019 Day14 PostGIS的安裝","slug":"ironman-2019-day14","date":"2018-10-29T15:11:22.000Z","updated":"2018-11-02T02:17:05.812Z","comments":true,"path":"2018/10/29/ironman-2019-day14/","link":"","permalink":"https://chimin17.github.io/2018/10/29/ironman-2019-day14/","excerpt":"PostGIS是PostgreSQL對於OpenGIS空間資料規範的擴充， 目前各大家資料庫對GIS資料都有支援及擴充 不過就以易用性來說，開源軟體QGIS對於PostGIS的支援度很高，而Geopandas對於PostGIS的支援也十分友善。 因此，十分建議常使用GIS資料的人安裝PostGIS在本機進行操作。 今天我們來執行單機版PostGIS的安裝(使用windows)","text":"PostGIS是PostgreSQL對於OpenGIS空間資料規範的擴充， 目前各大家資料庫對GIS資料都有支援及擴充 不過就以易用性來說，開源軟體QGIS對於PostGIS的支援度很高，而Geopandas對於PostGIS的支援也十分友善。 因此，十分建議常使用GIS資料的人安裝PostGIS在本機進行操作。 今天我們來執行單機版PostGIS的安裝(使用windows) 首先到EnterpriseDB Software Downloads | EnterpriseDB下載PostgreSQL安裝檔 打開安裝檔，開始安裝PostgreSQL 選擇要安裝的元件，為了安裝PostGIS，請把Stack Builder要打勾 接下來選擇資料庫的路徑 設定資料庫的密碼，輸入後請記得 port設定(預設即可) 地區 然後就開始安裝 以上，完成了PostgreSQL 的安裝 接下來要安裝PostGIS打開Stack Builder 選擇已安裝的PostgreSQL 版本 選擇要安裝的元件，PostGIS在spatial extension下面 stack builder會先下載檔案，因此選擇下載的路徑 下載完成，下一步開始安裝 開始安裝PostGIS 選擇PostGIS 最後，選擇路徑與下一步完成安裝。 按照以上步驟，完成了PostgreSQL +PostGIS資料庫的安裝，接下來我們會開始資料庫的操作","categories":[],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"2019鐵人賽-30天精通GIS資料分析-使用Python","slug":"2019鐵人賽-30天精通GIS資料分析-使用Python","permalink":"https://chimin17.github.io/tags/2019鐵人賽-30天精通GIS資料分析-使用Python/"}]},{"title":"鐵人賽2019 Day13 台鐵意外事件與folium練習-繪圖","slug":"ironman-2019-day13","date":"2018-10-28T13:10:01.000Z","updated":"2018-11-02T02:17:01.340Z","comments":true,"path":"2018/10/28/ironman-2019-day13/","link":"","permalink":"https://chimin17.github.io/2018/10/28/ironman-2019-day13/","excerpt":"昨天我們已經整合了台鐵路線與對話的資料今天就把圖畫完吧！ 首先，再次看看昨天的成果 1train_lines_talk","text":"昨天我們已經整合了台鐵路線與對話的資料今天就把圖畫完吧！ 首先，再次看看昨天的成果 1train_lines_talk 有了這樣的資料，可以開始畫圖了第一種畫法我們使用circlemarker我們以點的方式來呈現資訊 123456789101112131415import foliumm = folium.Map((25.01743512170683,121.9402276726103),zoom_start=13)for idx,row in train_lines_talk.iterrows(): folium.CircleMarker( location=(list(row[&apos;geometry&apos;].coords)[0][1],list(row[&apos;geometry&apos;].coords)[0][0]), radius=20, popup=row[&apos;text&apos;], color=&apos;#3186cc&apos;, fill=True, fill_color=&apos;#3186cc&apos; ).add_to(m) m 為了更清楚呈現資訊，把路線的資訊加進來1234folium.GeoJson( train_lines.to_json(), name=&apos;geojson&apos;).add_to(m)m 最後，我們試著把時間資料加進來 並使用TimestampedGeoJson這個外掛 要先把我們的資料整合成TimestampedGeoJson12345678910111213141516features = [ &#123; &apos;type&apos;: &apos;Feature&apos;, &apos;geometry&apos;: &#123; &apos;type&apos;: &apos;Point&apos;, &apos;coordinates&apos;: list(row[&apos;geometry&apos;].coords)[0], &#125;, &apos;properties&apos;: &#123; &apos;times&apos;: [&apos;2018-10-21T&apos;+row[&apos;time&apos;][0],&apos;2018-10-21T&apos;+row[&apos;time&apos;][1]], &apos;talk&apos;: row[&apos;text&apos;], &apos;location&apos;:row[&apos;location&apos;], &#125; &#125; for idx,row in train_lines_talk.iterrows()] 123456789101112131415import foliumm = folium.Map((25.01743512170683,121.9402276726103),zoom_start=13)folium.GeoJson( train_lines.to_json(), name=&apos;geojson&apos;).add_to(m)plugins.TimestampedGeoJson(&#123; &apos;type&apos;: &apos;FeatureCollection&apos;, &apos;features&apos;: features, &#125;, period=&apos;PT1M&apos;, add_last_point=True).add_to(m)m 完成！","categories":[],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"2019鐵人賽-30天精通GIS資料分析-使用Python","slug":"2019鐵人賽-30天精通GIS資料分析-使用Python","permalink":"https://chimin17.github.io/tags/2019鐵人賽-30天精通GIS資料分析-使用Python/"}]},{"title":"鐵人賽2019 Day12 台鐵意外事件與folium練習-續篇","slug":"ironman-2019-day12","date":"2018-10-27T15:33:01.000Z","updated":"2018-11-02T02:16:54.383Z","comments":true,"path":"2018/10/27/ironman-2019-day12/","link":"","permalink":"https://chimin17.github.io/2018/10/27/ironman-2019-day12/","excerpt":"昨天做了一些前處理，今天把昨天的處理好的資料做整合 首先是宜蘭縣鐵道(polyline)123import geopandas as gpdrail_yilan=gpd.read_file(&apos;output/Rail_yilan.shp&apos;,encoding=&apos;utf-8&apos;)rail_yilan","text":"昨天做了一些前處理，今天把昨天的處理好的資料做整合 首先是宜蘭縣鐵道(polyline)123import geopandas as gpdrail_yilan=gpd.read_file(&apos;output/Rail_yilan.shp&apos;,encoding=&apos;utf-8&apos;)rail_yilan 匯入車站資料，並進一步篩選通話中的車站 12345station=gpd.read_file(&apos;output/station.shp&apos;,encoding=&apos;utf-8&apos;)station_list=[&apos;貢寮&apos;,&apos;福隆&apos;,&apos;大里&apos;,&apos;大溪&apos;,&apos;龜山&apos;,&apos;頭城&apos;,&apos;宜蘭&apos;,&apos;二結&apos;,&apos;羅東&apos;,&apos;冬山&apos;,&apos;新馬&apos;]station=station[station[&apos;Station_Na&apos;].isin(station_list)]station=station.reset_index(drop=True)station 最後的是對話資料1234import pandas as pd talk=pd.read_csv(&apos;output/talk.csv&apos;,encoding=&apos;utf-8&apos;)talk[&apos;time&apos;]=[row[&apos;time&apos;][:-2]+&quot;00&quot; for idx,row in talk.iterrows()]talk 接下來，我們把原始的路線資料切成通訊對話逐字稿的模式，這裡會用到graph的資訊計算， 把polyline換算成graph 分別把車站設為起終點，計算路徑 例如在graph輸入宜蘭最近的node及羅東站最近的node,計算的得到這兩個站的路線會採用這樣的做法是臨時決定的&gt;.&lt; 說不定改天有更好的做法細節今天就先跳過，過幾天會講到，反正最終結果是要把polyline變成像是 福隆-貢寮 或是 宜蘭-二結的這種模式的線 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051## 這邊先手動整理對照表(對照上表)routes=[[9,10],[3,4],[3,3],[2,3],[6,7],[6,6],[0,2],[8,9] , [1,0],[4,5]] from shapely.geometry import LineString,Pointfrom s2g import ShapeGraphimport networkx as nxsg = ShapeGraph(shapefile=&apos;output/Rail_yilan.shp&apos;, to_graph=True)graph = sg.to_networkx()line_gs=[]line_name=[]for route in routes: min_distance=999 start_id=0 for num in range(sg.nodes_counter): xy=sg.node_xy[num] if Point(xy).distance(station.at[route[0],&apos;geometry&apos;])&lt;min_distance: min_distance=Point(xy).distance(station.at[route[0],&apos;geometry&apos;]) start_id=num min_distance=999 end_id=0 for num in range(sg.nodes_counter): xy=sg.node_xy[num] if Point(xy).distance(station.at[route[1],&apos;geometry&apos;])&lt;min_distance: min_distance=Point(xy).distance(station.at[route[1],&apos;geometry&apos;]) end_id=num nearest_path= nx.shortest_path(graph, source=start_id, target=end_id) geoms=[] for item in nearest_path: geoms.append(sg.node_xy[item]) try: line_gs.append(LineString(geoms)) line_name.append(&quot;（地點：&quot;+station.at[route[0],&apos;Station_Na&apos;]+&quot;-&quot;+station.at[route[1],&apos;Station_Na&apos;]+&quot;)&quot;) except:pass train_lines = gpd.GeoDataFrame(crs= &#123;&apos;init&apos; :&apos;epsg:4326&apos;&#125;,geometry=line_gs)train_lines[&apos;location&apos;]=line_nametrain_lines 以下是我們要的路線整合結果： 最後整合對話與路線，123456789101112131415161718192021222324252627282930# 初始化talk[&apos;geometry&apos;]=talk[&apos;location&apos;]for i1,r1 in talk.iterrows(): for i2,r2 in train_lines.iterrows(): if r1[&apos;location&apos;]==r2[&apos;location&apos;]: talk.at[i1,&apos;geometry&apos;]=r2[&apos;geometry&apos;] break else: talk.at[i1,&apos;geometry&apos;]=talk.at[0,&apos;geometry&apos;] st=talk.at[0,&apos;time&apos;]temp_text=&quot;&quot; geoms=[]temp_location=talk.at[0,&apos;location&apos;]for i1,r1 in talk.iterrows(): if temp_location!=talk.at[i1,&apos;location&apos;]: geoms.append([talk.at[i1-1,&apos;geometry&apos;],[st,talk.at[i1-1,&apos;time&apos;]],talk.at[i1-1,&apos;location&apos;],temp_text]) ##release temp_location=talk.at[i1,&apos;location&apos;] temp_text=&quot;&quot; st=talk.at[i1,&apos;time&apos;] else: temp_text+=talk.at[i1,&apos;content&apos;]+&quot;;&quot;geoms.append([talk.at[i1,&apos;geometry&apos;],[st,talk.at[i1,&apos;time&apos;]],talk.at[i1,&apos;location&apos;],temp_text]) train_lines_talk= gpd.GeoDataFrame(geoms)train_lines_talk.columns=[&apos;geometry&apos;,&apos;time&apos;,&apos;location&apos;,&apos;text&apos;]train_lines_talk 最終成果：","categories":[],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"2019鐵人賽-30天精通GIS資料分析-使用Python","slug":"2019鐵人賽-30天精通GIS資料分析-使用Python","permalink":"https://chimin17.github.io/tags/2019鐵人賽-30天精通GIS資料分析-使用Python/"}]},{"title":"鐵人賽2019 Day11 台鐵意外事件與folium練習-前處理","slug":"ironman-2019-day11","date":"2018-10-26T13:39:55.000Z","updated":"2018-11-02T02:16:19.966Z","comments":true,"path":"2018/10/26/ironman-2019-day11/","link":"","permalink":"https://chimin17.github.io/2018/10/26/ironman-2019-day11/","excerpt":"最近的台鐵意外事件，看到有媒體及網友製作前端的網頁地圖呈現通話紀錄，剛好昨天使用了folium，一時興起今天也來用folium做看看，今天先來做一些前處理 ps. 另外，也祝傷者平安及亡者安息","text":"最近的台鐵意外事件，看到有媒體及網友製作前端的網頁地圖呈現通話紀錄，剛好昨天使用了folium，一時興起今天也來用folium做看看，今天先來做一些前處理 ps. 另外，也祝傷者平安及亡者安息 資料來源要呈現這樣的圖，包括了以下幾種資料： 臺灣鐵路 | 政府資料開放平臺 台鐵車站基本資料（台鐵） 普悠瑪翻車前257句43分鐘對話曝光！ 司機一路求援邊開邊修-民視新聞網 逐字稿文字資料整理網站上的逐字稿在上面的新聞網站可以看到 我們試著把它結構化，我們使用requests去get網頁文檔，並用BeautifulSoup結構化資料123456789import requestsimport pandas as pd import geopandas as gpdimport refrom bs4 import BeautifulSoupresult=requests.get(&apos;https://news.ftv.com.tw/AMP/News_Amp.aspx?id=2018A25W0003&apos;)from bs4 import BeautifulSoupsoup = BeautifulSoup(result.text, &apos;html.parser&apos;) 有關這些技術細節，請參考以下程式碼1234567891011121314151617181920212223242526272829303132p_count=0start_flag=Falsep_contents=soup.find_all(&apos;p&apos;)all_data=[]location=&quot;&quot;time=&quot;&quot;for p_item in p_contents: text=str(p_item.text) if text ==&apos;完整通聯紀錄：&apos;: start_flag=True p_count+=1 continue if len(re.findall(&apos;地點&apos;,text))&gt;0: location=text continue if len(text.split(&apos;:&apos;))==3 and len(text)==8: time=text continue # 處理前幾行 if start_flag==True: if p_count&lt;4: p_count+=1 time=text[0:8] all_data.append([location,time,text[8:]]) else: all_data.append([location,time,text]) all_data 整理好會變這樣 整合車站資料與路線首先，我們把車站資料處理成GIS資料，利用pandas2geopandas的技巧：12345678910from shapely.geometry import Pointstation_pd=pd.read_json(&apos;data/Station/Station.json&apos;, &apos;r&apos;, encoding=&apos;utf-8-sig&apos;)station_pd=station_pd[station_pd[&apos;gps&apos;]!=&apos;&apos;]y = [float(row[&apos;gps&apos;].split(&apos;,&apos;)[0].replace(&apos; &apos;,&apos;&apos;)) for idx,row in station_pd.iterrows()]x = [float(row[&apos;gps&apos;].split(&apos;,&apos;)[1].replace(&apos; &apos;,&apos;&apos;)) for idx,row in station_pd.iterrows()]geom = [Point(xy) for xy in zip(x, y)]crs = &#123;&apos;init&apos;: &apos;epsg:4326&apos;&#125;station = gpd.GeoDataFrame(station_pd, crs=crs, geometry=geom)station[[&apos;Station_Name&apos;,&apos;geometry&apos;]].to_file(&apos;output/station.shp&apos;)station 然後把第一天出現過的鐵路資料再拿來，並且選擇臺鐵宜蘭線1234567rail=gpd.read_file(&apos;data/Rail/Rail.shp&apos;,encoding=&apos;utf-8&apos;)rail.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; # 避免資料沒設，這邊再重新給一次rail=rail.to_crs(epsg=4326)# rail.groupby(&apos;RAILNAME&apos;).size()rail=rail[rail[&apos;RAILNAME&apos;]==&apos;臺鐵宜蘭線&apos;]rail.reset_index(inplace=True)rail 先觀察一下資料，我們把他們一起畫在地圖上瀏覽：123456789101112131415161718import foliumm = folium.Map((24.694192,121.775163),zoom_start=18)folium.GeoJson( station.to_json(), name=&apos;geojson&apos;).add_to(m)rail_geojson = folium.GeoJson( rail.to_json(), name=&apos;geojson&apos;, )popup = folium.Popup(&apos;Hi&apos;)popup.add_to(rail_geojson)rail_geojson.add_to(m)m 由於車站的資料與鐵路資料有一點gap，也就是說車站的點不會在鐵路線上，這會影響到展示，因此，我們試著把他投影到線上，這邊的投影我們直接使用向量內外積來處理： 計算過程中，我們把每個元素的投影都算一遍，並取距離最短的點，作為車站修正後的值123456789101112131415161718192021222324252627import numpy as npfrom shapely.geometry import Pointfor i1,r1 in station.iterrows(): point=r1[&apos;geometry&apos;] min_distance=999 new_point=point for i2,r2 in rail.iterrows(): line = r2[&apos;geometry&apos;] x = np.array(point.coords[0]) u = np.array(line.coords[0]) v = np.array(line.coords[len(line.coords)-1]) n = v - u n /= np.linalg.norm(n, 2) P = u + n*np.dot(x - u, n) distance=Point(P).distance(point) if distance&lt;min_distance: min_distance=distance new_point=Point(P) station.at[i1,&apos;geometry&apos;]=new_point 還有另外一種解法，在第七天的時候我們提到shapely的project與interpolate這兩個連續技，結果跟上面是一樣的new_point = line.interpolate(line.project(point))12345678910111213for i1,r1 in station.iterrows(): point=r1[&apos;geometry&apos;] min_distance=999 new_point=point for i2,r2 in rail.iterrows(): line = r2[&apos;geometry&apos;] temp_point = line.interpolate(line.project(point)) distance=temp_point.distance(point) if distance&lt;min_distance: min_distance=distance new_point=temp_point station.at[i1,&apos;geometry&apos;]=new_point 上面的方法二選一，再用前面的code繪製一次成果，可以看到車站已經被修正在鐵路網上！ 後記今天我們完成了一些前處理雖然這些前處理其實有些也沒這麼必要，甚至手動畫一畫就好了，不過基於練習的精神還是明天繼續把它完成吧下班時間有點晚，明天再加油！ 對今天的測試有興趣請參考github程式碼","categories":[],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"2019鐵人賽-30天精通GIS資料分析-使用Python","slug":"2019鐵人賽-30天精通GIS資料分析-使用Python","permalink":"https://chimin17.github.io/tags/2019鐵人賽-30天精通GIS資料分析-使用Python/"}]},{"title":"鐵人賽2019 Day10 地圖互動folium","slug":"ironman-2019-day10","date":"2018-10-25T12:23:10.000Z","updated":"2018-11-02T02:16:21.702Z","comments":true,"path":"2018/10/25/ironman-2019-day10/","link":"","permalink":"https://chimin17.github.io/2018/10/25/ironman-2019-day10/","excerpt":"folium是基於leaflet.js的python地圖套件，讓使用者可以很快速的使用python產生一些可互動的地圖。我們可以很方便把加工後的GIS資料丟進去，並完成一個網頁地圖。 leaflet: [Day 13] WebGIS中的向量資料-在Leaflet實作 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 以下我們就快速來試一試","text":"folium是基於leaflet.js的python地圖套件，讓使用者可以很快速的使用python產生一些可互動的地圖。我們可以很方便把加工後的GIS資料丟進去，並完成一個網頁地圖。 leaflet: [Day 13] WebGIS中的向量資料-在Leaflet實作 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 以下我們就快速來試一試 基本操作 安裝 foliumconda install -c conda-forge folium 初始化地圖初始化地圖要指定地圖中心的經緯度坐標，跟比例尺(zomm_start)例如：123import foliumm = folium.Map((25.0133904,121.52245),zoom_start=14)m folium內建一些基本的WMTS，使用tiles，我們把它換成使用Cartodb Positron12m = folium.Map((25.0133904,121.52245), tiles=&quot;Cartodb Positron&quot;,zoom_start=14)m 當然，還有很多其他選擇，有需要的人可以自行參考 加入向量資料folium的操作沒有很複雜，如果要加入向量資料，操作起來跟leaflet很像。 例如我們增加一個marker然後設定style及popup12345678910m = folium.Map((25.0133904,121.52245),zoom_start=14)folium.CircleMarker( location=[25.0133904,121.52245], radius=20, popup=&apos;永和&apos;, color=&apos;#3186cc&apos;, fill=True, fill_color=&apos;#3186cc&apos;).add_to(m)m 若要丟整份資料，folium使用的格式是geojson，如果是Geopandas處理的資料，可以使用to_json()這個方法將資料餵進去。 再次以新北的村里界資料為範例先把資料準備好並轉好坐標系統為epsg43261234567import geopandas as gpdvillage=gpd.read_file(&apos;data/village/village.shp&apos;,encoding=&apos;utf-8&apos;)village=village[village.is_valid]village=village[village[&apos;ADMIT&apos;]==&apos;永和區&apos;]village.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; # 避免資料沒設，這邊再重新給一次village=village.to_crs(epsg=4326)village=village.reset_index() 處理好的資料是GeoDataFrame丟進去，可以用to_json轉為geojson並直接丟進去folium 123456m = folium.Map((25.0133904,121.52245),zoom_start=14)folium.GeoJson( village.to_json(), name=&apos;geojson&apos;).add_to(m)m 如果要增加圖層開關，讓瀏覽的時候比較方便，可以加入LayerControl(用法跟leaflet差不多)1folium.LayerControl().add_to(m) 做個時序地圖folium有一個滿好用的套件TimeSliderChoropleth，可以快速做一個時間序列的資料展示他的基本操作如下：1234g = TimeSliderChoropleth( village.to_json(), styledict = styledict, ).add_to(m) 其中，styledict定義的是時序資料的值餵進去的資料需要按照要求為了演示，我們針對village隨機產生時序資料123456789101112131415161718import pandas as pdimport numpy as npn_periods = 24n_sample = 12assert n_sample &lt; n_periodsdt_index = pd.date_range(&apos;2012-1-1&apos;, periods = n_periods, freq=&apos;M&apos;).strftime(&apos;%s&apos;)styledata = &#123; &#125;for item in village.index: df = pd.DataFrame(&#123;&apos;color&apos;: np.random.normal(size=n_periods), &apos;opacity&apos;: np.random.normal(size=n_periods)&#125;, index = dt_index) df = df.cumsum() df.sample(n_sample, replace=False).sort_index() styledata[item] = dfstyledict = &#123;str(country): data.to_dict(orient=&apos;index&apos;) for country, data in styledata.items()&#125; 產生的資料結構是長這樣 我們把向量圖丟進去，並把上面產生的styledict也放進去123456789from folium.plugins import TimeSliderChoroplethm = folium.Map((25.0133904,121.52245), tiles=&quot;Cartodb Positron&quot;,zoom_start=14)g = TimeSliderChoropleth( village.to_json(), styledict = styledict, ).add_to(m)m 參考資料folium 後記folium還很很多功能，可以講個好幾天，之後幾天有機會再多看看吧！ 今天的練習請參考github","categories":[],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"2019鐵人賽-30天精通GIS資料分析-使用Python","slug":"2019鐵人賽-30天精通GIS資料分析-使用Python","permalink":"https://chimin17.github.io/tags/2019鐵人賽-30天精通GIS資料分析-使用Python/"}]},{"title":"鐵人賽2019 Day09 使用GeoPlot","slug":"ironman-2019-day09","date":"2018-10-24T14:13:33.000Z","updated":"2018-11-02T02:16:28.787Z","comments":true,"path":"2018/10/24/ironman-2019-day09/","link":"","permalink":"https://chimin17.github.io/2018/10/24/ironman-2019-day09/","excerpt":"另外一個GIS資料畫圖的利器是Geoplot，它擴充了cartopy與matplotlib，讓GIS資料的視覺化更方便，當然，他也設計給Geopandas作為其資料的端口。 有關geoplot的安裝，使用annaconda：conda install geoplot -c conda-forge","text":"另外一個GIS資料畫圖的利器是Geoplot，它擴充了cartopy與matplotlib，讓GIS資料的視覺化更方便，當然，他也設計給Geopandas作為其資料的端口。 有關geoplot的安裝，使用annaconda：conda install geoplot -c conda-forge 點資料首先是geoplot的pointplot模組，先來簡單plot點資料，並以顏色來區分行政區 一樣使用路燈資料，轉到epsg4326123456import geopandas as gpdlight=gpd.read_file(&apos;output/light.shp&apos;,encoding=&apos;utf-8&apos;)light=light[light.is_valid]light=light[light[&apos;district&apos;]==&apos;永和區&apos;]light.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; # 避免資料沒設，這邊再重新給一次light=light.to_crs(epsg=4326) geoplot對GeoDataframe有支援，所以可以直接餵進去12import geoplot as gpltgplt.pointplot(light, figsize=(16, 8)) 在geolot中，可以設定投影(import geoplot.crs)另外，geoplot.點資料pointplot，可以設定視覺變數，包含scale、hue都以作為視覺變數 為了測試，我們先用numpy隨機產生一個值year(假設是路燈的使用年數)12import numpy as nplight[&apos;year&apos;]=np.random.randint(low=0,high=20,size=light.shape[0]) 以hue(顏色)繪圖1gplt.pointplot(light, hue=&apos;year&apos;, figsize=(16, 8)) geoplot中也可以改變schema與投影，也可以放上圖例，跟昨天的mapplotib類似12import geoplot.crs as gcrsgplt.pointplot(light, projection=gcrs.AlbersEqualArea(), hue=&apos;year&apos;, legend=True, scheme=&apos;fisher_jenks&apos;, figsize=(16, 8)) 試著以scale作為視覺變數1gplt.pointplot(light, projection=gcrs.AlbersEqualArea(), scale=&apos;year&apos;, legend=True ,limits=(0, 8), figsize=(16, 8)) 如果想要混和兩種視覺變數也可以，我們多產生一個size，跟year一起呈現例如我們以顏色及scale來呈現資料12light[&apos;size&apos;]=np.random.randint(low=0,high=5,size=light.shape[0])gplt.pointplot(light, projection=gcrs.AlbersEqualArea(),hue=&apos;size&apos;, scale=&apos;year&apos;, legend=True ,limits=(0, 8), figsize=(40, 32)) 面量圖geolpot拿來畫面量圖也是頗方便我們拿村里圖來測試一下(用x上色= =’’)1234567village=gpd.read_file(&apos;data/village/village.shp&apos;,encoding=&apos;utf-8&apos;)village=village[village.is_valid]village=village[village[&apos;ADMIT&apos;]==&apos;永和區&apos;]village.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; # 避免資料沒設，這邊再重新給一次village=village.to_crs(epsg=4326)gplt.choropleth(village, hue=&apos;X&apos;, projection=gcrs.AlbersEqualArea(), legend=True, edgecolor=&apos;white&apos;, scheme=&apos;equal_interval&apos;,figsize=(16, 8)) 也可以畫累積圖(重現前幾天的圖~)1234567result=gpd.tools.sjoin(light[[&apos;geometry&apos;,&apos;year&apos;,&apos;size&apos;]], village[[&apos;ADMIV&apos;,&apos;ADMIT&apos;,&apos;geometry&apos;]], op=&apos;within&apos;,how=&quot;right&quot;)result[&apos;count&apos;]=1result=result.dissolve(by=&apos;ADMIV&apos;, aggfunc=&apos;sum&apos;)result[&apos;year&apos;]=result[&apos;year&apos;]/result[&apos;count&apos;]result[&apos;size&apos;]=result[&apos;size&apos;]/result[&apos;count&apos;]gplt.choropleth(result, hue=&apos;count&apos;, projection=gcrs.AlbersEqualArea(), legend=True, edgecolor=&apos;white&apos;, linewidth=0.5, scheme=&apos;equal_interval&apos;,figsize=(16, 8)) 或者是另外一種方式呈現資訊12ax =gplt.polyplot(village,projection=gcrs.AlbersEqualArea(), figsize=(16, 8))gplt.pointplot(light,ax=ax,projection=gcrs.AlbersEqualArea(), hue=&apos;year&apos;, legend=True) 熱區圖geoplot有heatmap的功能kdeplot熱區圖計算的是Kernel density，計算核密度12ax =gplt.polyplot(result,projection=gcrs.AlbersEqualArea(), figsize=(16, 8))ax=gplt.kdeplot(light,ax=ax,shade=True,projection=gcrs.AlbersEqualArea(),shade_lowest=False) 參考資料Gallery — geoplot 0.2.0 documentation 今天的相關測試可以參考GitHub","categories":[],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"2019鐵人賽-30天精通GIS資料分析-使用Python","slug":"2019鐵人賽-30天精通GIS資料分析-使用Python","permalink":"https://chimin17.github.io/tags/2019鐵人賽-30天精通GIS資料分析-使用Python/"}]},{"title":"鐵人賽2019 Day08 GIS資料基本繪圖","slug":"ironman-2019-day08","date":"2018-10-23T15:03:57.000Z","updated":"2018-11-02T02:16:26.529Z","comments":true,"path":"2018/10/23/ironman-2019-day08/","link":"","permalink":"https://chimin17.github.io/2018/10/23/ironman-2019-day08/","excerpt":"前幾天我們也有利用Geopandas裡面包的matplotlib做一些基本的繪圖GIS資料很常出現在日常生活的資訊視覺化，除了在資料工程上用在Data wrangling外，資料視覺化扮演著資訊發布的重任，GIS或是地圖的視覺化的學習與資源非常的多，今天我們以matplotlib，討論一下GIS資料視覺化的一些要素。","text":"前幾天我們也有利用Geopandas裡面包的matplotlib做一些基本的繪圖GIS資料很常出現在日常生活的資訊視覺化，除了在資料工程上用在Data wrangling外，資料視覺化扮演著資訊發布的重任，GIS或是地圖的視覺化的學習與資源非常的多，今天我們以matplotlib，討論一下GIS資料視覺化的一些要素。 投影的選擇坐標、投影原本就是GIS資料始終圍繞的主題，前面幾天提到坐標轉換，大多時候我們必須要把不同坐標系統的資料轉到同一個系統，才能一起做資料分析及處理在展示地圖時，也要面臨投影的問題因為地球是近似橢圓，地圖的製作實際上是將全部或局部的地球投影在面上，凡是投影都會有誤差，地圖上的投影會造成幾何的扭曲 使用matplotlib的basemap試著說明這些，首先，繪製全球海岸線的圖在產生basemap時，要先設定投影projection=’merc’，merc就是麥卡托投影12345from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltplt.figure(figsize=(16,8))m = Basemap(projection=&apos;merc&apos;,urcrnrlat=80, llcrnrlat=-80,llcrnrlon=-180, urcrnrlon=180) m.drawcoastlines(color=&apos;#0066CC&apos;) 為了方便觀察，加入繪製經緯線123# Draw lines of latitude (parallels) and longitude (meridians)m.drawparallels(range(-90,91,30), color=&apos;#CCCCCC&apos;)m.drawmeridians(range(-180,181,60), color=&apos;#CCCCCC&apos;) 為了理解投影的變形與誤差，我們可以在圖上繪製Tissot’s Indicatrix(底索變形橢圓)圓(橢圓)的變化代表的就是投影方法在不同區域造成的變形1234567# draw tissot&apos;s indicatrix to show distortion.for y in np.linspace(m.ymax/20, 19*m.ymax/20, 9): for x in np.linspace(m.xmax/20, 19*m.xmax/20, 9): lon, lat = m(x,y,inverse=True) poly = m.tissot(lon, lat, 1.5, 100, facecolor=&apos;#2ca25f&apos;, zorder=10, alpha=0.6);plt.show() 可以看到，在不同緯度，麥卡托投影對於全球不同地區有著不同程度的變形，我們在呈現資料時，特別是大範圍的資料，變形是必須面對的，當然適度的變形也是滿美的。 關於投影，這邊提供另外一個例子，適用在南北極的極投影npstere(North-Polar Stereographic) 123456789101112plt.figure(figsize=(16,8))m = Basemap(projection=&apos;npstere&apos;,boundinglat=10,lon_0=270,resolution=&apos;l&apos;)m.drawcoastlines()m.drawparallels(np.arange(-80.,81.,20.))m.drawmeridians(np.arange(-180.,181.,20.))for y in np.linspace(m.ymax/20,19*m.ymax/20,10): for x in np.linspace(m.xmax/20,19*m.xmax/20,10): lon, lat = m(x,y,inverse=True) poly = m.tissot(lon,lat,2.5,100,\\ facecolor=&apos;#2ca25f&apos;,zorder=10,alpha=0.5)plt.show() 接著是美國，以蘭伯特等方位投影(Lambert Azimuthal Equal Area)呈現1234567plt.figure(figsize=(16,8))m = Basemap(width=5e6,height=3e6,projection=&apos;laea&apos;,boundinglat=10, resolution=&apos;c&apos;,lat_0=39, lon_0=-96)m.drawcoastlines()m.drawcountries()m.drawstates()plt.show() 如果改以蘭伯特投影呈現，會有不同的效果123456789101112131415plt.figure(figsize=(16,8))plt.figure()m = Basemap( llcrnrlon=-119, llcrnrlat=22, urcrnrlon=-64, urcrnrlat=49, projection=&apos;lcc&apos;, lat_1=39, lon_0=-98 )m.drawcoastlines()m.drawcountries()m.drawstates()plt.show() 另外，其他比較常用到的投影包含： merc(Mercator): 麥卡托投影 tmerc(Transverse Mercator): 橫麥卡托投影 npstere,spstere(North(South)-Polar Stereographic): 極投影 lcc(Lambert Conformal: 蘭伯特投影 robin(Robinson): 羅賓森投影在matplotlib的basemap中的投影代碼請參考matplotlib basemap toolkit — Basemap Matplotlib Toolkit 1.1.0 documentation 由於各式投影要給的參數不同，今天只是簡單測試，關於如何選擇投影，可以參考What is a Map Projection?有一些說明，適度暸解投影的特性，會讓資料視覺化更成功 顏色/值域的正規化資訊圖表的視覺化需考量視覺變數，顏色是視覺變數的其中一個項目，以Day06 其它資料聚合與geohash的geohash成果為例(以下代碼同第六天)12345678910111213141516171819202122import geopandas as gpdlight=gpd.read_file(&apos;output/light.shp&apos;,encoding=&apos;utf-8&apos;)light=light[light.is_valid]light=light[light[&apos;district&apos;]==&apos;永和區&apos;]light.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; # 避免資料沒設，這邊再重新給一次light=light.to_crs(epsg=4326)import geohashlight[&apos;geohash&apos;]=[geohash.encode(row[&apos;geometry&apos;].y,row[&apos;geometry&apos;].x, precision=7) for idx,row in light.iterrows()]group=light.groupby(&apos;geohash&apos;)group=group.size().reset_index(name=&apos;counts&apos;)from shapely.geometry import Polygongeohashs=[]for idx,row in group.iterrows(): decoded=geohash.bbox(row[&apos;geohash&apos;]) geohashs.append(Polygon([(decoded[&apos;s&apos;], decoded[&apos;w&apos;]), (decoded[&apos;s&apos;],decoded[&apos;e&apos;]), (decoded[&apos;n&apos;], decoded[&apos;e&apos;]), (decoded[&apos;n&apos;],decoded[&apos;w&apos;])]))g = gpd.GeoSeries(geohashs)g_aggr = gpd.GeoDataFrame(group)g_aggr[&apos;geometry&apos;]=g 這個資料我們想以counts上色，我們第六天的時候，一切設定都是default值 然而，我們其實可以控制一些繪圖的參數 第一個可以控制的是cmap顏色類型1g_aggr.plot(&apos;counts&apos;,cmap=&apos;YlGn&apos;, figsize=(12, 12)) 給另外一種顏色1g_aggr.plot(&apos;counts&apos;,cmap=&apos;PiYG&apos;, figsize=(12, 12)) 顏色類型參考— Matplotlib 2.0.2 documentation 另外，還可以調整scheme，包含了‘equal_interval’, ‘quantiles’ or ‘percentiles’，也就是顏色間隔的計算方式1g_aggr.plot(&apos;counts&apos;,cmap=&apos;PiYG&apos;, scheme = &apos;equal_interval&apos;, figsize=(12, 12)) 還有k值，給定顏色的數量1g_aggr.plot(&apos;counts&apos;,cmap=&apos;PiYG&apos;, scheme = &apos;equal_interval&apos;,k=15, figsize=(12, 12)) 參考資料oreilly-matplotlib-course/07 - Mapping in matplotlib at master · croach/oreilly-matplotlib-course · GitHub 今天的相關測試可以參考GitHub","categories":[],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"2019鐵人賽-30天精通GIS資料分析-使用Python","slug":"2019鐵人賽-30天精通GIS資料分析-使用Python","permalink":"https://chimin17.github.io/tags/2019鐵人賽-30天精通GIS資料分析-使用Python/"}]},{"title":"鐵人賽2019 Day07 進階幾何資料處理","slug":"ironman-2019-day07","date":"2018-10-22T14:48:22.000Z","updated":"2018-10-23T15:30:37.813Z","comments":true,"path":"2018/10/22/ironman-2019-day07/","link":"","permalink":"https://chimin17.github.io/2018/10/22/ironman-2019-day07/","excerpt":"今天的主題是延續Day04 幾何資料基本運算，記錄一下在GIS向量資料中，可能會碰到但比較進階的幾何處理，今天的測試主要是圍繞在shapely的應用，shapely在Geopandas也有依賴，因此相關操作可以互相延伸。","text":"今天的主題是延續Day04 幾何資料基本運算，記錄一下在GIS向量資料中，可能會碰到但比較進階的幾何處理，今天的測試主要是圍繞在shapely的應用，shapely在Geopandas也有依賴，因此相關操作可以互相延伸。 在線資料中內插點shapely的interpolate滿方便的，我們知道向量資料包含了點線面，線與面是由一序列的點組成的，shapely的interpolate提供了一個方法，可以在這樣的序列資料中，沿著序列的方向內插一個點。 有關向量資料，請參考[Day 11] WebGIS中的向量圖層-除了點資料以外的幾何 為此，我們先產生兩個線做說明1234567import geopandas as gpdfrom shapely.geometry import LineString,Pointline1 = LineString([(0, 0), (50, 50), (100, 100)]) line2 = LineString([(10, 0), (60, 50), (110, 100)]) lines = gpd.GeoDataFrame()lines[&apos;geometry&apos;] = [line1,line2]lines.plot() 接著分別對資料做內插，其中distance是要內插的距離1234base=lines.plot()points = gpd.GeoDataFrame()points[&apos;geometry&apos;] = [row[&apos;geometry&apos;].interpolate(50) for idx,row in df.iterrows()]points.plot(ax=base) 內插多個點1234567base=lines.plot()points = gpd.GeoDataFrame()intpoints=[row[&apos;geometry&apos;].interpolate(50) for idx,row in df.iterrows()]intpoints+=[row[&apos;geometry&apos;].interpolate(25) for idx,row in df.iterrows()]intpoints+=[row[&apos;geometry&apos;].interpolate(75) for idx,row in df.iterrows()]points[&apos;geometry&apos;] = intpointspoints.plot(ax=base) projectshapely的project這個方法會回傳線資料對與一個點的投影距離，直接用案例來看:1LineString([(0, 0), (50, 50), (100, 100)]).project(Point(50,0)) 回傳值=35.3553390 我們把圖畫出來1234567lines = gpd.GeoDataFrame()lines[&apos;geometry&apos;] = [LineString([(0, 0), (50, 50), (100, 100)])]base=lines.plot()points = gpd.GeoDataFrame()points[&apos;geometry&apos;] = [Point(50,0)]points.plot(ax=base) project方法提供的，是(50,0)這個點，投影在線上的點p，這個點p距離線的原點(0,0)的距離 再看一個例子，這次我們特意把點指定在線上(投影就是自己)12345678lines = gpd.GeoDataFrame()lines[&apos;geometry&apos;] = [LineString([(0, 0), (50, 50), (100, 100)])]base=lines.plot()points = gpd.GeoDataFrame()points[&apos;geometry&apos;] = [Point(50,50)]points.plot(ax=base)LineString([(0, 0), (50, 50), (100, 100)]).project(Point(50,50)) 回傳值=70.710678 其中，70.710678其實就是(50,50)到這條線的原點(0,0)的距離 de-9im-relationshipsde-9im全名是(Dimensionally Extended nine-Intersection Model)，是一個GIS位向關係描述的模型及標轉，這個模型描述了兩個幾何物件的關係，它把兩個幾何物件的關係以物件的I(Interior),B(Boundary),E(Exterior)，兩物件之間的幾何關係以此3*3內的關係來判斷，這個矩陣就是de-9im，以下圖為例：[取自DE-9IM - Wikipedia] 上圖範例中，a及b為兩個面，他們之間的關係按I, B, E三個觀點切入，在矩陣內的Dim()函數表示此關係的維度。如果相交部分點則為0，線則為一維，dim()=1，面則dim()=2，而不相交為dim()=-1，de-9im的讀法可以中從上往下、從左往右將數字集合起來如本案例的212101212，這串數字就用來表達這兩個物件的關係。 這樣的模型再把它簡化一點，我們把維度dim()簡化成相交(0,1,2維)與不相交(-1)，分別以T與F表示，配合I, B, E三個角度的判斷，這樣也可以拿來描述兩個幾何物件的關係。 另外，我們常用的幾何物件關係的描述，若以de-9im表示，其實並不需要9個元素都判斷就可以判斷他們是否符合這個關係，例如以上兩個面相交的例子：實際上它是TTTTTTTTT事實上只要知道第一個T，就可以決定這種關係T******** 又例如兩個面分離(Disjoint)，他應符合：FF*FF****我們直接來測試，把第三天的資料再來拿看看更多的幾何關係可以參考Spatial Relations Defined 1234567891011p1=gpd.read_file(&apos;output/Library.shp&apos;,encoding=&apos;utf-8&apos;).head(1)p1.crs = &#123;&apos;init&apos; :&apos;epsg:4326&apos;&#125; # 避免資料沒設，這邊再重新給一次p1=p1.to_crs(epsg=3826)p1[&apos;geometry&apos;]=p1.buffer(30).translate(xoff=20.0, yoff=0.0)p2=gpd.read_file(&apos;output/Library.shp&apos;,encoding=&apos;utf-8&apos;).head(1)p2.crs = &#123;&apos;init&apos; :&apos;epsg:4326&apos;&#125; # 避免資料沒設，這邊再重新給一次p2=p2.to_crs(epsg=3826)p2[&apos;geometry&apos;]=p2.buffer(30)base=p1.plot(color=&apos;blue&apos;)p2.plot(ax=base,color=&apos;brown&apos;) 由於Geopandas的geometry是依賴於shapely，使用relate這個方法看看他的de-9im的值 1p1.at[0,&apos;geometry&apos;].relate(p2.at[0,&apos;geometry&apos;]) 回傳值=212101212 今天的相關測試可以參考GitHub","categories":[{"name":"data analysis","slug":"data-analysis","permalink":"https://chimin17.github.io/categories/data-analysis/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"2019鐵人賽-30天精通GIS資料分析-使用Python","slug":"2019鐵人賽-30天精通GIS資料分析-使用Python","permalink":"https://chimin17.github.io/tags/2019鐵人賽-30天精通GIS資料分析-使用Python/"}]},{"title":"鐵人賽2019 Day06 其它資料聚合與geohash","slug":"ironman-2019-day06","date":"2018-10-21T05:48:22.000Z","updated":"2018-10-21T05:54:25.712Z","comments":true,"path":"2018/10/21/ironman-2019-day06/","link":"","permalink":"https://chimin17.github.io/2018/10/21/ironman-2019-day06/","excerpt":"前一天的資料聚合，所舉的應用例是行政區村里，實作簡單的點資料與空間單元做結合，然而事實上，聚合的單元不限於行政區村里，以台灣來說，可以使用內政部最小統計區的空間單元來做資料聚合，最小統計區與其發佈區的劃設主要是根據人口，有關最小統計區請參考最小統計區圖｜MOI Open Data。 另外，也有特別針對其他用途的統計區：經濟統計區圖資| 政府資料開放平臺，或是如集水區等都可以採用前一天的方法，與點資料做整合，相關資料請自行參閱。 今天要介紹的也與昨日的資料聚合有一點關係-geohash","text":"前一天的資料聚合，所舉的應用例是行政區村里，實作簡單的點資料與空間單元做結合，然而事實上，聚合的單元不限於行政區村里，以台灣來說，可以使用內政部最小統計區的空間單元來做資料聚合，最小統計區與其發佈區的劃設主要是根據人口，有關最小統計區請參考最小統計區圖｜MOI Open Data。 另外，也有特別針對其他用途的統計區：經濟統計區圖資| 政府資料開放平臺，或是如集水區等都可以採用前一天的方法，與點資料做整合，相關資料請自行參閱。 今天要介紹的也與昨日的資料聚合有一點關係-geohash Geohashgeohash故名意思是一種編碼，包含了多層級的架構，將空間劃分為網格(分為1-12層)，Geohash的產生是根據Z-order curve的方式產生的，這樣的特性讓查詢上可以透過hash編碼的前綴來加快空間搜尋速度。 geohash被很常用在GIS資料的indexing上，他有點類似R-tree或Quadtree 以示意圖來理解geohash(取自GitHub - stephenlb/geohash-chat-by-proximity: Geo Hashing Chat by Proximity to connect two or more users to a group chat.) geohash的每個層級的網格的解析度大致如下：1 5,009.4km x 4,992.6km2 1,252.3km x 624.1km3 156.5km x 156km4 39.1km x 19.5km5 4.9km x 4.9km6 1.2km x 609.4m7 152.9m x 152.4m8 38.2m x 19m9 4.8m x 4.8m10 1.2m x 59.5cm11 14.9cm x 14.9cm12 3.7cm x 1.9cm 線上也有一些工具可以檢視及瀏覽geohash編碼Geohash encoding/decoding 瀏覽這個網站也會對geohash更有感覺GeohashExplorer project point to geohash我們直接簡單從python做一些測試，geohash是透過經緯度坐標系統建構的： 以路燈資料為例，先轉為經緯度資料1234567import geopandas as gpdlight=gpd.read_file(&apos;output/light.shp&apos;,encoding=&apos;utf-8&apos;)light=light[light.is_valid]light=light[light[&apos;district&apos;]==&apos;永和區&apos;]light.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; light=light.to_crs(epsg=4326)light 接著，直接我們使用pygeohash，precision 7 代表第七層 須先安裝，使用 pip install python-geohash 123import geohashlight[&apos;geohash&apos;]=[geohash.encode(row[&apos;geometry&apos;].y,row[&apos;geometry&apos;].x, precision=7) for idx,row in light.iterrows()]light 接著使用groupby12group=light.groupby(&apos;geohash&apos;)group=group.size().reset_index(name=&apos;counts&apos;) 我們試著把geohash解碼，geohash.bbox(0)提供geohash的邊界，我們把它轉為Polygob，把它存進去一個新的array12345from shapely.geometry import Polygongeohashs=[]for idx,row in group.iterrows(): decoded=geohash.bbox(row[&apos;geohash&apos;]) geohashs.append(Polygon([(decoded[&apos;s&apos;], decoded[&apos;w&apos;]), (decoded[&apos;s&apos;],decoded[&apos;e&apos;]), (decoded[&apos;n&apos;], decoded[&apos;e&apos;]), (decoded[&apos;n&apos;],decoded[&apos;w&apos;])])) 我們把資訊畫出來吧：1234g = gpd.GeoSeries(geohashs) g_aggr = gpd.GeoDataFrame(group)g_aggr[&apos;geometry&apos;]=gg_aggr.plot(&apos;counts&apos;) 後記透過今天的練習，利用geohash也可以進行網格式的資料聚合以及多時期的資料分析。 今天的相關測試可以參考GitHub","categories":[{"name":"data analysis","slug":"data-analysis","permalink":"https://chimin17.github.io/categories/data-analysis/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"2019鐵人賽-30天精通GIS資料分析-使用Python","slug":"2019鐵人賽-30天精通GIS資料分析-使用Python","permalink":"https://chimin17.github.io/tags/2019鐵人賽-30天精通GIS資料分析-使用Python/"}]},{"title":"鐵人賽2019 Day05 基本的資料聚合","slug":"ironman-2019-day05","date":"2018-10-20T04:42:43.000Z","updated":"2018-10-20T04:54:26.403Z","comments":true,"path":"2018/10/20/ironman-2019-day05/","link":"","permalink":"https://chimin17.github.io/2018/10/20/ironman-2019-day05/","excerpt":"在Pandas可以使用groupby等方法進行資料聚合例如先前第三天的路燈資料，如果想看一下不同的統計成果，除了空間上的展示外，可以用資料內的行政區欄位(district)做聚合 回顧這份資料，有district欄位表示行政區 12light=gpd.read_file(&apos;output/light.shp&apos;,encoding=&apos;utf-8&apos;)light 我們可以很簡單的用groupy做資料的的聚合1light.groupby(&apos;district&apos;).size()","text":"在Pandas可以使用groupby等方法進行資料聚合例如先前第三天的路燈資料，如果想看一下不同的統計成果，除了空間上的展示外，可以用資料內的行政區欄位(district)做聚合 回顧這份資料，有district欄位表示行政區 12light=gpd.read_file(&apos;output/light.shp&apos;,encoding=&apos;utf-8&apos;)light 我們可以很簡單的用groupy做資料的的聚合1light.groupby(&apos;district&apos;).size() 如果資料中沒有這樣的屬性呢？(例如第三天的另一份圖書館點為資料)在GIS資料中，我們可以對資料做空間聚合，聚合的單元可以是面資料。 路燈及圖書館資料請參考及Day03 從Pandas到Geopandas的幾種方法 spatial join首先我們下載村里界圖新北市政府資料開放平台，試著把圖書館資料與其做連結 把村里界圖讀進來，稍作觀察1234import geopandas as gpdvillage=gpd.read_file(&apos;data/Village/Village.shp&apos;,encoding=&apos;utf-8&apos;)village.crs= &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; # 避免資料沒設，這邊再重新給一次village.head(3) 可以看出來ADMIV及ADMIT是村里與行政區 把圖書館資料有讀進來1234lib=gpd.read_file(&apos;output/library.shp&apos;,encoding=&apos;utf-8&apos;)lib.crs= &#123;&apos;init&apos; :&apos;epsg:4326&apos;&#125; # 避免資料沒設，這邊再重新給一次lib=lib.to_crs(epsg=3826)lib.head(3) 從上面可以看到，這份圖書館沒有行政區的資訊，無法直接產出如前面的統計表，但是由於我們有村里的GIS資料，可利用資料間的空間關係整合，在此特別在提醒，請記得轉換空間坐標，讓兩者系統一致喔。 坐標轉換請參考前一天的文章： Day04 幾何資料基本運算 先把他們套疊(ps.為了方便顯示，只選擇中和區)12base=village[village[&apos;ADMIT&apos;]==&apos;中和區&apos;].plot(color=&apos;yellow&apos;)lib[lib[&apos;address&apos;].str.contains(&apos;中和區&apos;)].plot(ax=base) 從上得知，我們應該可以從空間關係取得我們要的東西，使用的是spatial join(sjoin)12result = gpd.tools.sjoin(lib, village[[&apos;ADMIV&apos;,&apos;ADMIT&apos;,&apos;geometry&apos;]], how=&quot;left&quot;)result 其中，how是選擇要left join或是right, inner join，op則是空間關聯的方法，有contains, within, intersects可以選擇，我們選within，因為我們想計算點被包含在哪些村里界中 spatial join完成後，我們就可以做groupy，達到前面的效果12group=result.groupby([&apos;ADMIT&apos;,&apos;ADMIV&apos;])group.size().reset_index(name=&apos;counts&apos;) 除了表格的展示，可以展點在圖上，並以行政區做上色1result.plot(&apos;ADMIT&apos;) 然而，如果要以地圖展示的話，可能不夠清楚，把村里的圖也納進來一起顯示吧！ aggregation為了產生這樣的資訊，可以先計算village圖層涵蓋到的點數量，這之中會參考到昨天的幾何基本運算，這邊使用intersects，計算counts，也就是包含的點數量。 12345import numpy as npcounts=[np.sum(row[&apos;geometry&apos;].intersects(lib.unary_union)) for idx, row in village.iterrows()]village[&apos;count&apos;]=countsaggre_v=village[[&apos;ADMIV&apos;,&apos;ADMIT&apos;,&apos;count&apos;,&apos;geometry&apos;]]aggre_v[aggre_v[&apos;count&apos;]&gt;0] 展示一下，並以count上色1aggre_v.plot(&apos;count&apos;) dissolve試著再把資料做一次聚合，使用行政區上色，會用到dissolve，其中第一個參數是要dissolve的欄位，aggfunc則是欄位中被合併的資料呈現的方式，我們這邊的聚合方式當然是sum 12dis=aggre_v.dissolve(&apos;ADMIT&apos;,aggfunc=&apos;sum&apos;)dis 最後，展示成果 後記今天的練習在QGIS等軟體都可以很方便做到，在Geopandas中，也是透過幾行程式碼就可以操作到這些效果，並且更具彈性。 今天的相關測試可以參考GitHub","categories":[{"name":"data analysis","slug":"data-analysis","permalink":"https://chimin17.github.io/categories/data-analysis/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"2019鐵人賽-30天精通GIS資料分析-使用Python","slug":"2019鐵人賽-30天精通GIS資料分析-使用Python","permalink":"https://chimin17.github.io/tags/2019鐵人賽-30天精通GIS資料分析-使用Python/"}]},{"title":"鐵人賽2019 Day04 幾何資料基本運算","slug":"ironman-2019-day04","date":"2018-10-19T12:21:22.000Z","updated":"2018-10-20T04:46:35.141Z","comments":true,"path":"2018/10/19/ironman-2019-day04/","link":"","permalink":"https://chimin17.github.io/2018/10/19/ironman-2019-day04/","excerpt":"GeoDataFrame使操作GIS資料分析時更有彈性我們可以很快對GIS的屬性資料的分析與過濾 當然，也包括一些幾何空間的運算 坐標轉換坐標轉換幾乎是GIS第一門課，可以參考[Day10] 坐標系統及WebGIS常用的坐標轉換有大致的說明。","text":"GeoDataFrame使操作GIS資料分析時更有彈性我們可以很快對GIS的屬性資料的分析與過濾 當然，也包括一些幾何空間的運算 坐標轉換坐標轉換幾乎是GIS第一門課，可以參考[Day10] 坐標系統及WebGIS常用的坐標轉換有大致的說明。 Geopandas依賴pyrpoj，坐標轉換操作也很簡單我們以昨天的圖書館資料為例，它是epsg4326，試著轉成TWD97(epsg3826)在同一坐標系統的資料才能一起操作 有關圖書館資料，請參考Day03 從Pandas到Geopandas的幾種方法 12345import geopandas as gpdgdf_Lib=gpd.read_file(&apos;output/Library.shp&apos;,encoding=&apos;utf-8&apos;)gdf_Lib.crs = &#123;&apos;init&apos; :&apos;epsg:4326&apos;&#125; # 避免資料沒設，這邊再重新給一次gdf_Lib=gdf_Lib.to_crs(epsg=3826)gdf_Lib 可以看到坐標系統已經成果轉換(4326–&gt;3826) 幾何操作接下來來進行基本的幾何運算，Geopandas的幾何操作主要是來自shaply套件，以下來試看看在GIS軟體常用的功能 bufferbuffer在GIS中常用來分析點線面的影響範圍，這邊採用上面圖書館的資料採用buffer這個方法，參數為環域距離由於坐標系統已經轉為TWD97，因此距離的設定的單位為公尺 而為了做比較，我們只取資料的第一筆做buffer，並把原始的點也放上去123base=gdf_Lib.head(1).buffer(100).plot()gdf_Lib.head(1).plot(ax=base, marker=&apos;o&apos;, color=&apos;red&apos;, markersize=30); areaarea是GeoDataFrame所有每一筆資料的面積12345buffer=gdf_Lib.head(1).buffer(100)area=buffer.areaprint(area[0])### # 0 31365.4849055 envelopeenvelope是整個GeoDataFrame每一筆資料包覆的長方形範圍12345envelope=buffer.envelopeprint(envelope)# 0 POLYGON ((295824.3464126067 2765944.031022599,... convex_hullconvex hull則是包住每一個資料的多邊形1234convexhull=buffer.convex_hullprint(convexhull)### 0 POLYGON ((295924.3464126067 2765944.031022599,... 可以Plot一下convex hull與envelope，連同點的buffer一起套疊123base=envelope.plot()convexhull.plot(ax=base,color=&apos;brown&apos;)gdf_Lib.head(1).plot(ax=base, color=&apos;red&apos;); 可以發現convex hull與envelope的差異，並且convex hull與buffer的結果一樣(因為包住圓的convex hull 也是圓..不好意思這個例子舉不太好) 幾何轉換可以進行幾何的投影轉換，可以對資料進行仿射轉換(Affine Transform)，包含了兩個平移、兩個尺度、一個剪力以及一個旋轉 這邊只舉尺度轉換的例子，分別在x方向10倍及y方向5倍的投影，並與原本的buffer做比較。12base=buffer.scale(10,5).plot(color=&apos;yellow&apos;)buffer.plot(ax=base,color=&apos;brown&apos;) 其餘的一些操作在Shapely的官方文件有滿多說明的，特別是對幾何資料的一些檢查，建議有需要時瀏覽一遍Shapely的參考文件The Shapely User Manual — Shapely 1.2 and 1.3 documentation 空間運算子前半部說明的主要為資料內部的計算，在此空間運算子是屬於資料與資料之間的運算與分析 常見的GIS運算包含了幾項運算子，如[取自Geopandas官方] 為了方便說明，我們把前面buffer的成果做一些處理，p1是把buffer成果做一些平移，p2則是原本buffer的結果123456789p1=gpd.read_file(&apos;output/Library.shp&apos;,encoding=&apos;utf-8&apos;).head(1)p1.crs = &#123;&apos;init&apos; :&apos;epsg:4326&apos;&#125; # 避免資料沒設，這邊再重新給一次p1=p1.to_crs(epsg=3826)p1[&apos;geometry&apos;]=p1.buffer(30).translate(xoff=20.0, yoff=0.0)p2=gpd.read_file(&apos;output/Library.shp&apos;,encoding=&apos;utf-8&apos;).head(1)p2.crs = &#123;&apos;init&apos; :&apos;epsg:4326&apos;&#125; # 避免資料沒設，這邊再重新給一次p2=p2.to_crs(epsg=3826)p2[&apos;geometry&apos;]=p2.buffer(30) intersectionintersection是交集，我們分別使用不同的顏色，交集的部分是黃色1234intersection = gpd.overlay(p1,p2, how=&apos;intersection&apos;)base=p1.plot(color=&apos;blue&apos;)p2.plot(ax=base,color=&apos;brown&apos;)intersection.plot(ax=base,color=&apos;yellow&apos;) union聯集1234union = gpd.overlay(p1,p2, how=&apos;union&apos;)base=p1.plot(color=&apos;blue&apos;)p2.plot(ax=base,color=&apos;brown&apos;)union.plot(ax=base,color=&apos;yellow&apos;) difference算出兩個幾何的差異，一樣以黃色表示1234difference = gpd.overlay(p1,p2, how=&apos;difference&apos;)base=p1.plot(color=&apos;blue&apos;)p2.plot(ax=base,color=&apos;brown&apos;)difference.plot(ax=base,color=&apos;yellow&apos;) 以上就簡單測試一些幾何運算子，未來幾天有機會會在應用到這些方法 今天的相關測試可以參考GitHub","categories":[{"name":"data analysis","slug":"data-analysis","permalink":"https://chimin17.github.io/categories/data-analysis/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"2019鐵人賽-30天精通GIS資料分析-使用Python","slug":"2019鐵人賽-30天精通GIS資料分析-使用Python","permalink":"https://chimin17.github.io/tags/2019鐵人賽-30天精通GIS資料分析-使用Python/"}]},{"title":"鐵人賽2019 Day03 從Pandas到Geopandas的幾種方法","slug":"ironman-2019-day03","date":"2018-10-18T13:23:01.000Z","updated":"2018-10-19T13:00:20.974Z","comments":true,"path":"2018/10/18/ironman-2019-day03/","link":"","permalink":"https://chimin17.github.io/2018/10/18/ironman-2019-day03/","excerpt":"Geopandas可以讀取各GIS格式進行空間運算，然而實際上我們可能拿到的資料不見得是GIS的格式 不是GIS格式，但它可能是有坐標資訊的資料 比較常見的會是一個csv,Excel含有經緯度或xy的資料，對於這樣的資料，我們可以把它轉為Geopandas的GeoDataFrame。","text":"Geopandas可以讀取各GIS格式進行空間運算，然而實際上我們可能拿到的資料不見得是GIS的格式 不是GIS格式，但它可能是有坐標資訊的資料 比較常見的會是一個csv,Excel含有經緯度或xy的資料，對於這樣的資料，我們可以把它轉為Geopandas的GeoDataFrame。 用Pandas讀取csv或Excel為了今天的範例，我們下載[新北市路燈資料]，下載該數據的csv檔，命名為Light.csv第一步先使用Pandas讀取csv為DataFrame12import pandas as pd df=pd.read_csv(&apos;data/Light/Light.csv&apos;,encoding=&apos;utf-8&apos;) ps.如果沒有pandas請記得安裝1conda install pandas 瀏覽一下這份資料可以看到這份資料具有TWD97X, TWD97Y坐標欄位。接下來，我們試著把X,Y轉換成GeoDataFrame DataFrame轉為Geodataframe前一天提到GeoDataFrame包含geometry的屬性，因此，要產生GeoDataFrame，需要產生geometry這時候需要用shapely套件中的geometry我們使用之中的Point類型，並把TWD97X, TWD97Y包成geom123from shapely.geometry import Pointimport geopandas as gpdgeom = [Point(xy) for xy in zip(df.TWD97X, df.TWD97Y)] 有了geom，我們可以用來產生GeoDataFrame，其中，需要指定crs，由於TWD97X, TWD97Y的坐標是TWD97，為epsg:3826 [Day10] 坐標系統及WebGIS常用的坐標轉換123crs = &#123;&apos;init&apos;: &apos;epsg:3826&apos;&#125;gdf = gpd.GeoDataFrame(df, crs=crs, geometry=geom)gdf 就這樣，我們成功把csv轉成了GeoDataFrame，然後我們就可以做GeoDataFrame能做的事把永和區的資料畫圖來，並以address為color code繪圖，1gdf[gdf[&apos;district&apos;]==&apos;永和區&apos;].plot(column=&apos;address&apos;) Geocoding像是今天的資料集[新北市路燈資料]是一個具有XY的資料，如果今天資料中沒有XY，我們還是可以透過一些Geocoding方法取得坐標在[Day 9] 自己產製資料-地址定位part2提到可以使用TGOS來進行門牌地址的Geocoding。 為了一次性的完成Geocoding，接下來以TomTom Developer Portal Geocode的Geocoding為例(個人經驗是會有較好的成果) 首先，必須要取得一個api key，方法很簡單，按照官網方法操作就好User account | TomTom Developer Portal 假設以順利取得api的key，我們現在以新北市各圖書館地址電話表為範例，下載csv使用 首先，跟上面一樣，用Pandas讀取csv123import pandas as pd df=pd.read_csv(&apos;data/Library/Library.csv&apos;,encoding=&apos;utf-8&apos;)df 接著我們寫一個函式處理Geocoding，呼叫的方法及回應的格式直接參考TomTom Developer Portal Geocode的說明 其中，YOUR_KEY必須填入你的api key!123456789import requests,jsondef rest(address): url = &apos;https://api.tomtom.com/search/2/geocode/&#123;&#125;.json?&amp;key=YOUR_KEY&amp;countrySet=TWN&amp;language=zh-TW&amp;limit=1&apos;.format( address) response = requests.get(url) data = response.text js = json.loads(str(data)) return js[&apos;results&apos;][0][&apos;position&apos;] ps. requests需要安裝，1conda install requests 然後使用這個rest函式，產生geometry(命名為geom) 12# 這邊使用df.head()只取前五筆測試geom=[Point(rest(row.address)) for idx, row in df.head().iterrows()] 有了geom就可以產生GeoDataFrame了，要注意的是，這邊的坐標是WGS84，也就是epsg:4326123crs = &#123;&apos;init&apos;: &apos;epsg:4326&apos;&#125;gdf = gpd.GeoDataFrame(df.head(), crs=crs, geometry=geom)gdf 一樣，看看成果吧 GeoDataFrame可以輸出成GIS格式，用以在其他平台檢視與處理，包含常用的shp或是geojson1gdf.to_file(driver = &apos;ESRI Shapefile&apos;, filename = &apos;output/Light.shp&apos;) 今天的相關測試可以參考GitHub","categories":[{"name":"data analysis","slug":"data-analysis","permalink":"https://chimin17.github.io/categories/data-analysis/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"2019鐵人賽-30天精通GIS資料分析-使用Python","slug":"2019鐵人賽-30天精通GIS資料分析-使用Python","permalink":"https://chimin17.github.io/tags/2019鐵人賽-30天精通GIS資料分析-使用Python/"}]},{"title":"鐵人賽2019 Day02 Geopandas初探","slug":"ironman-2019-day02","date":"2018-10-17T12:15:01.000Z","updated":"2018-10-19T12:54:49.041Z","comments":true,"path":"2018/10/17/ironman-2019-day02/","link":"","permalink":"https://chimin17.github.io/2018/10/17/ironman-2019-day02/","excerpt":"Pandas是資料分析熱門且好用的工具，相信熟悉資料分析的各路英雄好漢都不陌生在Python中，與GIS相關的套件滿坑滿谷，這邊我們選定Geopandas作為資料操作的基礎它與Pandas有很接近的操作體驗，並且依賴了許多GIS常用的Python套件。 Geopandas介紹在Python上處理空間資料有許多套件們，這些套件都有不同的使用場景，例如shapely用在向量資料的處理、fiona則是幫助使用Python上操作OGR(支援超多格式的資料轉換)，pyproj做坐標投影的轉換等等。","text":"Pandas是資料分析熱門且好用的工具，相信熟悉資料分析的各路英雄好漢都不陌生在Python中，與GIS相關的套件滿坑滿谷，這邊我們選定Geopandas作為資料操作的基礎它與Pandas有很接近的操作體驗，並且依賴了許多GIS常用的Python套件。 Geopandas介紹在Python上處理空間資料有許多套件們，這些套件都有不同的使用場景，例如shapely用在向量資料的處理、fiona則是幫助使用Python上操作OGR(支援超多格式的資料轉換)，pyproj做坐標投影的轉換等等。 還好，Geopandas的出現，讓這些事情變得比較好上手，也讓分析資料時感受很像Pandas，他主要依賴了以下Python空間資料處理的套件介面： shapely fiona descartes matplotlib pyproj numpy..more 使用者可以跟Pandas操作DataFrame一般，在Geopandas操作GeoDataFrame，並且擁有許多空間資料處理的功能。在Python環境中使用GeoPandas，依照官方文件的說明，安裝方法有兩種，第一種是使用Conda(請設定Python3.6環境)： 1conda install -c conda-forge geopandas 或是直接透過Geopandas Repo以pip安裝 1pip install git+git://github.com/geopandas/geopandas.git 讀寫GIS資料今天所使用的GIS資料為向量資料其中shp為空間資料中最為常見的一種向量資料的格式，它可以紀錄點、線、面等幾何 有關向量資料及格式的暸解，可以參考[Day 6] 常見的GIS資料格式 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 我們可以利用GeoPandas讀取shp資料，以進行我們想要的各種處理或分析，以[臺灣鐵路 | 政府資料開放平臺]這個資料集為例，我們將其下載到本機，使用GeoPandas讀取為GeoDataFrame 123import geopandas as gpdgdf_Rail=gpd.read_file(&apos;data/Rail/Rail.shp&apos;,encoding=&apos;utf-8&apos;)gdf_Rail GeoPandas也支援常用的格式 GeoDataFrameGeoDataFrame與DataFrame類似，在[官方文件]中對於DataFrame的基本類型有一些說明。 簡單來說，與dataframe相對，GeoPandas多了一個geometry的欄位。 Like a DataFrameGeoDataFrame的許多基本操作與Pandas的DataFrame很我們試著做一些Pandas上可以做的事情， 選擇欄位1subset=gdf_Rail[&apos;RAILNAME&apos;] subset again1subset=gdf_Rail.iloc[:3] 排序資料1sample=gdf_Rail.sort_values(by=&apos;MDATE&apos;) 另外，GeoDataFrame對於地理資料有基本的繪圖功能 1sample.plot() 其採用matplotlib繪圖引擎，例如可以依照欄位來繪圖(下面案例是以鐵道支線名稱分色)1sample.plot(column=&apos;RAILNAME&apos;) GeoDataFrame讓GIS資料處理更方便，他與DataFrame操作體驗接近，今天也初探了一些簡單的功能 對於DataFrame或者GeoDataFrame的操作，可以參考Data wrangling with Pandas的圖表，對於Pandas的功能有一些快速指南，大部分也都通用於Geopandas。 今天的相關測試可以參考GitHub","categories":[{"name":"data analysis","slug":"data-analysis","permalink":"https://chimin17.github.io/categories/data-analysis/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"2019鐵人賽-30天精通GIS資料分析-使用Python","slug":"2019鐵人賽-30天精通GIS資料分析-使用Python","permalink":"https://chimin17.github.io/tags/2019鐵人賽-30天精通GIS資料分析-使用Python/"}]},{"title":"鐵人賽2019 Day01 前言","slug":"ironman-2019-day01","date":"2018-10-16T12:12:33.000Z","updated":"2018-10-17T12:23:58.000Z","comments":true,"path":"2018/10/16/ironman-2019-day01/","link":"","permalink":"https://chimin17.github.io/2018/10/16/ironman-2019-day01/","excerpt":"地理空間資料或簡稱GIS資料，無論是學術研究、資料科學、商業分析、或是各種資料採集等，或多或少都需要與空間資料相處。 或許各路GIS相關的工作者，常會覺得明明空間資料與非空間資料差異只在於有無坐標資料，但實際處理起來卻常常遇到各種坑苦。 有感於此，希望藉由這次鐵人賽的砥礪，攻略實務上處理GIS資料時更進階及更自動化的工具與技巧。 這次30天的任務，主要以Python為主軸，配合QGIS及空間資料庫，熟悉GIS工作的自動化流程，解決空間資料分析或是資料工程上的問題。","text":"地理空間資料或簡稱GIS資料，無論是學術研究、資料科學、商業分析、或是各種資料採集等，或多或少都需要與空間資料相處。 或許各路GIS相關的工作者，常會覺得明明空間資料與非空間資料差異只在於有無坐標資料，但實際處理起來卻常常遇到各種坑苦。 有感於此，希望藉由這次鐵人賽的砥礪，攻略實務上處理GIS資料時更進階及更自動化的工具與技巧。 這次30天的任務，主要以Python為主軸，配合QGIS及空間資料庫，熟悉GIS工作的自動化流程，解決空間資料分析或是資料工程上的問題。 雖然QGIS及ArcGIS中，也支援Python程式的包裝PyQGIS與ArcPy，使用者可以撰寫程式、拉Model或是Macro等，在許多情境下，已經可以解決大多數問題。 然而GIS資料常是眾多資料流的一部分，以軟體架構角度如果資料流必須跳到另外一個軟體或環境執行，總是覺得不太順遂。因此這30天挑戰的目標將是以Coding方式處理GIS資料，主要是利用Python作為資料分析的語言，當然也會加入一些軟體的輔助。 GIS軟體儘管好用，但若GIS資料是一個資料流的一部分，不允許中斷另以其它軟體做處理，此時，動手寫程式處理GIS資料是必須的，有些時候，撰寫程式會比操作軟體還要方便一些！ 目標架構在起始階段，原本先構想先規劃一下30天中每一天的目標，但仔細想想，常常寫到一半會發現新多東西或挑戰，很難一次定義清楚每日目標，但整個範疇應該會包含： Python 基本GIS資料處理 資料視覺化 空間資料庫 結合各種資料集 GIS資料採集 GIS資料分析 開發環境這30天的挑戰會有一些程式碼案例，如果對提供的案例有興趣，歡迎自行測試，測試的環境為Python3，若沒有Python環境建置相關經驗，建議使用Annaconda建置Python3環境，使用Jupyter Notebbook作測試，詳細過程可以參考：[第 01 天] 建立開發環境與計算機應用 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天","categories":[{"name":"data analysis","slug":"data-analysis","permalink":"https://chimin17.github.io/categories/data-analysis/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"2019鐵人賽-30天精通GIS資料分析-使用Python","slug":"2019鐵人賽-30天精通GIS資料分析-使用Python","permalink":"https://chimin17.github.io/tags/2019鐵人賽-30天精通GIS資料分析-使用Python/"}]},{"title":"鐵人賽Day 30- 最重要的回顧","slug":"ironman-2018-day30","date":"2018-01-19T12:12:33.000Z","updated":"2018-10-16T13:33:17.473Z","comments":true,"path":"2018/01/19/ironman-2018-day30/","link":"","permalink":"https://chimin17.github.io/2018/01/19/ironman-2018-day30/","excerpt":"第30天了，來回顧一下並發表心得吧！ 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 30天的發文大綱這30天的大綱可以切為6塊，分述如下：","text":"第30天了，來回顧一下並發表心得吧！ 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 30天的發文大綱這30天的大綱可以切為6塊，分述如下： 第1天到第5天:起步 一開始撰寫這幾篇文章的目標主要在加深WebGIS的觀念，雖然地圖應用在d3.js資料視覺化與Google Maps的發展下，已經讓很多人認識網頁與地圖，但因為過去學的是測量及地理空間資訊，撰寫鐵人賽本意是再把一些資源及觀念整理，所以這幾天從WebGIS元素到互操作性，並透過CartoDB視覺化GIS資料，希望能讓看的人看到WebGIS這個topic。 第6天到第10天: 動手做資料 這幾天的課題是資料的產製，主要是針對POI資料的自製，如果手邊有一份資料要做成POI，要使用什麼格式、要怎麼地址定位、坐標系統跟坐標轉換會是開發者遇到重要的課題，因此，這幾天介紹了一些概念及方便的工具以方便Web開發者參考。 第11天到第15天: 了解資料型態及使用資源 有了自己的資料以後，接下來是該怎麼把資料放到WebGIS，再者，如何運用其他外部資源也是這幾天想整理的，林林總總講了向量資料、網格資料及網路上的WMS資源都有所觸及。 第16天到第21天: 實作 透過Leaflet實作WebGIS，最重要的是掌握GIS資料處理的一些精華，包含了基本展示、比較核心的內插、空間運算函式庫及方法介紹，大致掌握了在前端程式內插、TIN、Voronoi、熱區圖與風場圖等。 第22到第27天: 擴充 已經是後半段了，所以介紹一些對WebGIS中算是外掛元素，包含導航功能、街景、圖表互動等等，另外也非常簡短介紹了空間資料庫，資料庫對WebGIS或GIS來說是另一個非常重要的核心。 第28到30天: 收尾 最後這幾天已經到了收尾階段，帶過一些3D GIS的想法及有趣的WebGIS的案例，最後就是今天的回顧。 小結：這30天把一些資訊做了整理，其實都是WebGIS應用會遇到的環節，WebGIS雖然說是Web，在GIS資料面及應用上總是容易入門卻難以深入的，藉由鐵人賽也加強了自己對WebGIS的暸解。 Good這次呈現的主題觸及項目跟當初規劃的差不多，特別是在資料面的問題，在WebGIS案例上多加一些比較GIS的部分，重要的是都有在時間內完成，專案執行的很滿意XD，而這次鐵人賽除了文章上面呈現的，其實更重要的是幕後資料的整理，看了很多開源的專案，也動手特別針對某些議題實作，無論最重有無寫出來，能在短時間內有主題性的去瀏覽或深入這些專案，儘管可能還沒整理好po出來，在開發生涯中也是難得經驗。 Bad有些環節有些可惜，要如何在短時間有限的篇幅濃縮內容，真的很難；而在程式面上，因擔心credit及主題發散問題code是寫在一起沒有架構的XD；另外例如PostGIS資料庫及MongoDB的應用在有限章節中無法實踐太多案例，每日與這些資料庫相處卻有種短時間無法說的簡單並清楚的窘態。 Acknowledgment最後一天必需感謝老婆的支持，晚上不睡覺搞這個真的有點肖，過程中所有幫忙及討論的前團隊同事也謝謝你們。 Future下次見，身為GIS人，也會持續分享GIS的一切並放在github上。也希望可以多跟有興趣的朋友多交流!","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"}]},{"title":"鐵人賽Day 29- WebGIS大觀園","slug":"ironman-2018-day29","date":"2018-01-18T14:02:33.000Z","updated":"2018-10-16T13:33:11.931Z","comments":true,"path":"2018/01/18/ironman-2018-day29/","link":"","permalink":"https://chimin17.github.io/2018/01/18/ironman-2018-day29/","excerpt":"前言到了第29天，想講的東西很多，但能寫的時間不多XD，所以決定在倒數第二天來看一些有趣的WebGIS。","text":"前言到了第29天，想講的東西很多，但能寫的時間不多XD，所以決定在倒數第二天來看一些有趣的WebGIS。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” Story Map -The Bare EarthThe Bare Earth這個網站利用Story Map的概念，以說故事的方式展示了許多GIS在地質上的應用及名詞解釋，除了資料處理上用了各種GIS內插、視覺化、空間運算等技術外，Web上也使用了大量的swipe雙視窗的功能。 3D Bar Chart- 3D Feinstaub Berlin3D-Feinstaub Berlin網站是在Maps Mania上看到的，以3D視角加上bar chart做視覺展示，所展示的資料是污染物測站的觀測量，並有一個heatmap的開關可供結合，在3D GIS當紅的時代，這種3D GIS視覺化的應用越來越多。 Indoor Map室內GIS應該是未來幾年GIS的發展方向，包含OSM Indoor Mapping也越來越多貢獻者，隨著室內定位技術逐漸提升，無論在資料生產維護或是應用開發的部分，會有越來越多室內GIS應用的產品出現，在WebGIS方面應該也會有所變化，這是從esri網站上看到的案例IndoorMaps ParisMall，Leaflet上也有類似的發表。 FlowMap、百度Echarts3與Pixi.js的應用WebGIS與人類生活做息息相關的就是交通，也隨著各種交通數據的整合及應用相關視覺化的表現越來越豐富，例如Leaflet上的案例Flowmap及赫赫有名的百度Echarts3，另外各種WebGL(e.g. Pixi with Leaflet)在地圖上的結合也是越來越常見到。","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"Leaflet","slug":"Leaflet","permalink":"https://chimin17.github.io/tags/Leaflet/"}]},{"title":"鐵人賽Day 28- WebGL與3D GIS概觀","slug":"ironman-2018-day28","date":"2018-01-17T00:02:33.000Z","updated":"2018-10-16T13:33:07.486Z","comments":true,"path":"2018/01/17/ironman-2018-day28/","link":"","permalink":"https://chimin17.github.io/2018/01/17/ironman-2018-day28/","excerpt":"3D GISWebGIS已經逐步走向3D GIS時代，雖然說3D GIS已經發展很多年了，也有Google Earth這樣的產品，不過真的3D GIS在這幾年才比較有大進展，突破原因除了資料獲取的技術提升以外，主要還是跟Web技術息息相關，其中WebGL佔了重要角色。 3D GIS雖然過去有Google Earth這種霸王級產品，但是其應用有限，而要說這幾年3D GIS發展及前進的速度可說是過去的好幾倍，這與WebGL發展有關，目前3D GIS仍是百家爭鳴階段，連互操作相關議題才剛有幾家大型龍頭爭奪完畢好讓自己的格式成為OGC標準(ESRI I3S勝出)，姑且不論很早起就已ready for use的3D空間分析演算法(與2D差異甚多)，3D GIS在格式、資料方面都與2D截然不同，所以，既然如此，今天就不討論那些，來瀏覽看看一些WebGL for 3D GIS的範例。","text":"3D GISWebGIS已經逐步走向3D GIS時代，雖然說3D GIS已經發展很多年了，也有Google Earth這樣的產品，不過真的3D GIS在這幾年才比較有大進展，突破原因除了資料獲取的技術提升以外，主要還是跟Web技術息息相關，其中WebGL佔了重要角色。 3D GIS雖然過去有Google Earth這種霸王級產品，但是其應用有限，而要說這幾年3D GIS發展及前進的速度可說是過去的好幾倍，這與WebGL發展有關，目前3D GIS仍是百家爭鳴階段，連互操作相關議題才剛有幾家大型龍頭爭奪完畢好讓自己的格式成為OGC標準(ESRI I3S勝出)，姑且不論很早起就已ready for use的3D空間分析演算法(與2D差異甚多)，3D GIS在格式、資料方面都與2D截然不同，所以，既然如此，今天就不討論那些，來瀏覽看看一些WebGL for 3D GIS的範例。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” OSM BuildongOSM building是透過Open Street Map(OSM)上建物的資訊，Render出來的3D地圖展示，主要是根據建築物的footprint與該物件的屬性，包含了樓高、材質、屋頂等等。 Building height: Mapbox-GLMapbox-GL也有3D建物的功能，也是利用樓高的方式進行render，看起來效果很好。 地形前面兩者的案例是利用平面的街廓線，配合屬性資訊產生3D建物的效果(或是說2.5D)，在3D GIS中，地形也是很重要的元素，例如heightmap及GIScene.js就是利用SRTM 30米空間解析度全球地形資料庫做的3D地形展示(SRTM全稱是Shuttle Radar Topography Mission，是NASA JPL發展多年的計畫)，將SRTM從2D Raster利用WebGL(three.js的)做3D的呈現。 3D mesh場景為了呈現更多細節，目前的3D 的WebGIS以走向3D mesh方向發展，透過電腦視覺及攝影測量技術重建3D場景模型，這些模型是以三角網方式組成，可以呈現非常完整的細節(包含形狀及紋理等)，也因為要呈現細節，所以在瀏覽器效能及API串流的技術上就顯得格外重要，相關案例如ESRI 3D mesh scene layer。","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"WebGL","slug":"WebGL","permalink":"https://chimin17.github.io/tags/WebGL/"}]},{"title":"鐵人賽Day 27- WebGIS 加入D3.js圖表互動","slug":"ironman-2018-day27","date":"2018-01-16T00:02:33.000Z","updated":"2018-10-16T13:33:04.496Z","comments":true,"path":"2018/01/16/ironman-2018-day27/","link":"","permalink":"https://chimin17.github.io/2018/01/16/ironman-2018-day27/","excerpt":"前言今天要在WebGIS中加入一些資訊圖表，利用D3.js來實作圖表並與地圖互動，D3.js非常具有彈性且多樣，能與地圖結合有錦上添花的感覺，let’s go!","text":"前言今天要在WebGIS中加入一些資訊圖表，利用D3.js來實作圖表並與地圖互動，D3.js非常具有彈性且多樣，能與地圖結合有錦上添花的感覺，let’s go! 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” D3.jsD3.js是資料視覺化的利器，光從官方網站範例就琳瑯滿目，例如我們要畫一個bar chart 123456789101112131415161718192021222324252627282930313233343536373839404142//設定畫布及x,y軸比例尺等 var svg = d3.select(&quot;#svg&quot;), margin = &#123; top: 20, right: 20, bottom: 30, left: 40 &#125;, width = +svg.attr(&quot;width&quot;) - margin.left - margin.right, height = +svg.attr(&quot;height&quot;) - margin.top - margin.bottom; var x = d3.scaleBand().rangeRound([0, width]).padding(0.1); var y = d3.scaleLinear().rangeRound([height, 0]); var column = svg.append(&quot;g&quot;) .attr(&quot;transform&quot;, &quot;translate(&quot; + margin.left + &quot;,&quot; + margin.top + &quot;)&quot;); //設定資料範圍 x.domain(data.map(function (d) &#123; return d.letter; &#125;)); y.domain([0, d3.max(data, function (d) &#123; return d.frequency; &#125;)]); //x軸 column.append(&quot;g&quot;) .attr(&quot;transform&quot;, &quot;translate(0,&quot; + height + &quot;)&quot;) .call(d3.axisBottom(x)); //y軸 column.append(&quot;g&quot;) .call(d3.axisLeft(y)) .append(&quot;text&quot;) .attr(&quot;transform&quot;, &quot;rotate(-90)&quot;) .attr(&quot;y&quot;, 6) .attr(&quot;dy&quot;, &quot;0.71em&quot;) .attr(&quot;text-anchor&quot;, &quot;end&quot;) .text(&quot;Frequency&quot;); //bar chart部分 column.selectAll(&quot;.bar&quot;) .data(data) .enter().append(&quot;rect&quot;) .attr(&quot;class&quot;, &quot;bar&quot;) .attr(&quot;x&quot;, function (d) &#123; return x(d.letter); &#125;) .attr(&quot;y&quot;, function (d) &#123; return y(d.frequency); &#125;) .attr(&quot;width&quot;, x.bandwidth()) .attr(&quot;height&quot;, function (d) &#123; return height - y(d.frequency); &#125;)&#125; 在地圖中增加互動WebGIS的圖表當然就是圖層的屬性，在讀入geojson後，我們會需要把資料做些轉換，去產生圖表需要的資訊。 例如：1234567891011121314151617181920212223242526272829303132$.getJSON(&quot;./dist/assets/data/map.geojson&quot;, function (data) &#123; featchdata(data);&#125;);function featchdata(d) &#123; //資料 var data = []; var tmp_type; var tmp_count = 0; $.each(d.features, function (k, v) &#123; if (k == 0) &#123; tmp_type = v.properties.surface; tmp_count++; &#125; else if (k == d.length - 1) &#123; tmp_count++; data.push(&#123; &quot;letter&quot;: tmp_type, &quot;frequency&quot;: tmp_count &#125;) &#125; else &#123; if (tmp_type == v.properties.surface) &#123; tmp_count++; &#125; else &#123; data.push(&#123; &quot;letter&quot;: tmp_type, &quot;frequency&quot;: tmp_count &#125;) tmp_count = 1; tmp_type = v.properties.surface; &#125; &#125; &#125;); 上面圖表串接，我們加入一些地圖事件讓圖表動起來，圖表會跟著地圖實際涵蓋的範圍做變化 首先，加入地圖事件：123456789map.on(&apos;zoomend&apos;, function () &#123; var d = pois.toGeoJSON(); featchdata(d);&#125;);map.on(&apos;dragend&apos;, function () &#123; var d = pois.toGeoJSON(); featchdata(d);&#125;); 接著，在前面的featchdata加入bounds判斷，讓圖表會根據bounds範圍呈現資料使用的函式為turf.booleanPointInPolygon(point,polygon)如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function featchdata(d0) &#123;var ext = map.getBounds() //資料 var poly = turf.polygon([[ [ext.getSouthWest().lng, ext.getSouthWest().lat], [ext.getNorthWest().lng, ext.getNorthWest().lat], [ext.getNorthEast().lng, ext.getNorthEast().lat], [ext.getSouthEast().lng, ext.getSouthEast().lat], [ext.getSouthWest().lng, ext.getSouthWest().lat] ]]); console.log(poly); var d = []; $.each(d0.features, function (k, v) &#123; var pt = turf.point([v.geometry.coordinates[0], v.geometry.coordinates[1]]); if (turf.booleanPointInPolygon(pt, poly)) &#123; d.push(v); &#125; &#125;); var data = []; var tmp_type; var tmp_count = 0; $.each(d, function (k, v) &#123; if (k == 0) &#123; tmp_type = v.properties.surface; tmp_count++; &#125; else if (k == d.length - 1) &#123; tmp_count++; data.push(&#123; &quot;letter&quot;: tmp_type, &quot;frequency&quot;: tmp_count &#125;) &#125; else &#123; if (tmp_type == v.properties.surface) &#123; tmp_count++; &#125; else &#123; data.push(&#123; &quot;letter&quot;: tmp_type, &quot;frequency&quot;: tmp_count &#125;) tmp_count = 1; tmp_type = v.properties.surface; &#125; &#125; &#125;); ... ... 省略&#125; 成果略圖 後記在D3.js我們還加入一些click事件及css調整，可以直接看程式碼喔～，另外，除了D3.js以外，也可以使用單純圖表的C3.js或是highchart等較直覺的工具喔。","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"D3","slug":"D3","permalink":"https://chimin17.github.io/tags/D3/"}]},{"title":"鐵人賽Day 26- 在資料庫中操作空間資料-MongoDB","slug":"ironman-2018-day26","date":"2018-01-15T00:00:43.000Z","updated":"2018-10-16T13:33:00.526Z","comments":true,"path":"2018/01/15/ironman-2018-day26/","link":"","permalink":"https://chimin17.github.io/2018/01/15/ironman-2018-day26/","excerpt":"前言除了前一天有提到的關聯式資料庫具有地理空間函式庫，使用Key-Value的資料庫例如MongoDB也支援一些空間運算子，在不同應用場合可能會用到，就來嘗試看看。","text":"前言除了前一天有提到的關聯式資料庫具有地理空間函式庫，使用Key-Value的資料庫例如MongoDB也支援一些空間運算子，在不同應用場合可能會用到，就來嘗試看看。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 安裝安裝Mongodb的方法： Windows可以直接下載安裝檔 Mac有Howbrew可以使用Howbrew: 12brew updatebrew install mongodb 然後就完成了。 啟動啟動Mongodb1Mongod 修改資料庫存放的路徑1mongod --dbpath ~/mongo_test 基本操作進入資料庫操作1mongo 顯示資料庫清單12show dbs//ironman 進入ironman這個資料庫1use ironman 顯示資料庫的collections12show collection//test 在test中query所有資料1db.test.find(&#123;&#125;) 空間搜尋首先匯入一份具有空間資訊的資料：1db.test.save(&#123;name:&quot;前鎮高中網球場&quot;, city:&quot;高雄市&quot;, geom:[120.318735,22.589452]&#125;) 建立空間索引，在2d的索引部分分為2dsphere與2d1db.test.ensureIndex(&#123;geom:&quot;2dsphere&quot;&#125;) 建立好空間索引，我們就可以使用Mongodb的地理空間函式操作囉！例如使用\\$near進行距離查詢1db.test.find(&#123;geom: &#123;$near:[120.319,22.588] , $maxDistance:1000 &#125;&#125;) 後記Mongodb的空間運算子還包含了\\$geoIntersects跟$geoWithin等，MongoDB這些基本的空間運算子滿方便的，如果需要使用NoSQL或是Key-Value DB，又需要一些基本的空間資料運算，可以參考！","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"Mongodb","slug":"Mongodb","permalink":"https://chimin17.github.io/tags/Mongodb/"}]},{"title":"鐵人賽Day 25- 在資料庫中操作空間資料-PostGIS","slug":"ironman-2018-day25","date":"2018-01-13T03:00:43.000Z","updated":"2018-10-16T13:32:55.535Z","comments":true,"path":"2018/01/13/ironman-2018-day25/","link":"","permalink":"https://chimin17.github.io/2018/01/13/ironman-2018-day25/","excerpt":"前言PostGIS是PostgreSQL基於OpenGIS中的SFS規範(Simple Feature Specification for SQL)所實作出來的地理物件函式庫，而PostgreSQL則是一個關聯式資料庫的自由軟體(BSD license)， 跟PostGIS類似的東西相當於MS SQL Server中的SQL Spatial、Oracle spatial、MySQL spatial。 PostGIS在地理空間運算的實作function非常多，也可以與QGIS等軟體做結合。","text":"前言PostGIS是PostgreSQL基於OpenGIS中的SFS規範(Simple Feature Specification for SQL)所實作出來的地理物件函式庫，而PostgreSQL則是一個關聯式資料庫的自由軟體(BSD license)， 跟PostGIS類似的東西相當於MS SQL Server中的SQL Spatial、Oracle spatial、MySQL spatial。 PostGIS在地理空間運算的實作function非常多，也可以與QGIS等軟體做結合。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 安裝PostGIS安裝可以參考官網，各種OS有不同的安裝方法，例如Mac使用Homebrew、Windows則有安裝檔等等。也可以在DockerHub找PostGIS的image，用Docker啟用一個PostGIS環境，做一些測試。 操作PostGIS基於PostgreSQL當然可以使用psql或是pgadmin等工具及UItool，另外，QGIS對於PostGIS支援程度很高，有興趣者可以多研究喔！ 建立table產生一個table1234CREATE TABLE tennis (name VARCHAR(20),city VARCHAR(10)); 使用AddGeometryColumn增加空間欄位，指定坐標系統為EPSG:4326 2D。SELECT AddGeometryColumn (&#39;topology&#39;,&#39;tennis&#39;,&#39;geom&#39;,4326,&#39;POINT&#39;,2); 使用ST_GeomFromTextinset資料資料 例如123INSERT INTO topology.tennis( name, city, geom) VALUES (&apos;前鎮高中網球場&apos;, &apos;高雄市&apos;, ST_GeomFromText(&apos;POINT(120.318735 22.589452)&apos;, 4326)); 查詢PostGIS有很多空間格式的function,KML,geojson,GML等等 ST_AsGML ST_AsGeoJSON ST_AsKML 例如：1select name, city, ST_AsKML(geom) FROM topology.tennis 空間查詢會用到的常見方法舉幾個例子： ST_Distance - 計算距離 ST_Intersection - 計算兩個幾何交會的部分 ST_Intersects: 判斷是否交會 ST_Length: 計算長度(polyline) 其實PostGIS的地理空間運算Funtion非常多，涵蓋了raster及vector操作，可以參考官方文件喔！ 後記更多PostGIS可以參考https://www.slideshare.net/mutolisp/postgis-57051746http://www.postgis.org/docs/http://ravenonhill.blogspot.tw/2017/12/postgis.html","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://chimin17.github.io/tags/PostgreSQL/"}]},{"title":"鐵人賽Day 24- 在WebGIS加入Mapillary街景","slug":"ironman-2018-day24","date":"2018-01-12T03:00:43.000Z","updated":"2018-10-16T13:32:51.190Z","comments":true,"path":"2018/01/12/ironman-2018-day24/","link":"","permalink":"https://chimin17.github.io/2018/01/12/ironman-2018-day24/","excerpt":"前言Mapillary是一個透過眾包建立的街景服務，其目標是建立一個群眾外包的平台分享具空間坐標的照片影片，2013年建立以來，這個平台於2016年11月15日到達一億張相片，除了昨天使用的Google街景以外，我們也可以選擇使用Mapillary的街景，Mapillary計畫透過將其使用者生成的資料授權給其他公司使用來獲利(wiki)，目前Mapillary的資料已授權OpenStreetMap使用。","text":"前言Mapillary是一個透過眾包建立的街景服務，其目標是建立一個群眾外包的平台分享具空間坐標的照片影片，2013年建立以來，這個平台於2016年11月15日到達一億張相片，除了昨天使用的Google街景以外，我們也可以選擇使用Mapillary的街景，Mapillary計畫透過將其使用者生成的資料授權給其他公司使用來獲利(wiki)，目前Mapillary的資料已授權OpenStreetMap使用。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” Mapillary網站畫面(綠色為有街景的區域) 上傳自己的照片使用Mapillary，我們可以上傳步行、騎車、開車或是全景的照片或照片，只要註冊帳號都可以上傳，可以透過GPX軌跡或是照片本身的EXIF資訊取得地理坐標。 Mapillary除了提供照片上傳，利用眾包發展街景服務以外，還提供了一些電腦覺演算法，進一步為照片加值，辨識道路的物件。 使用Mapillary.jsMapillary.js使用上跟Google街景沒差很多，我們就只接看範例：首先，要申請帳號並取得token 加入div1&lt;div id=&quot;mly&quot; &gt; &lt;/div&gt; 加入程式12345var mly = new Mapillary.Viewer( &apos;mly&apos;, &apos;token&apos;, &apos;MiEVQvYuxJOmTgpS2TNK8w&apos;// 初始照片的key); 接著，加入marker12345678910111213var mlyMan;mly.on(Mapillary.Viewer.nodechanged, function (node) &#123; var latLon = [node.latLon.lat, node.latLon.lon]; if (!mlyMan) &#123; mlyMan = L.marker(latLon); mlyMan.addTo(map); &#125; else &#123; mlyMan.setLatLng(latLon); &#125; map.setView(latLon);&#125;); 後記Mapillary跟OpenStreetMap一樣透過群眾外包建立地圖(街景)，而且進一步使用自動辨識演算法，讓照片得以加值，有興趣可以上傳喔！","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"leaflet","slug":"leaflet","permalink":"https://chimin17.github.io/tags/leaflet/"},{"name":"Mapillary","slug":"Mapillary","permalink":"https://chimin17.github.io/tags/Mapillary/"}]},{"title":"鐵人賽Day 23- 在WebGIS中加入Google街景","slug":"ironman-2018-day23","date":"2018-01-11T00:00:43.000Z","updated":"2018-10-16T13:32:43.433Z","comments":true,"path":"2018/01/11/ironman-2018-day23/","link":"","permalink":"https://chimin17.github.io/2018/01/11/ironman-2018-day23/","excerpt":"前言今天要在地圖中加入另一個元素：街景。到目前為止介紹的WebGIS應用都是2D的，加入街景環景影像雖然不是3D，但還是比較有身歷其境的感覺，今天我們使用的服務為Google街景。","text":"前言今天要在地圖中加入另一個元素：街景。到目前為止介紹的WebGIS應用都是2D的，加入街景環景影像雖然不是3D，但還是比較有身歷其境的感覺，今天我們使用的服務為Google街景。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 申請token跟昨天一樣，使用Google API都要申請token，這邊偷懶地簡單說明一下：街景服務是被放在Google Javascript API之下，首先打開連結，按右上角取得金鑰。 然後選取一個專案(如果沒有要另外開啟)。 之後就會取得一組金鑰，這就是token。 加入街景收先要引入Google API，記得YOUR_KEY是放你的token喔123 &lt;script type=&quot;text/javascript&quot; src=&quot;https://maps.googleapis.com/maps/api/js?key=YOUR_KEY&amp;libraries=StreetViewPanorama&quot;&gt;&lt;/script&gt; 首先我們沿用昨天的版型，在bottom區塊增加一個id 為googleStreet的div1&lt;div id=&apos;googleStreet&apos;&gt;&lt;/div&gt; 接著在app.js加入123456789var panorama = new google.maps.StreetViewPanorama( document.getElementById(&apos;googleStreet&apos;), &#123; position: &#123; lat: 25.0574304, lng: 121.5964764 &#125;, pov: &#123; heading: 165, pitch: 0 &#125; &#125;); 其中呢，lat及lng為經緯度資訊，pov為相片的水平角及俯仰角。 heading （預設為 0）使用從正北方算起的相對角度來定義相機焦點的旋轉角度。方向是以順時針方向計算（90 度為正東方）。 pitch （預設為 0）定義從相機的初始預設傾斜「往上」或「往下」的角度變化，通常是（但不總是）平面水平。（例如，在山丘上拍到的影像可能會展示不是水平視角的預設傾斜。）傾斜角度的測量是往上仰視為正值（與預設傾斜呈垂直向上的 +90 度），往下俯視為負值（與預設傾斜呈垂直向下的 -90 度）。 成功囉： 加入地圖互動利用Google的方法，初始化街景影像還不夠，別忘記Google環景還有「小人」這個元素。我們來加入類似小人的marker，讓街景跟地圖能互動。要完成這件事需要一些事件綁定，在google.maps.StreetViewPanorama有訂定一些事件： pano_changed 個別全景變更時引發。 position_changed 會在全景的底層 (LatLng) 位置變更時引發。旋轉全景將不會觸發此事件。 pov_changed 會在「街景服務」的 StreetViewPov 變更時引發。 links_changed 會在「街景服務」的連結變更時引發。 visible_changed 會在「街景服務」的可見度變更時引發。 移動事件移動事件這邊使用position_changed，並且在事件中利用getPosition()取得相片所在坐標，把坐標標示一個marker在地圖上12345678var panoramMan = L.geoJson(null);panorama.addListener(&apos;position_changed&apos;, function () &#123; map.removeLayer(panoramMan); console.log(&quot;x:&quot; + panorama.getPosition().lng()); console.log(&quot;y:&quot; + panorama.getPosition().lat()); panoramMan = L.marker([panorama.getPosition().lat(), panorama.getPosition().lng()]).addTo(map); map.setView([panorama.getPosition().lat(), panorama.getPosition().lng()], 17)&#125;); 加入這個事件以後，只要我們在全景視窗中移動，會有一個marker在圖上。成果： 旋轉事件要有旋轉的效果，首先先把marker的symbol改成有方向性的圖片：1234var streetIcon = L.icon(&#123; iconUrl: &apos;./dist/assets/img/streetman.png&apos;, iconSize: [32, 32],&#125;); 在加入時設定icon的rotationAngle，值我們可以使用panorama.pov.heading取得轉向。12panoramMan = L.marker([panorama.getPosition().lat(), panorama.getPosition().lng()], &#123; rotationAngle: panorama.pov.heading, icon: streetIcon &#125;).addTo(map); 完整程式碼：12345678910111213141516171819202122232425262728293031323334353637var panoramMan = L.geoJson(null);//圖片var streetIcon = L.icon(&#123; iconUrl: &apos;./dist/assets/img/streetman.png&apos;, iconSize: [32, 32],&#125;);google街景var panorama = new google.maps.StreetViewPanorama( document.getElementById(&apos;googleStreet&apos;), &#123; position: &#123; lat: 25.0574304, lng: 121.5964764 &#125;, pov: &#123; heading: 165, pitch: 0 &#125; &#125;); //位置變換事件panorama.addListener(&apos;position_changed&apos;, function () &#123; map.removeLayer(panoramMan); console.log(&quot;x:&quot; + panorama.getPosition().lng()); console.log(&quot;y:&quot; + panorama.getPosition().lat()); console.log(&quot;rotation:&quot; + panorama.pov.heading); panoramMan = L.marker([panorama.getPosition().lat(), panorama.getPosition().lng()], &#123; rotationAngle: panorama.pov.heading, icon: streetIcon &#125;).addTo(map); map.setView([panorama.getPosition().lat(), panorama.getPosition().lng()], 17)&#125;);//旋轉事件panorama.addListener(&apos;pov_changed&apos;, function () &#123; map.removeLayer(panoramMan); console.log(&quot;x:&quot; + panorama.getPosition().lng()); console.log(&quot;y:&quot; + panorama.getPosition().lat()); console.log(&quot;rotation:&quot; + panorama.pov.heading); panoramMan = L.marker([panorama.getPosition().lat(), panorama.getPosition().lng()], &#123; rotationAngle: panorama.pov.heading, icon: streetIcon &#125;).addTo(map); map.setView([panorama.getPosition().lat(), panorama.getPosition().lng()], 17)&#125;); 動態成果： 後記把Google街景接進自己的圖台會讓WebGIS功能更完整，使用的方法也很簡單，提供參考囉！今天的程式碼一樣放在github(day23的commit)。","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"leaflet","slug":"leaflet","permalink":"https://chimin17.github.io/tags/leaflet/"},{"name":"Google","slug":"Google","permalink":"https://chimin17.github.io/tags/Google/"}]},{"title":"鐵人賽Day 22- WebGIS中加入Google Directions導航API","slug":"ironman-2018-day22","date":"2018-01-10T03:00:43.000Z","updated":"2018-10-16T13:32:39.116Z","comments":true,"path":"2018/01/10/ironman-2018-day22/","link":"","permalink":"https://chimin17.github.io/2018/01/10/ironman-2018-day22/","excerpt":"前言今天要來接Google路徑導航資訊，Google Maps API有很多很棒的東西可以用在WebGIS，路徑規劃就是其中之一，他的完整名稱是Directions API，把它整合進我們的地圖。","text":"前言今天要來接Google路徑導航資訊，Google Maps API有很多很棒的東西可以用在WebGIS，路徑規劃就是其中之一，他的完整名稱是Directions API，把它整合進我們的地圖。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 申請token使用Google API都要申請token，這邊偷懶地簡單說明一下：首先打開Directions API，按右上角取得金鑰。 然後選取一個專案(如果沒有要另外開啟)。 之後就會取得一組金鑰，這就是token。 我們關注一下免費版的使用限制，注意不是完全免費的喔。 每日免費要求提供上限為 2,500 個。 如果啟用計費功能，則每 1,000 個額外要求收費 $0.50 美元，每日提供上限為 100,000 個。 try it使用Direction API取得路徑規劃的方式可以用get的方式，最簡單的使用：1https://maps.googleapis.com/maps/api/directions/json?language=zh-TW&amp;origin=&quot; + **start** + &quot;&amp;destination=&quot; + **end** + &quot;&amp;key=&quot; + **token** request有幾個必填項目， key: 金鑰token(如果是在client端使用記得要設定存取domain) origin: 起點，起終點都可以使用wgs84坐標或是地標名稱 destination: 終點 此外，Direction API有提供很多選填，包含 language: 語言 mode: 移動模式(預設為 driving) region: 指定地區代碼 more..Google DirectionAPI可以設定的參數很多，包含避開路線、替代路線等等，有需要者可以詳閱API文件 我們就直接request一個看Direction API回應些什麼.. 整個回應的資料十分豐富，包含旅行時間、路徑等等，我們可以把這些資訊使用在圖台上！ 解析資料1.overview_polyline從回應的資料可以看到overview_polyline，這是一個經過編碼的路線陣列，記錄的是API規劃的路徑及沿線polyline的預覽，我們可以把它畫在圖上，而編碼的方法請參閱Google文件。 要使用overview_polyline這類的編碼資料，可以引入Leaflet.encoded，利用這個工具解碼1var latlngs = L.PolylineUtil.decode(str); 解碼後就是一個polyline的資料，可以直接用polyline放到圖上1L.polyline(latlngs, &#123; color: &apos;red&apos; &#125;).addTo(map); 2.stepsAPI回傳的資料很多，其中steps是分段的路徑資訊，我們直接取steps這個陣列來使用，steps裡面包的就是一段一段的轉折點，除了幾何外，還包含了導航文字說明。 展開： 我們就組個表格，並把文字說明html_instructions塞入： 123456//data為api responds資料 $.each(data.routes[0].legs[0].steps, function (k, v) &#123; $(&quot;#route-list tbody&quot;).append(&quot;&lt;tr id=&apos;&quot; + v.polyline.points + &quot;&apos; class=&apos;route-row&apos;&gt;&lt;td&gt;&quot; + v.html_instructions + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;); &#125;) 接著，綁定每段的click事件，使用者點到以後就可以顯示每小段的位置，其中在幾何部分我們使用一樣工具解碼喔！12345678910111213$(document).on(&quot;click&quot;, &quot;.route-row&quot;, function (e) &#123; $(&apos;#googleRouting&apos;).animate(&#123; scrollTop: $(this).context.offsetTop &#125;, 800); routelineClick($(this).attr(&quot;id&quot;));&#125;);var subRoute = L.geoJson(null);function routelineClick(str) &#123; map.removeLayer(subRoute); var latlngs = L.PolylineUtil.decode(str); subRoute = L.polyline(latlngs, &#123; color: &apos;red&apos; &#125;).addTo(map); map.setView([latlngs[0][0] - 0.001, latlngs[0][1]], 17)&#125; 切版及成果為了加入導航的功能，所以今天地圖增加了bottom區塊，有興趣者就自行研究吧，最終的效果如下： 後記今天快速測試一下Google Direction，很好用但是不是完全免費的，而類似的服務還有Mapbox、Here Routing API，OSM社群也有一些開源的服務，有機會再詳細介紹吧！ 今天的測試程式碼一樣放在github(day22的commit)。","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"leaflet","slug":"leaflet","permalink":"https://chimin17.github.io/tags/leaflet/"},{"name":"Google","slug":"Google","permalink":"https://chimin17.github.io/tags/Google/"}]},{"title":"鐵人賽Day 21- 在WebGIS加入風場圖","slug":"ironman-2018-day21","date":"2018-01-09T03:00:43.000Z","updated":"2018-10-17T10:51:08.099Z","comments":true,"path":"2018/01/09/ironman-2018-day21/","link":"","permalink":"https://chimin17.github.io/2018/01/09/ironman-2018-day21/","excerpt":"前言前幾天研究了內插、TIN、 Voronoi Diagram、Contours(等高線)、Heatmaps(熱區圖)與Clustering(群聚圖)，這些都是很常見的webGIS資料視覺化應用，今天要來研究的是前陣子很常看到的全球風場圖，看一下到底做了些什麼…","text":"前言前幾天研究了內插、TIN、 Voronoi Diagram、Contours(等高線)、Heatmaps(熱區圖)與Clustering(群聚圖)，這些都是很常見的webGIS資料視覺化應用，今天要來研究的是前陣子很常看到的全球風場圖，看一下到底做了些什麼… 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 風場圖在不同的地圖、視覺化工具皆有不同的實作： D3.js ESRI Leaflet 原始資料與資料來源全球風場圖的資料來源主要是美國國家海洋暨大氣總署(NOAA)天氣資料，採用的格式為氣象交換格式GRIB2，這個格式是Binary的，在上述三個風場圖實作的套件中，都是採用grib2json轉成一包json物件，而這個東西到底記錄了什麼呢？他其實就是網格資料。 打開grib2json匯出的json檔案，他大概長這樣： 檔案內除了資料外，還記錄了metadata於header，在data的部分，記錄方式是一條一條橫方向記錄，例如第一點是(25.6,120.5),第二點就是(25.6,120.6)的值，第三點(25.6,120.7)…以此類推… header有定義格子的起點與長寬資訊，以一般拿到的NOAA大氣資料(空間解析度為一度)展示出來大概會是這麼密： 怎麼畫圖前面範例的風場圖是空間解析度為一度的NOAA大氣資料(解析度header會定義)，也就是每一個網格點的氣壓，為產生風向圖的效果，做了幾個處理。 1.在格子與格子間以雙線性內插產生面。(wiki) 2.內插完成面後，隨機在面之中產生若干粒子，讓粒子沿著速度場、梯度方向移動(由高至低)。3.可以設定一些參數，包含粒子的生命週期，最大最小速度、顏色等等ps.詳情可參考earth的描述及程式碼^^ Leaflet實作接下來，我們使用leaflet-velocity來繪製全球風場圖，加入我們的地圖專案。 引入leaflet-velocity.js，並預先下載大氣的網格資料。(使用這個專案必須跟grib2json的輸出格式一樣) 根據套件說明直接使用：1234567891011$.getJSON(&quot;./dist/assets/data/wind-global.json&quot;, function (data) &#123; var velocityLayer = L.velocityLayer(&#123; //設置一些顯示的參數 displayValues: false, data: data, maxVelocity: 10, colorScale: [&apos;#bd0026&apos;, &apos;#f03b20&apos;, &apos;#fd8d3c&apos;, &apos;#fecc5c&apos;, &apos;#ffffb2&apos;]//色階 &#125;); map.addLayer(velocityLayer);&#125;); 這個圖層是以Canvas方式實作，以增加效能(不然一堆粒子應該會爆炸…) 成果： 後記除了NOAA的大氣資料，如果要產生類似效果的向量圖或梯度圖，也可以自行產製類似的資料繪製在地圖上(洋流等等)。今天的程式碼一樣放在github(day21的commit)。","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"leaflet","slug":"leaflet","permalink":"https://chimin17.github.io/tags/leaflet/"},{"name":"Google","slug":"Google","permalink":"https://chimin17.github.io/tags/Google/"}]},{"title":"鐵人賽Day 20- WebGIS中的Contours、Heatmaps與Clustering資料呈現","slug":"ironman-2018-day20","date":"2018-01-08T00:00:43.000Z","updated":"2018-10-16T13:32:31.171Z","comments":true,"path":"2018/01/08/ironman-2018-day20/","link":"","permalink":"https://chimin17.github.io/2018/01/08/ironman-2018-day20/","excerpt":"前言今天延續昨天內插的議題，準備研究一下webGIS中的Contours(等高線)、Heatmaps(熱區圖)與Clustering(群聚圖)等方法，用來增進原本只是點資料的資訊呈現方式。 等高線(或等值線)要算等高線(contours)或等值線我們可以使用turf.js的isobands，要產製一個等值線圖的流程是：1.離散的資料 2.內插(turf.js要使用規則的points) 3.使用isobands。 所以，延續昨天的IDW內插，我們內插一組gridType為points的資料後，想進一步將等值的範圍做整合，這個過程可以採用computer vision中的Marching squares。 這個方法主要需設定的東西是breaks，也就是要分值的斷點，例如0, 5, 10, 15, 20, 25, 30)。","text":"前言今天延續昨天內插的議題，準備研究一下webGIS中的Contours(等高線)、Heatmaps(熱區圖)與Clustering(群聚圖)等方法，用來增進原本只是點資料的資訊呈現方式。 等高線(或等值線)要算等高線(contours)或等值線我們可以使用turf.js的isobands，要產製一個等值線圖的流程是：1.離散的資料 2.內插(turf.js要使用規則的points) 3.使用isobands。 所以，延續昨天的IDW內插，我們內插一組gridType為points的資料後，想進一步將等值的範圍做整合，這個過程可以採用computer vision中的Marching squares。 這個方法主要需設定的東西是breaks，也就是要分值的斷點，例如0, 5, 10, 15, 20, 25, 30)。turf.js計算等值線：1234567891011121314151617181920212223var contours_pts = turf.interpolate(ramdompts_ipl, 2, &#123; gridType: &apos;points&apos;, property: &apos;obs&apos;, units: &apos;kilometers&apos; &#125;);//zProperty為要計算的欄位var contours = turf.isobands(contours_pts, [0, 5, 10, 15, 20, 25, 30], &#123; zProperty: &apos;obs&apos; &#125;);//結果為multiPolygon喔！！//加入圖層var contoursLayer = L.geoJson(contours, &#123; onEachFeature: function (feature, layer) &#123; layer.bindPopup(feature.properties.obs); &#125;, style: function (feature) &#123; return &#123; &quot;fillColor&quot;: getColor(parseInt(feature.properties.obs.split(&apos;-&apos;)[0])), &quot;weight&quot;: 0.5, &quot;color&quot;: &apos;#bd0026&apos;, &quot;opacity&quot;: 1, &#125; &#125;&#125;).addTo(map); 成果： HeatMapsheatMap用來顯示資料群聚的現象，是根據核密度估計(kernel density estimation)，演算法實作可以參考heatmap.js。 heatmap在Leaflet直接使用Leaflet.heat，heatmap使用時機與內插不同，heatmap是拿來看點資料的聚集現象，以核密度估計為基礎，包含了幾個參數包含每個點資料影響的半徑radius、設定色階的gradient以及用來設定平滑程度的高斯模糊參數blur等等，有興趣可以直接參考heatmap.js。 我們直接使用吧！123456789101112131415//組成資料放進去heatmapLayervar arr = [];turf.featureEach(ramdompts_ipl, function (feature) &#123; arr.push([feature.geometry.coordinates[1], feature.geometry.coordinates[0], feature.properties.obs, ]);&#125;);var heatmapLayer = L.heatLayer(arr, &#123; radius: 100, minOpacity: 0, blur: 0.75, gradient: &#123; 0.1: &apos;blue&apos;, 0.2: &apos;lime&apos;, 0.3: &apos;red&apos; &#125;&#125;).addTo(map); 成果：從成果這邊可以看到，heatmap主要是從有資料的位置出發，超過影響範圍的地方則沒有值，因此heatmap適合用來表達影響力範圍的地理資訊。 ClusteringPoints Clustering也是資料視覺化常見的手段，感覺起來跟前幾天提到的k-means群聚很像，目的是以若干個群聚中心點代表整體資料，讓資訊傳遞更清楚一些，避免一次大量離散的點資料呈現。 但是，與k-means不同的是，k-means需要預先說要給幾群，而這邊的Clustering是動態的，處理這個問題解決辦法是貪婪演算法(Greedy algorithms)，請參考mapbox有完整說明! 我們引入Leaflet.markercluster然後直接使用：12var clusterLayer = L.markerClusterGroup();clusterLayer.addLayer(ramdomLayer_ipl).addTo(map); 成果： 在Clustering的應用中Cluster是有階層的，不同的比例尺會有不同的聚合成果，類似的應用在房地產系統很常見喔! 後記今天的程式碼一樣放在github(day20的commit)。","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"leaflet","slug":"leaflet","permalink":"https://chimin17.github.io/tags/leaflet/"},{"name":"Turf.js","slug":"Turf-js","permalink":"https://chimin17.github.io/tags/Turf-js/"}]},{"title":"鐵人賽Day 19- 使用Turf.js進行空間資料內插","slug":"ironman-2018-day19","date":"2018-01-06T16:00:43.000Z","updated":"2018-10-16T13:32:26.346Z","comments":true,"path":"2018/01/07/ironman-2018-day19/","link":"","permalink":"https://chimin17.github.io/2018/01/07/ironman-2018-day19/","excerpt":"前言今天的主題是空間資料內插(interpolation)，內插是GIS很重要的課題，因為我們拿到的資料(例如觀測站資料)很常是point，內插可以幫助我們把這些離散的資料變成面狀成果，這樣除了方便資料視覺化，也可以進一步進行空間分析。","text":"前言今天的主題是空間資料內插(interpolation)，內插是GIS很重要的課題，因為我們拿到的資料(例如觀測站資料)很常是point，內插可以幫助我們把這些離散的資料變成面狀成果，這樣除了方便資料視覺化，也可以進一步進行空間分析。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 內插有很多演算法，我們今天使用turf.js，在client端也可以做即時的內插運算，今天就試著來說明： IDW法(規則網格) TIN(不規則三角網) Voronoi Diagram 在開始之前，先補充說明，GIS內插方法在GIS已相當成熟，GIS軟體如ArcGIS、QGIS、GRASS…等等強大老牌的工具都有更進階的方法(Bilinear, Kriging, nearest neighbor)且較多參數可調整的工具可以使用，turf.js是讓我們可以簡單在前端使用^^。 IDW(inverse distance weighting)IDW法概念很簡單，每個內插點(網格)的值與鄰近樣本點的關係是距離，距離越遠關係越小。所以取值點與樣本點間的距離為權重進行加權平均，離內插點越近的樣本點賦予的權重越大。 已知其坐標和值為Xi，Yi, Zi （i=1,2,3,4,5..）距離加權值求(Xp,Yp)點值，每個則Zp值以下公式。（gisgeography） 跟昨天一樣，以randomPoint產生隨機點的點作為示範，並隨機給定一個觀測值obs：123456789101112131415161718192021//產生隨機點var ramdompts_ipl = turf.randomPoint(25, &#123; bbox: [121.41, 24.34, 121.8, 24.65] &#125;);turf.featureEach(ramdompts_ipl, function (point) &#123; point.properties.obs = Math.random() * 20;&#125;);ramdomLayer_ipl.addData(ramdompts_ipl).addTo(map);map.fitBounds(ramdomLayer_ipl.getBounds());//放入圖層var ramdomLayer_ipl = L.geoJson(null, &#123; pointToLayer: function (feature, latlng) &#123; return L.marker(latlng, &#123; icon: L.icon(&#123; iconUrl: &quot;./dist/assets/img/icon-black.png&quot;, iconSize: [12, 12], iconAnchor: [0, 6] &#125;), &#125;).bindPopup(feature.properties.obs.toFixed(3).toString()); &#125;&#125;); 在turf.js中，interpolate這個方法就是IDW法：12var idw_grid = turf.interpolate(ramdompts_ipl, 2, &#123; gridType: &apos;hex&apos;, property: &apos;obs&apos;, units: &apos;kilometers&apos; &#125;);//成果會是geojson interpolate有幾個參數，包含內插點的間距(2)、內插得值(obs)、間距的單位(kilometers)、以及gridType(turfjs)。 特別說明一下ㄓgridType，目前有’square’ | ‘point’ | ‘hex’ | ‘triangle’ 可以選，例如本範例是用hex，輸出的成果就會是蜂巢狀的hexgrid。除此之外，我們可能會使用square或triangle，因此這個方法是在規則的形狀中，計算內插值，只是格子不一定是方形的。 加入圖層，並給定色階：123456789101112131415161718192021var idw_gridLayer = L.geoJson(idw_grid, &#123; onEachFeature: function (feature, layer) &#123; layer.bindPopup(feature.properties.obs.toFixed(3).toString()); &#125;, style: function (feature) &#123; return &#123; &quot;color&quot;: getColor(feature.properties.obs), &quot;opacity&quot;: 1, &#125; &#125;&#125;).addTo(map);//色階function getColor(x) &#123; return x &lt; 5 ? &apos;#bd0026&apos; : x &lt; 10 ? &apos;#f03b20&apos; : x &lt; 15 ? &apos;#fd8d3c&apos; : x &lt; 20 ? &apos;#fecc5c&apos; : &apos;#ffffb2&apos;;&#125;; 成果： square hex grid TIN(Triangulated Irregular Network)TIN是不規則三角網，在電腦視覺領域或是GIS都很常見，跟前面IDW法是內插在規則的形狀中有所不同，TIN組成的不規則三角網是將樣本點連成連續的三角網，而在眾多產生三角網的演算法中，Delaunay三角化是公認最佳解： Delaunay三網化：資料中任三點取其外接圓，若此圓內沒有包含任何其它點，則這三角形加入三角網中。這樣的目的是讓三角形都能越接近正三角形，狹長得三角形出現機會越低，因為三角形三邊長若越接近，外接圓越小。(wiki) 在turf中，產生TIN的方法也很簡單：12//把前面的隨機點拿來用用var tin = turf.tin(ramdompts_ipl, &apos;obs&apos;); 加入圖層：12345678910111213141516171819//放到圖層中var tinLayer = L.geoJson(tin, &#123; onEachFeature: function (feature, layer) &#123; var obs = feature.properties.a + feature.properties.b + feature.properties.c; feature.properties.obs = obs / 3; layer.bindPopup(feature.properties.obs.toFixed(3).toString()); &#125;, style: function (feature) &#123; var obs = feature.properties.a + feature.properties.b + feature.properties.c; return &#123; &quot;fillColor&quot;: getColor(obs), &quot;weight&quot;: 0.5, &quot;color&quot;: &apos;#bd0026&apos;, &quot;opacity&quot;: 1, &#125; &#125;&#125;).addTo(map); 其中，設定的obs為三角網三頂點要記錄的東西，每個三角形分別會記錄到a,b,c三個頂點，要進行內插，我們就組好TIN之後把三角形內的頂點取平均作為三角形的值囉。比較一下前面的成果，跟用interpolate把gridType設為triangle12var idw_grid = turf.interpolate(ramdompts_ipl, 2, &#123; gridType: &apos;triangle&apos;, property: &apos;obs&apos;, units: &apos;kilometers&apos; &#125;); 感覺TIN省很多圖形～ Voronoi Diagram前面TIN講到Delaunay，那就一定要再提到Voronoi Diagram，兩者是對偶關係： Voronoi Diagram：鄰近的點的中垂線，形成 Voronoi Diagram。(演算法筆記) Voronoi Diagram 能表達的是最近或範圍的概念，在地理學上非常適合哪來將點的資料轉成面資料。 turf.js產生Voronoi Diagram的方法：12var voronoiPolygons = turf.voronoi(ramdompts_ipl, &#123; bbox: [121.41, 24.34, 121.8, 24.65] &#125;); 在每個Diagram中塞入值：123turf.featureEach(voronoiPolygons, function (feature, index) &#123; feature.properties.obs = ramdompts_ipl.features[index].properties.obs;&#125;); 加入圖層：12345678910111213141516var voronoiLayer = L.geoJson(voronoiPolygons, &#123; onEachFeature: function (feature, layer) &#123; layer.bindPopup(feature.properties.obs.toFixed(3).toString()); &#125;, style: function (feature) &#123; return &#123; &quot;fillColor&quot;: getColor(feature.properties.obs), &quot;weight&quot;: 0.5, &quot;color&quot;: &apos;#bd0026&apos;, &quot;opacity&quot;: 1, &#125; &#125;&#125;).addTo(map); 成果：Voronoi Diagram套疊TIN與Voronoi Diagram 後記今天介紹了IDW法(規則網格)、TIN(不規則三角網)、Voronoi Diagram，這些方法除了在webGIS會看到，在D3.js等視覺化領域也是很常用到，在turf.js中使用這些方法很簡單，但我自己認為關鍵在於使用時機，要知道每種方法的意義及限制，才不會誤用或誤解算出來的東西，讓資訊傳達更正確。 另外，GIS領域有很多其他更多內插方法，例如Bilinear, Kriging, nearest neighbor等等，這些東西目前turf.js還沒看到，但也可以自己找工具或是自己動手實作看看喔。 今天的程式碼一樣放在github(day19的commit)。","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"leaflet","slug":"leaflet","permalink":"https://chimin17.github.io/tags/leaflet/"},{"name":"Turf.js","slug":"Turf-js","permalink":"https://chimin17.github.io/tags/Turf-js/"}]},{"title":"鐵人賽Day 18- Turf.js:空間資料運算及分析","slug":"ironman-2018-day18","date":"2018-01-05T16:20:43.000Z","updated":"2018-10-16T13:32:22.748Z","comments":true,"path":"2018/01/06/ironman-2018-day18/","link":"","permalink":"https://chimin17.github.io/2018/01/06/ironman-2018-day18/","excerpt":"前言今天要介紹turf.js，前兩天的網球地圖完成了基本的地圖功能及版面，並在地圖上展示、查詢了GIS資料，今天想進一步對資料做空間資料分析，使用的是turf.js。","text":"前言今天要介紹turf.js，前兩天的網球地圖完成了基本的地圖功能及版面，並在地圖上展示、查詢了GIS資料，今天想進一步對資料做空間資料分析，使用的是turf.js。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” turf.js是Mapbox公司提出用來處理空間資料分析的開源函式庫，打開turf.js的說明文件，可以看到其功能非常的多： 要處理空間資料的手段有很多，常見的方法是使用QGIS等軟體做資料處理，也可以使用其他程式語言的函式庫輔助或手刻，而turf.js是一個十分方便輕巧的工具，最棒的是可以用在webGIS中，client端空間資料處理。 至於什麼是空間資料分析呢？主要像是空間資料幾何運算、內插、資料聚合等都算，廢話不多說，我們就先來實作幾個案例。 幾何運算-pointsWithinPolygon範例目的：產生隨機的POI，利用新北市polygon，切出新北市內的POI 說明：首先，先new一個layer1234567891011var ramdomLayer = L.geoJson(null, &#123; pointToLayer: function (feature, latlng) &#123; return L.marker(latlng, &#123; icon: L.icon(&#123; iconUrl: &quot;./dist/assets/img/icon-black.png&quot;, iconSize: [36, 36], iconAnchor: [0, 18] &#125;), &#125;); &#125;&#125;); 利用 turf.randomPoint 產生隨機點，設定隨機點的範圍在[121.41, 24.9, 121.8, 25.19] 方框中。1234var ramdompts = turf.randomPoint(25, &#123; bbox: [121.41, 24.9, 121.8, 25.19] &#125;);//把成果放入圖層ramdomLayer.addData(ramdompts);ramdomLayer.addTo(map); 接著，放入新北市geojson1234var ntp = L.geoJson(null);$.getJSON(&quot;./dist/assets/data/ntp.geojson&quot;, function (data) &#123; ntp.addData(data);&#125;); 在沒有屬性欄位的狀態下，我們用幾何取出新北市範圍內的POI那就使用turf.pointsWithinPolygon~1234//ramdompts為前面產生的隨機點//data為新北市geojsonvar ptsWithin = turf.pointsWithinPolygon(ramdompts, data);//成果為geojson points ps.成果跟後面一起展示喔 空間分析-clustersKmeans範例目的：對新北市範圍的POI做距離分群 說明：這邊使用的群聚(cluster)演算法是Kmeans，Kmeans是非監督式學習的分類演算法，這個演算法要設定分群的數量，流程概述如下：1.根據預先設定的目標群數n，隨機給n個點作為n群資料的群聚中心2.資料中距離(空間距離)哪個群聚中心最近，就屬哪類3.各群以平均值重新計算各群中心點4.反覆1~3，直到中心點移動量低於設定值或是達到迭代次數而停止 利用turfclustersKmeans為資料作分群，設定分五類：12var clustered_kmeans = turf.clustersKmeans(ptsWithin, &#123; numberOfClusters: 5 &#125;);//結果是geojson points 幾何運算-找出Polygon的中心點與計算最鄰近的POI範例目的：找出新北市幾何中心及距離該點最近的poi 說明：turf.js有很多幾何的計算，以下是計算Polygon中心點，及找群POI中距離這個中心點最近的一個，直接看程式碼：1234//中心//data是新北市polygon geojsonvar center = turf.center(data);L.geoJson(center).addTo(map).bindPopup(&apos;這是新北幾何中心&apos;).openPopup(); 最短距離：12var nearest = turf.nearestPoint(center, ptsWithin);L.geoJson(center).addTo(map).bindPopup(&apos;這是距離新北中心最近的點&apos;).openPopup(); 成果：隨機給定POI(黑色)，使用空間選取前(ps.，另有不同icon顯示中心點及最近點。)只顯示新北市內的poi，並依空間分佈分群(不同顏色為不同群) 後記turf.js除了今天介紹的功能，還有很多是在webGIS常用的，例如buffer,intersect等等，很多GIS軟體工具提供的功能，turf.js都可以引用參考，非常方便，另外，turf.js相關介紹可以參考這個youtube喔^^。 明天會繼續介紹turf.js比較進階的空間分析功能，除了今天的基本運算外，希望能多觸及進階的分析方法！今天的程式碼一樣放在github(day18的commit)。","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"leaflet","slug":"leaflet","permalink":"https://chimin17.github.io/tags/leaflet/"},{"name":"Turf.js","slug":"Turf-js","permalink":"https://chimin17.github.io/tags/Turf-js/"}]},{"title":"鐵人賽Day 17- Leaflet.js：加入資料及資料互動","slug":"ironman-2018-day17","date":"2018-01-04T16:31:43.000Z","updated":"2018-10-16T13:32:18.926Z","comments":true,"path":"2018/01/05/ironman-2018-day17/","link":"","permalink":"https://chimin17.github.io/2018/01/05/ironman-2018-day17/","excerpt":"昨天我們建立了一個初步的地圖，webGIS中，除了基本工具的建立，加入主題性POI資料是主要功能，除了加入地圖以外，也必須有瀏覽POI列表及瀏覽詳細資料的操作功能。 今天就繼續昨天的成果，使用Leaflet實作前述事件及資料綁定的工作，資料部分，就以我們團隊成員建立的網球場資料(僅放部分)作為webGIS POI瀏覽範例吧。","text":"昨天我們建立了一個初步的地圖，webGIS中，除了基本工具的建立，加入主題性POI資料是主要功能，除了加入地圖以外，也必須有瀏覽POI列表及瀏覽詳細資料的操作功能。 今天就繼續昨天的成果，使用Leaflet實作前述事件及資料綁定的工作，資料部分，就以我們團隊成員建立的網球場資料(僅放部分)作為webGIS POI瀏覽範例吧。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 今日工作 goejson加入marker 建立list table 詳細資料-點擊事件 版面調整 加入geojson首先new 一個pois圖層，在geojson讀進來之後，把資料放進去，並透過pointToLayer把marker放上地圖，其中，icon部分根據場地性質(硬地、草地、紅土)給予不同的圖片。 app.js123456789101112131415161718192021222324252627282930313233//pois圖層ar pois = L.geoJson(null, &#123; pointToLayer: function (feature, latlng) &#123; //根據場地性質給不同marker icon var icon; if (feature.properties.surface == &quot;紅土[clay]&quot;) icon = &quot;./dist/assets/img/tennis-red.png&quot;; else if (feature.properties.surface == &quot;硬地[hard]&quot;) icon = &quot;./dist/assets/img/tennis-blue.png&quot;; else if (feature.properties.surface == &quot;草地[grass]&quot;) icon = &quot;./dist/assets/img/tennis-green.png&quot;; else icon = &quot;./dist/assets/img/globe.png&quot;; return L.marker(latlng, &#123; icon: L.icon(&#123; iconUrl: icon, iconSize: [24, 24], iconAnchor: [12, 12], popupAnchor: [0, -25] &#125;), title: feature.properties.name, riseOnHover: true &#125;); &#125;, ..略讀入$.getJSON(&quot;./dist/assets/data/map.geojson&quot;, function (data) &#123; pois.addData(data); map.addLayer(pois);&#125;); 建立list table我們先把list的div設置好，其中poi-list是主要的table。index.cshtml123456789101112131415&lt;div id=&quot;sidebar&quot;&gt; ...略 &lt;div class=&quot;sidebar-table&quot;&gt; &lt;table class=&quot;table table-hover&quot; id=&quot;poi-list&quot;&gt; &lt;thead class=&quot;hidden&quot;&gt; &lt;/thead&gt; &lt;tbody class=&quot;list&quot;&gt;&lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; ...略 &lt;/div&gt; 然後，在pois之中加入onEachFeature，遍歷每一筆資料並把每一條record組好放入list table中12345 onEachFeature: function (feature, layer) &#123; if (feature.properties) &#123; $(&quot;#poi-list tbody&quot;).append(&apos;&lt;tr class=&quot;feature-row&quot; id=&quot;&apos; + L.stamp(layer) + &apos;&quot; lat=&quot;&apos; + layer.getLatLng().lat + &apos;&quot; lng=&quot;&apos; + layer.getLatLng().lng + &apos;&quot;&gt;&lt;td style=&quot;vertical-align: middle;&quot;&gt;&lt;img width=&quot;16&quot; height=&quot;18&quot; src=&quot;&apos; + layer.options.icon.options.iconUrl + &apos;&quot;&gt;&lt;/td&gt;&lt;td class=&quot;feature-name&quot;&gt;&apos; + layer.feature.properties.name + &apos;&lt;/td&gt;&lt;td style=&quot;vertical-align: middle;&quot;&gt;&lt;i class=&quot;fa fa-chevron-right pull-right&quot;&gt;&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;&apos;);&#125; 詳細資料-點擊事件詳細資料我們這邊採用boostrap的modal，先在html加入div。index.cshtml1234567891011121314&lt;div class=&quot;modal fade&quot; id=&quot;featureModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot;&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button class=&quot;close&quot; type=&quot;button&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;×&lt;/button&gt; &lt;h4 class=&quot;modal-title text-primary&quot; id=&quot;feature-title&quot;&gt;&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot; id=&quot;feature-info&quot;&gt;&lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;Close&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 接下來，在pois的onEachFeatured中把modal之中的內容組好，接著綁定click事件。app.js123456var content = &quot;&lt;table class=&apos;table table-striped table-bordered table-condensed&apos;&gt;&quot; + &quot;&lt;tr&gt;&lt;th&gt;球場名稱&lt;/th&gt;&lt;td&gt;&quot; + feature.properties.name + &quot;&lt;/td&gt;&lt;/tr&gt;&quot; + &quot;&lt;tr&gt;&lt;th&gt;縣市&lt;/th&gt;&lt;td&gt;&quot; + feature.properties.city + &quot;&lt;/td&gt;&lt;/tr&gt;&quot; + &quot;&lt;tr&gt;&lt;th&gt;材質&lt;/th&gt;&lt;td&gt;&quot; + feature.properties.surface + &quot;&lt;/td&gt;&lt;/tr&gt;&quot; + &quot;&lt;tr&gt;&lt;th&gt;面數&lt;/th&gt;&lt;td&gt;&quot; + layer.feature.properties.number_of_courts + &quot;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; &quot;; click: function (e) &#123; $(&quot;#feature-title&quot;).html(feature.properties.name); $(&quot;#feature-info&quot;).html(content); $(&quot;#featureModal&quot;).modal(&quot;show&quot;); 在list中也要綁定click，讓使用者點擊地圖marker或list的item都可以開啟詳細資料modal，此外，在list之中開啟modal還要順便移動中心點喔。 123456789$(document).on(&quot;click&quot;, &quot;.feature-row&quot;, function (e) &#123; sidebarClick(parseInt($(this).attr(&quot;id&quot;), 10));&#125;);function sidebarClick(id) &#123; var layer = pois.getLayer(id); map.setView([layer.getLatLng().lat, layer.getLatLng().lng], 17); layer.fire(&quot;click&quot;);&#125; 版面調整及成果版面調整的工事比較瑣碎，主要包含slidebar的開關，nav-bar的微調(藉由boosrap的RWD特性)，直接看成果，相關內容可以參考程式碼。手機 後記今天完成基本的資料及事件綁定，其中有一些今天沒做到但常見的部分，例如在table list部分可以增加一些filter功能，可以參考list.js等等，而今天的程式碼都會放在github(day17有一個commit)供參考喔。","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"leaflet","slug":"leaflet","permalink":"https://chimin17.github.io/tags/leaflet/"}]},{"title":"鐵人賽Day 16- Leaflet.js：設置基本地圖元件","slug":"ironman-2018-day16","date":"2018-01-03T16:11:43.000Z","updated":"2018-10-16T13:32:14.359Z","comments":true,"path":"2018/01/04/ironman-2018-day16/","link":"","permalink":"https://chimin17.github.io/2018/01/04/ironman-2018-day16/","excerpt":"前言今天開始要逐步建立一個webGIS，練習一下使用Leaflet等API的實戰能力，在開始之前，先設定這個系統的基本功能： 切換底圖 定位 量測 資料查詢 街景 空間查詢 結合統計圖表 路徑規劃 資料視覺化","text":"前言今天開始要逐步建立一個webGIS，練習一下使用Leaflet等API的實戰能力，在開始之前，先設定這個系統的基本功能： 切換底圖 定位 量測 資料查詢 街景 空間查詢 結合統計圖表 路徑規劃 資料視覺化 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 今日工作我們把工作分成幾天說明，今天預計會完成的部分屬於地圖基本款的設置，包含了： 版型及基本設置 切換底圖 定位 量測 相關的程式碼都放在github，commit原則上會依照文章標示。 版型及基本設置首先，版型很重要，為了方便起見，我們直接套用boostrap template，並模仿bootleaf這個專案設計了一套版型。 大概會是長這樣： 上方留一個Navigation Bar做為選單空間，此外，最重要的區塊，就是要有一個map的 div 1234&lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;map&quot;&gt;&lt;/div&gt; //預留其他上下左右panel,寬度及高度建議滿版&lt;/div&gt; ps.關於排版詳情請參考原始碼.. 接下來，我們在app.js加入：map = L.map(&#39;map&#39;).setView([25.0375928, 121.5529563], 10);在這邊提醒一下，leaflet預設使用的坐標系統是EPSG:4326，但tileLayers的WMTS標準大多是EPSG:3857，忘記或搞混的可以參考這一篇，另外，第二個值是指zoom layer。 底圖切換功能加入底圖部分，在過去幾天我們也有使用了幾次，基本上是使用tileLayer這個類別，然而，webGIS通常會加入多種底圖，並且要有切換的功能。 因此，在此我們使用Leaflet.Basemaps套件： ps.類似的功能也可以自行實作看看，使用layerGroup Include the CSS:&lt;link rel=&quot;stylesheet&quot; href=&quot;L.Control.Basemaps.css&quot; /&gt;Include the JavaScript:&lt;script src=&quot;L.Control.Basemaps-min.js&quot;&gt;&lt;/script&gt; app.js：這邊用了兩個我覺得滿好看的底圖123456789101112131415161718192021222324var basemaps = [ L.tileLayer(&apos;//&#123;s&#125;.tile.stamen.com/toner-lite/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&apos;, &#123; attribution: &apos;Map tiles by &lt;a href=&quot;http://stamen.com&quot;&gt;Stamen Design&lt;/a&gt;, &lt;a href=&quot;http://creativecommons.org/licenses/by/3.0&quot;&gt;CC BY 3.0&lt;/a&gt; — Map data © &lt;a href=&quot;http://openstreetmap.org&quot;&gt;OpenStreetMap&lt;/a&gt; contributors, &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/2.0/&quot;&gt;CC-BY-SA&lt;/a&gt;&apos;, subdomains: &apos;abcd&apos;, maxZoom: 20, minZoom: 0, label: &apos;Toner Lite&apos; // optional label used for tooltip &#125;), L.tileLayer(&apos;//&#123;s&#125;.tile.stamen.com/watercolor/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&apos;, &#123; attribution: &apos;Map tiles by &lt;a href=&quot;http://stamen.com&quot;&gt;Stamen Design&lt;/a&gt;, &lt;a href=&quot;http://creativecommons.org/licenses/by/3.0&quot;&gt;CC BY 3.0&lt;/a&gt; — Map data © &lt;a href=&quot;http://openstreetmap.org&quot;&gt;OpenStreetMap&lt;/a&gt; contributors, &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/2.0/&quot;&gt;CC-BY-SA&lt;/a&gt;&apos;, subdomains: &apos;abcd&apos;, maxZoom: 16, minZoom: 1, label: &apos;Watercolor&apos; &#125;)];map.addControl(L.control.basemaps(&#123; basemaps: basemaps, tileX: 0, // tile X coordinate tileY: 0, // tile Y coordinate tileZ: 1 // tile zoom level&#125;)); 定位功能定位功能是webgis基本款，因為光有地圖，很多使用者會不知道自己在哪裡而迷了路，因此類似Google關鍵字地標搜尋，可以輸入關鍵字定位的功能，會是webGIS會出現的東西。 這類地標搜尋可以使用Google、Here、Mapbox，有些是免費(有request限制)以些是付費的，像這些POI供應平台申請access token後即可使用他們的API，在這邊我們使用的也是套件:Leaflet.geocoder。 Include the CSS:&lt;link rel=&quot;stylesheet&quot; href=&quot;~/dist/assets/css/Control.Geocoder.css&quot; /&gt; Include the JavaScript:&lt;script src=&quot;~/dist/assets/js/Control.Geocoder.js&quot;&gt;&lt;/script&gt; app.js123var geocoder = L.Control.geocoder(&#123; defaultMarkGeocode: true&#125;).addTo(map); 量測功能在圖上量測距離及面積，我們一樣直接使用模組，並把套件的文字稍微中文化。Include the CSS:&lt;link rel=&quot;stylesheet&quot; href=&quot;~/dist/assets/css/leaflet-measure.css&quot; /&gt; Include the JavaScript:&lt;script src=&quot;~/dist/assets/js/leaflet-measure.js&quot;&gt;&lt;/script&gt; app.js12var measureControl = new L.Control.Measure(&#123; measureControl: true, primaryLengthUnit: &apos;meters&apos;, secondaryLengthUnit: &apos;kilometers&apos; &#125;);measureControl.addTo(map); 後記今天先將版型設置好及將地圖基本款功能放在地圖上，後續我們還有很多部分要實作，明天繼續加油！","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"leaflet","slug":"leaflet","permalink":"https://chimin17.github.io/tags/leaflet/"}]},{"title":"鐵人賽Day 14- webgis中的網格資料","slug":"ironman-2018-day14","date":"2018-01-01T17:11:43.000Z","updated":"2018-10-16T13:32:04.116Z","comments":true,"path":"2018/01/02/ironman-2018-day14/","link":"","permalink":"https://chimin17.github.io/2018/01/02/ironman-2018-day14/","excerpt":"前言網格(raster)資料是指以規則網格的方式呈現空間資料，可能是長這樣。 上面是試圖以geojson模擬網格資料，網格間隔大概是一英里(1.6km)，並且有一個solRad屬性，像這樣用geojson這種向量格式表達網格看起來沒有什麼問題，但是… 假設今天網格的間隔更密一些，範圍在大一些，其資料量可能會很可觀，這時候無論在計算或是前端展示上，GIS傾向會使用影像方式儲存。 再者，上述案例在網格式資料是單一波段的資料(也就是只有solRad這個屬性)，網格資料大多都是三個波段的資料(例如正射影像、衛星影像)，相關討論我們在[Day 6] 常見的GIS資料格式有探討過。 在webGIS中，我們可能比較少直接處理網格資料，通常都是使用它，今天我們試著使用Leaflet的raster圖層功能。","text":"前言網格(raster)資料是指以規則網格的方式呈現空間資料，可能是長這樣。 上面是試圖以geojson模擬網格資料，網格間隔大概是一英里(1.6km)，並且有一個solRad屬性，像這樣用geojson這種向量格式表達網格看起來沒有什麼問題，但是… 假設今天網格的間隔更密一些，範圍在大一些，其資料量可能會很可觀，這時候無論在計算或是前端展示上，GIS傾向會使用影像方式儲存。 再者，上述案例在網格式資料是單一波段的資料(也就是只有solRad這個屬性)，網格資料大多都是三個波段的資料(例如正射影像、衛星影像)，相關討論我們在[Day 6] 常見的GIS資料格式有探討過。 在webGIS中，我們可能比較少直接處理網格資料，通常都是使用它，今天我們試著使用Leaflet的raster圖層功能。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 在地圖放影像:使用Leaflet-ImageOverlay使用ImageOverlay之前我們先要有資料，這邊我們使用內政部20米DTM。 下載下來之後，原始檔案是*.grd，此時必須使用QGIS這套軟體稍作處理，將其轉為.tif或.jpg等。 原先內政部提供的為TWD97，我們把它轉為WGS84，透過crs設定記錄其範圍坐標（後面要用）。 把這張圖片加入地圖，使用imageOverlay，需要使用剛剛記錄的邊界123var imageUrl = &apos;/dist/DEM.tif&apos;;var imageBounds = [[24.8737080, 120.9426029], [24.847877, 120.958343]];var imglayer = L.imageOverlay(imageUrl, imageBounds).addTo(map); 成果： 另外，Leaflet也有VideoOverlay的類別，方法差不多，有需要可以自行參考。 介接圖磚服務(WMTS):使用Leaflet-TileLayer我們在[Day 3] 談互操作性及Web Map Service 標準有提到WMS與WMTS，兩者在Leaflet中分別方法可以放入我們的地圖，以國土測繪中心的WMTS為例，我們從Capabilities的xml檔可以看到介接圖磚的資訊。使用tileLayer實作：1L.tileLayer(&apos;https://wmts.nlsc.gov.tw/wmts/EMAP/default/GoogleMapsCompatible/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;&apos;).addTo(map); 圖磚(web tiles)跟向量圖磚(vector tiles)觀察一下剛剛前面增加的兩個圖層： 可以觀察到： 使用imageOverlay，request部分是把整張影像存取下來而使用tileLayer可以發現整個地圖是以細碎的方式存取，這是兩者最大差異。 對地圖做縮放，imageOverlay並不會重新request資料，tileLayer則會，表示tileLayer是有高度(深度)的。 以上兩點正好可以拿來說明tileLayer，試想，如果我們一次要存取大範圍的影像，使用imageOverlay應該不太妥當，一來影像太大，二來不能依照深度或高度展示不同細節。 圖磚(web tiles)TileLayer或是說WMTS的設計概念如下，簡單來講，就是將原始影像依不同深度切成不同大小的磚，並透過資料標準的方式協定介接規格，所以client端可以根據不同坐標及深度要求不同的資料，而不是整張影像存取，以增加效率：(取自QGIS) 向量圖磚(vector tiles)Vector tiles是這幾年webGIS發展的趨勢，它不像wmts是以影像為respond，而是使用geojson，也就是說，過去我們使用的wmts(指通用版電子地圖這類的，不是指正射影像)，是把點線面向量資料網格化成影像製成tiles，而vector tiles是以向量的方式提供給client端。 使用vector tiles具有這些優勢 (取自mapbox)： 可自行定義地圖樣式 vector tile資料小，存取更快 像是Google map也是採用vector tile的技術，因此可以使用snazzy這類工具產生樣式定義檔，並在地圖上使用。 其他像是cartodb、mapbox，OpenStreetMap的ID editor也是利用vector tile技術，而Leaflet也有相關擴充。","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"geojson","slug":"geojson","permalink":"https://chimin17.github.io/tags/geojson/"},{"name":"leaflet","slug":"leaflet","permalink":"https://chimin17.github.io/tags/leaflet/"}]},{"title":"鐵人賽Day 13- webgis中的向量資料:在leaflet實作","slug":"ironman-2018-day13","date":"2018-01-01T05:11:43.000Z","updated":"2018-10-16T13:31:59.978Z","comments":true,"path":"2018/01/01/ironman-2018-day13/","link":"","permalink":"https://chimin17.github.io/2018/01/01/ironman-2018-day13/","excerpt":"前言在[Day1]webGIS-資訊時代的地理大發現的引言中提到webgis的前端實踐可以透過幾個地圖API，本次鐵人賽將都以leaflet做說明。","text":"前言在[Day1]webGIS-資訊時代的地理大發現的引言中提到webgis的前端實踐可以透過幾個地圖API，本次鐵人賽將都以leaflet做說明。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” Leaflet的向量圖層GIS資料中，資料的類型就是網格資料及向量資料，而我們過去也介紹了向量資料的結構(基本上就是點、線、面)。 在leaflet中，要放向量資料在圖上，可以透過以下物件的實作 Marker Path(以下實作基於此抽象類別) Polyline Polygon Circle CircleMarker Rectangle geojson 下面就來實作一下這些圖層物件。 Marker相當於geojson中的point。1var marker=L.marker([25.0270000, 121.545745]).addTo(map); Polylilne相當於geojson中的linestring1234567var latlngs = [ [25.0270000, 121.545745], [25.0370000, 121.535745], [25.0270000, 121.525745]];var polyline = L.polyline(latlngs);polyline.addTo(map); Polygon12345678var latlngs = [[ [25.0270000, 121.555745], [25.0370000, 121.565745], [25.0270000, 121.575745], [25.0270000, 121.555745]]];var polygon = L.polygon(latlngs).polygon.addTo(map); rectangle與circlerectangle與circle相當於geojson中的polygon跟point的擴充。 rectangle是長方形，他還是基於polygon123var bounds = [[25.0390000, 121.569745], [25.0380000, 121.568745]];// create an orange rectangleL.rectangle(bounds, &#123;color: &quot;#ff7800&quot;, weight: 1&#125;).addTo(map); circle是基於point123var circle= L.circle([25.0370000, 121.515745], &#123;radius: 200&#125;);circle.addTo(map);console.log(circle.toGeoJSON()); geojson實作也可以直接透過把整份geojson資料，例如：12345678910111213141516171819202122232425262728293031323334353637383940414243444546var data=&#123; &quot;type&quot;: &quot;MultiPolygon&quot;, &quot;coordinates&quot;: [ [ [ [ 121.5398, 25.0071 ], [ 121.5831, 25.0112 ], [ 121.5515, 25.0294 ], [ 121.5398, 25.0071 ] ] ], [ [ [ 121.5398, 25.0071 ], [ 121.5031, 25.0112 ], [ 121.5515, 25.0294 ], [ 121.5398, 25.0071 ] ] ] ]&#125;var json=L.geoJSON(data).addTo(map); SVG與CanvasLeaflet在Render時可以選擇SVG與Canvas，兩者的選擇跟其他是HTML5應用需考量的問題類似，Canvas適合展現上萬條polyline、上萬點的POI，當資料很大時，如果使用SVG會使效率不佳。 但是使用Canvas是必須犧牲個別資料間的互動事件(events)。預設的向量資料是採用SVG，這一點可以從執行上面我們的範例程式碼後，可以於地圖上按右鍵並開啟瀏覽器開發者模式觀察到： 指定使用SVG123var map = L.map(&apos;map&apos;, &#123; renderer: L.svg()&#125;); Canvas123var map = L.map(&apos;map&apos;, &#123; renderer: L.canvas()&#125;); 使用Canvas後： 向量資料object幾個常用的Method與Options在webgis中，對於向量資料的操作有一些常用的方法，以下就舉幾個例子： 1234567891011121314//綁定popup於圖層上polyline.bindPopup(&apos;popup&apos;).//顯示popuppolyline.openPopup();//關閉popuppolyline.closePopup();//為綁定click事件並得到物件的geojson內容polyline.on(&apos;click&apos;, function(e)&#123;console.log(e.layer.toGeoJSON())&#125;);//移動到某個位置map.setView([25.0270000, 121.545745], 13);//移動到polyline範圍map.fitBounds(polyline.getBounds()); 在實作這些物件時可以設定option，例如繼承於path的polyline、polygon12345678var option=&#123; color:&apos;#00ff00&apos;, //顏色 weight:3, // 寬度，以pixel為單位 opacity:0.6, //透明度 fill:true, //是否填滿 fillColor&apos;red&apos; //填滿的顏色&#125;var polygon = L.polygon(latlngs, option).addTo(map); 後記今天測試的內容都會放在jsfiddle，有興趣可以自行測試。祝大家新年快樂^^。","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"geojson","slug":"geojson","permalink":"https://chimin17.github.io/tags/geojson/"},{"name":"leaflet","slug":"leaflet","permalink":"https://chimin17.github.io/tags/leaflet/"}]},{"title":"鐵人賽Day 12- webgis中的向量資料-一些特殊的Polygon","slug":"ironman-2018-day12","date":"2017-12-31T02:11:43.000Z","updated":"2018-10-16T13:31:57.058Z","comments":true,"path":"2017/12/31/ironman-2018-day12/","link":"","permalink":"https://chimin17.github.io/2017/12/31/ironman-2018-day12/","excerpt":"前一天講了向量圖層中的線跟面，今天來看一些特殊的幾何資料，雖然少見但還是遇得到，也藉此機會多認識一下Polygon。","text":"前一天講了向量圖層中的線跟面，今天來看一些特殊的幾何資料，雖然少見但還是遇得到，也藉此機會多認識一下Polygon。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” Polygon with hole(Polygon裡面有洞)polygon with hole是polygon內挖個洞，geojson處理polygon with hole的方法是在coordinates中加入hole，而且可以加入多個hole。事實上，polygon的coordinates記錄的內容有兩個部分：12&quot;coordinates&quot;: [[外圈形狀(outter ring array)], [內圈形狀1(inner ring array)],[內圈形狀2(inner ring array)]] 舉個例子，一個有洞的Polygon資料是長這樣(用json ediotr觀察)：coordinates這個array包覆的第一個元素是outter ring，為polygon的外框，第二個元素後面則擺可以選擇性的放多個inner ring，其效果就是在polygon挖洞，並且可以挖很多洞。 實務上，我們偶爾會遇到這種幾何，例如包圍著臺北市的新北市行政區域範圍(上面就是新北市的geojson)，polygon中的coordinates除了outter ring外，跟昨天的Polygon範例相比，多了一個inner ring，如有興趣，新北市geojson請點此下載。(資料取自github twgeojson。) 行政區域界線圖與Multipolygon延續台灣的行政區當例子，行政區除了polygon內要被挖洞以外，當然也有行政區是由多個polgon組成，這時候在GIS資料是用multipolygon表示，例如澎湖等具有島嶼或群島性質的縣市，(澎湖縣geojson請點此下載)。(資料取自github twgeojson。) 飛地除了外島因為地理上就是群島的關係，很合理的需要用到multipolygon，但是在本島，也有不少區域會用到multi polygon，這種現象叫做飛地，例如-屏東縣瑪家鄉(wiki)，除了原本的區域範圍外，因為政府早期鼓勵原住民到平地鄉開墾，因此遷村到原屬於內埔鄉及長治鄉範圍內，形成飛地，需要使用multipolygon表現(瑪家鄉geojson資料請點此下載)。(資料重製自Open Street Map) 後記關於飛地的資料，台灣其實有不少村里，由於一些因素造成遷村(政府政策、災害)，借用原本屬於其他行政區的一塊範圍使用，而出現像是瑪家鄉這樣的飛地。 另外有一件有趣的事，就是發現國土測繪中心opendata的村里界圖資好像怪怪的…，竟然沒有顯示遷村而調整界線，還是沿用沒有遷村的範圍(1967年就遷村了)，可能有特殊理由吧(掌管門牌及行政區界是根據地方自治應該是縣市政府的權責，國土測繪中心這部分只是整合圖資供應的角色)。 總之就是套上官方的行政區域圖後，竟發現瑪家國中位置及門牌竟然在瑪家鄉鄉界的外面…，這個問題我前陣子遇到過一次，還以為是自己程式有bug，弄了半天才發現是這個資料的問題，所以特別拿出來做為參考囉。","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"geojson","slug":"geojson","permalink":"https://chimin17.github.io/tags/geojson/"}]},{"title":"鐵人賽Day 11- webgis中的向量圖層-除了點資料以外的幾何","slug":"ironman-2018-day11","date":"2017-12-30T15:11:43.000Z","updated":"2018-10-16T13:31:53.114Z","comments":true,"path":"2017/12/30/ironman-2018-day11/","link":"","permalink":"https://chimin17.github.io/2017/12/30/ironman-2018-day11/","excerpt":"在Day4、Day5及Day8、Day9談的資料都是點資料，一般使用者最熟悉也最需要的資料也是點，例如各式各樣的POI資料..","text":"在Day4、Day5及Day8、Day9談的資料都是點資料，一般使用者最熟悉也最需要的資料也是點，例如各式各樣的POI資料.. 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 事實上在二維向量GIS資料中還有其他幾何型態，今天就簡單來看看除了點以外的資料：線跟面。 工具：geojson.io非常推薦geojson.io這個線上工具，可以線上編輯geojson及一些基本格式的匯出匯入，如果手邊沒有工具，很推薦用它來做資料基本處理。(示範影片) 以下資料都可以貼到geojson.io看看實際情況喔！ 線：LineString(polyline)line是兩個點連成的一條線，polyline就是多個點依序連成的線，polyline常用於表示路線，在geojson中，geometry的type為LineString，coordinates記錄方式為：[[x1,y1],[x1,y2]…[xn,yn]]123456789101112131415161718192021222324252627&#123; &quot;type&quot;: &quot;FeatureCollection&quot;, &quot;features&quot;: [ &#123; &quot;type&quot;: &quot;Feature&quot;, &quot;properties&quot;: &#123;&#125;, &quot;geometry&quot;: &#123; &quot;type&quot;: &quot;LineString&quot;, &quot;coordinates&quot;: [ [ 121.50518417358397, 25.028994928869533 ], [ 121.53264999389648, 25.024173053538334 ], [ 121.54312133789062, 25.037704933043095 ] ] &#125; &#125; ]&#125; 面：polygonpolygon常用於表示範圍，面狀的資料，一個基本的polygon在coordinates的記錄方式為[[[x1,y1],[x1,y2]…[xn,yn],[x1,y1]]]最後一點要收回第一個節點，形成封閉。 12345678910111213141516171819202122232425262728293031 &#123; &quot;type&quot;: &quot;Feature&quot;, &quot;properties&quot;: &#123;&#125;, &quot;geometry&quot;: &#123; &quot;type&quot;: &quot;Polygon&quot;, &quot;coordinates&quot;: [ [ [ 121.5395164489746, 25.007995055821286 ], [ 121.55153274536133, 25.007995055821286 ], [ 121.55153274536133, 25.029461551911478 ], [ 121.5395164489746, 25.029461551911478 ], [ 121.5395164489746, 25.007995055821286 ] ] ] &#125;&#125; MultiPointgeojson也定義了multipoint，用來表達多個點合併的結果123456&#123; &quot;type&quot;: &quot;MultiPoint&quot;, &quot;coordinates&quot;: [ [121.5398,25.0071], [121.5515,25.0294] ]&#125; MultiLineString一樣也有MultiLineString的定義1234567&#123; &quot;type&quot;: &quot;MultiLineString&quot;, &quot;coordinates&quot;: [ [ [121.5398,25.0071], [121.5515,25.0294]], [ [121.5831,25.0112], [121.5610,25.0224] ] ]&#125; MultiPolygon這是MultiPolygon123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; &quot;type&quot;: &quot;MultiPolygon&quot;, &quot;coordinates&quot;: [ [ [ [ 121.5398, 25.0071 ], [ 121.5831, 25.0112 ], [ 121.5515, 25.0294 ], [ 121.5398, 25.0071 ] ] ], [ [ [ 121.5398, 25.0071 ], [ 121.5031, 25.0112 ], [ 121.5515, 25.0294 ], [ 121.5398, 25.0071 ] ] ] ]&#125; 後記今天先說明了基本的polyline,polygon及其他類似的擴充，跟今天介紹資料時一樣，未來實作時會以geojson為主，而這幾天後續還是會說一些資料的特性，這些幾何資料是webgis的特色，所以，明天繼續囉！","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"geojson","slug":"geojson","permalink":"https://chimin17.github.io/tags/geojson/"}]},{"title":"鐵人賽Day 10-坐標系統及webgis常用的坐標轉換","slug":"ironman-2018-day10","date":"2017-12-29T01:26:43.000Z","updated":"2018-10-16T13:31:49.026Z","comments":true,"path":"2017/12/29/ironman-2018-day10/","link":"","permalink":"https://chimin17.github.io/2017/12/29/ironman-2018-day10/","excerpt":"坐標系統是GIS、大地測量及製圖的核心，而坐標轉換則是開發webGIS最常會遇到的課題。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 坐標系統大地坐標系統: 地球是近似橢球由於地球是近似橢球，會有很多模式來描述這個橢球，以及球上面的點位坐標，描述這個橢球及球上位置的系統稱作大地坐標系統，需要定義的東西很多，包含幾何面的橢球參數、其他物理面及觀測資料的整合推估，GPS使用的WGS84經緯度屬此類，簡單來說，大地坐標系統是想描述橢球及球上面的位置。 Map projection: 一切都是投影為了製造地圖，人們必須把近似橢球狀的地球投影到平面上，這個坐標系統稱作投影坐標系統，只要是地圖，一定會採用投影系統。投影的方式有很多，麥卡托、藍柏特投影等等…，而從Map Projection Transitions網站的各種投影機制的模擬圖可以看得出來，投影一定會有失真的情況，所以才會常常有以下新聞出現: 400年來世界地圖都失真 各國大小差很多格陵蘭島到底有多大，在地圖上一直是個謎","text":"坐標系統是GIS、大地測量及製圖的核心，而坐標轉換則是開發webGIS最常會遇到的課題。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 坐標系統大地坐標系統: 地球是近似橢球由於地球是近似橢球，會有很多模式來描述這個橢球，以及球上面的點位坐標，描述這個橢球及球上位置的系統稱作大地坐標系統，需要定義的東西很多，包含幾何面的橢球參數、其他物理面及觀測資料的整合推估，GPS使用的WGS84經緯度屬此類，簡單來說，大地坐標系統是想描述橢球及球上面的位置。 Map projection: 一切都是投影為了製造地圖，人們必須把近似橢球狀的地球投影到平面上，這個坐標系統稱作投影坐標系統，只要是地圖，一定會採用投影系統。投影的方式有很多，麥卡托、藍柏特投影等等…，而從Map Projection Transitions網站的各種投影機制的模擬圖可以看得出來，投影一定會有失真的情況，所以才會常常有以下新聞出現: 400年來世界地圖都失真 各國大小差很多格陵蘭島到底有多大，在地圖上一直是個謎投影系統一定都是有一好沒兩好，只有最適合的投影，沒有最好的投影，包含小小的台灣，因考量投影的誤差，也分了121中央子午線及119中央子午線的投影帶。 TWD97我們直接來看看訂定及維護我國坐標系統的內政部怎麼說明TWD97(引述自內政部) 新國家坐標系統之名稱命名為1997臺灣大地基準（TWD97），其建構係採用國際地球參考框架（International Terrestrial Reference Frame，簡稱為ITRF）。 ITRF為利用全球測站網之觀測資料成果推算所得之地心坐標系統，其方位採國際時間局（Bureau International de l’Heure` Heure，簡稱為BIH）定義在1984.0時刻之方位。 新國家坐標系統之參考橢球體採用1980年國際大地測量學與地球物理學協會（International Union of Geodesy and Geophysics，簡稱為IUGG）公布之參考橢球體（GRS80），其橢球參數如下：長半徑a=6378137公尺 扁率f=1/298.257222101 臺灣、琉球嶼、綠島、蘭嶼及龜山島等地區之投影方式採用橫麥卡托投影經差二度分帶，其中央子午線為東經121度，投影原點向西平移250,000公尺，中央子午線尺度比為0.9999；另澎湖、金門及馬祖等地區之投影方式，亦採用橫麥卡托投影經差二度分帶，其中央子午線定於東經119度，投影原點向西平移250,000公尺，中央子午線尺度比為0.9999。 大致上可以劃兩個重點: (1)有定義所採用的大地系統、 (2)定義了投影，採橫麥卡托二度分帶，且分兩種投影帶(台灣本島121分帶、澎湖金門馬祖119分帶) ps.好像也遇過117分帶(太平島、南沙等離島)、123分帶(釣魚台等) Web Mercator我國官方的坐標系統是TWD97，而在webgis中，為了互操作性通用的系統為Web Mercator(或稱Google Web Mercator、Spherical Mercator、WGS 84 Web Mercator)，相關說明可以及其前世今生可以參考這篇文章，它其實不是真正的麥卡托投影，儘管這個坐標系一度不被GIS專業人士接受，但目前已經廣泛使用於webgis。 EPSG Geodetic Parameter Dataset為了方便世界各國的坐標系統的轉換及辨識，一般使用EPSG Wkid來為坐標系統取代號，EPSG是(European Petroleum Survey Group) 的縮寫，EPSG定義了世界各國投影、坐標系統一系列的編號WKID(Well Known ID)，在台灣的我們常使用的編碼如下: WMS,WMTS等常使用的Web Mercator :EPSG:3857 kml, geojson默認使用的WGS84:EPSG:4326 TWD97 121分帶:EPSG:3826 TWD97 119分帶:EPSG:3825 TWD67 121分帶(台灣舊系統):EPSG:3828 TWD67 119分帶(台灣舊系統):EPSG:3827 坐標系統在GIS資料中應該都要被記錄，像是shapefile的.prj檔，在解析資料時才能判讀，但在geojson、kml通常沒有類似prj的東西，默認使用EPSG:4326 (也就是WGS84經緯度) 很常搞混3857 or 4326嗎?stackexchange上有這麼一個問題： 到底在Google Earth、Googlemaps、Openlayers、Leaflet應該是要使用EPSG:3857還是EPSG:4326? 最佳答案是這樣： 有些事被混淆了… Google Earth是 EPSG:4326也就是WGS84大地基準 Googlemaps是使用投影系統的EPSG:3857(其中EPSG:3857大地框架是WGS84，使用麥卡托投影) 我們使用的底圖圖磚的資料來源是使用EPSG:4326儲存 但是其發布的Web Service如WMS、WMTS是用EPSG:3857發布的 簡單來說，資料用EPSG:4326存，但地圖底圖Web Service都是使用EPSG:3857(因為地圖是平面，一定是要經過投影的呀！)兩者坐標值域是差很多的： EPSG:4326就是熟悉的經緯度 EPSG:3857台灣地區值域都是八位數(13511000, 2870000) 通常我們只會使用EPSG:4326的資料但不會直接運算EPSG:3857 坐標轉換: 使用proj4WMTS跟WMS主要使用EPSG:3857、geojson、kml通常採用EPSG:4326儲存資料，而我們取得的opendata資料常出現EPSG:3826甚至EPSG:3828等坐標系統….實務上一定會遇到這類問題。 所以我們需要坐標轉換！ proj4是OSGeo（Open Source Geospatial Foundation）維護的坐標轉換工具，有許多程式語言的版本，Javascirpt可以使用proj4js。 安裝npm install proj4 建立test.js 123456789101112131415 var proj4=require(&apos;proj4&apos;);//首先定義坐標系統的參數(這些內容包含使用大地框架、橢球、投影等)，proj4轉換是根據這些參數 proj4.defs([ [ &apos;EPSG:4326&apos;, &apos;+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees&apos;], [ &apos;EPSG:3826&apos;, &apos;+title=TWD97 TM2+proj=tmerc +lat_0=0 +lon_0=121 +k=0.9999 +x_0=250000 +y_0=0 +ellps=GRS80 +units=公尺 +no_defs&apos; ], [ &apos;EPSG:3828&apos;, &apos;+proj=tmerc +lat_0=0 +lon_0=121 +k=0.9999 +x_0=250000 +y_0=0 +ellps=aust_SA&apos; ]]); 轉換 123456789101112var EPSG3826 = new proj4.Proj(&apos;EPSG:3826&apos;);//TWD97 121分帶var EPSG3828 = new proj4.Proj(&apos;EPSG:3828&apos;);//TWD67 121分帶var EPSG4326 = new proj4.Proj(&apos;EPSG:4326&apos;);//WGS84//4326轉3826 (經緯度轉TWD97)var data1 = proj4(EPSG4326, EPSG3826, [121, 23]);//[250000,2544283.12479424]//3826轉3828(TWD97轉TWD67)var data2 = proj4(EPSG4326, EPSG3826, data1);//[249171.10594810007, 2544488.5274230908] 註：Proj4參數取自:台灣大地座標系統的轉換 執行node test.js 後記順著上面的案例，我國有兩個時代的坐標系統TWD97跟TWD67兩者在本島121分帶的差值大概是[dx,dy]=[8xx,2xx] (單位：公尺)因此，如果在拿到一份資料時，如果發現X方向差了800公尺而Y方向差了200公尺，又沒有prj檔的狀況下，可能拿到的資料把TWD67跟TWD97弄混了，對坐標需要有一些敏銳度。 而文中一直提到，在geojson中通常都使用EPSG:4326，但我們取得國內政府平台提供的資料，應該是以適合我國的TWD97測量建置而來。 另外一個重點，如果在金門、澎湖、馬祖等坐標系統記得使用EPSG:3825(TWD97,119)或EPSG:3827(TWD67,119)喔，綜上所述，proj4在webgis一定會需要用到。","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"proj4","slug":"proj4","permalink":"https://chimin17.github.io/tags/proj4/"}]},{"title":"鐵人賽Day 9-自己產製資料-地址定位part2","slug":"ironman-2018-day9","date":"2017-12-28T15:26:43.000Z","updated":"2018-10-16T13:31:45.422Z","comments":true,"path":"2017/12/28/ironman-2018-day9/","link":"","permalink":"https://chimin17.github.io/2017/12/28/ironman-2018-day9/","excerpt":"今天要介紹TGOS全國門牌定位服務。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” TGOS (Taiwan Geospatial One Stop)TGOS是內政部資訊中心維運的系統，整合了很多國內GIS資料，也提供了很多GIS相關API，除了需要申請token的API外，也有民眾版的查詢系統可供線上使用。 TGOS全國門牌定位服務全國門牌定位API服務 整合了國內戶政機關的門牌坐標資料，更新頻率很高，因為各縣市門牌資料在建置時驗收的標準滿高的，所以完整性跟正確性都很高。","text":"今天要介紹TGOS全國門牌定位服務。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” TGOS (Taiwan Geospatial One Stop)TGOS是內政部資訊中心維運的系統，整合了很多國內GIS資料，也提供了很多GIS相關API，除了需要申請token的API外，也有民眾版的查詢系統可供線上使用。 TGOS全國門牌定位服務全國門牌定位API服務 整合了國內戶政機關的門牌坐標資料，更新頻率很高，因為各縣市門牌資料在建置時驗收的標準滿高的，所以完整性跟正確性都很高。 更重要的是該API的模糊查詢的機制滿實用的: 假設今天輸入 [忠孝東路十段380號] ，這是一個不存在的門牌 在Google Geocode可能傳給忠孝東路十段38號(常理上，380號跟38號可能差距天南地北) TGOS可能傳給忠孝東路十段370號，這是一個在空間上比較有關聯的結果 另外也可以選擇單雙號的鎖定(台灣門牌編制，單號通常在一側，雙號在另一側)，實際例子可能要請各位實際去操作看看 操作以下直接實際操作看看 開啟服務網址，輸入門牌 2.系統會跳出一個地圖，並顯示坐標 [關於坐標值] TGOS單筆查詢的坐標值是X是6位數,Y是7位數，跟先前幾天看到的121.XX,24.XX經緯度不一樣這邊顯示的坐標系統是採用國內的TWD97，坐標系統這件事跟製圖有關，世界各國各區都會定義適合自己的局部坐標系統，關於坐標系統，後續打算攻略一番，就靜待下回分曉瞜。 批次操作TGOS門牌API是可以批次使用的(其實批次才是重點)，但是需要申請(網站上有提供教學)，申請後就可以使用啦，目前申請取得token後，好像一天可以使用1萬次。 批次操作的選擇項目比較多，像是可以選輸出的坐標系統。 後記什麼? 坐標系統 ?這邊我們看到個資料坐標系統是TWD97(EPSG:3826)，而之前的提到的資料都是WGS84(EPSG:4326)，關於這些坐標的內容及轉換..，就明天見囉!","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"opendata","slug":"opendata","permalink":"https://chimin17.github.io/tags/opendata/"}]},{"title":"鐵人賽Day 8-自己產製資料-地址定位part1","slug":"ironman-2018-day8","date":"2017-12-27T15:26:43.000Z","updated":"2018-10-16T13:27:45.113Z","comments":true,"path":"2017/12/27/ironman-2018-day8/","link":"","permalink":"https://chimin17.github.io/2017/12/27/ironman-2018-day8/","excerpt":"取得GIS資料的方式有很多，包含： 取得實體檔或API(opendata等資料交換平台) 拿專業儀器測量或在地圖上數化而得：GPS、遙測、工程測量、etc. 地址定位：僅有poi的地址，可從線上資源取得地址的坐標 今天要介紹的為地址定位，如果你也有一批資料有地址沒坐標，那就參考本篇吧^^。","text":"取得GIS資料的方式有很多，包含： 取得實體檔或API(opendata等資料交換平台) 拿專業儀器測量或在地圖上數化而得：GPS、遙測、工程測量、etc. 地址定位：僅有poi的地址，可從線上資源取得地址的坐標 今天要介紹的為地址定位，如果你也有一批資料有地址沒坐標，那就參考本篇吧^^。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 以 臺北市各區農會地址一覽表 臺北市開放資料平臺下載的這份為例，就是具有地址，但沒有坐標 的資料。 我們可以使用一些線上資源幫助我們把它加值為具空間資訊的GIS資料，包括: Google Fusion Table 內政部TGOS門牌對位系統 其它 (例如CartoDB也有支援Here的Geocoding，但需酌收點數) 我們這兩天就來使用看看免費又好用的Google Fusion Table及內政部TGOS門牌對位系統，自己動手產生GIS資料。 Google Fusion Table： Fusion Table是在Google雲端上的一個功能，在Google雲端新增處可選擇 如果找不到，請按 [連結更多應用程式] ，搜尋後找到 fusion table有幾種匯入資料的方式，這邊直接把剛剛的csv匯入，可能要注意一下編碼，中文字常會出現Big5/UTF8的問題 然後會是一些設定(沒啥問題就下一步然後完成) 接著，我們選擇[File]–&gt;[Geocode] Geocode需要設定地址的欄位名稱，設定好後，就直接給它Run下去，需要執行一段時間 然後…就完成了，我們切換至map頁籤看結果，這邊其實可以作一些視覺化設定，包含marker符號及產生熱區圖(heat map) 接著我們可以把資料匯出成kml，再透過[Day 7] 常見的GIS資料格式-轉換篇的程式轉換成想要的格式12345var fs = require(&apos;fs&apos;);var KmlStream = require(&quot;kml-stream&quot;);var data = fs.createReadStream(&apos;./out.kml&apos;).pipe(new KmlStream()).on(&apos;data&apos;, function (d) &#123; console.log(d);&#125;); 在Google Earth可以看到匯出的成果: 後記fusion table是一個快速地址對位的工具，但由於Google門牌資料庫完整度及更新頻率並不是這麼高，正確性及完整性可以還有一些限制，但已經可以滿足大多數需求，有了這個功能，只要手邊有地址，就可以自己的GIS資料自己產啦。 而fusion table其實是基於Google Geocode Api，所以每天只能request2500筆。 另外，這幾天在蒐集資料時，發現Kuro大大之前也非常完整的介紹Fusion Table，或許大家也可以參考唷!","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"google","slug":"google","permalink":"https://chimin17.github.io/tags/google/"}]},{"title":"鐵人賽Day 7-常見的GIS資料格式-轉換篇","slug":"ironman-2018-day7","date":"2017-12-26T15:26:43.000Z","updated":"2018-10-16T13:31:38.943Z","comments":true,"path":"2017/12/26/ironman-2018-day7/","link":"","permalink":"https://chimin17.github.io/2017/12/26/ironman-2018-day7/","excerpt":"昨天介紹了geojson、shapefile、kml基本概念，今天我們簡單用npm上面的工具寫個簡單轉換，有關node.js的安裝及使用請各位參考其他線上教學資源，這邊我們就直接使用囉。","text":"昨天介紹了geojson、shapefile、kml基本概念，今天我們簡單用npm上面的工具寫個簡單轉換，有關node.js的安裝及使用請各位參考其他線上教學資源，這邊我們就直接使用囉。 &gt; 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列”geojson資料轉換工具：這邊使用npm上的geojson2，直接安裝： 1npm install geojson2 建立test.js，寫一個geojson2.kml的轉換1234var geojson2 = require(&apos;geojson2&apos;);geojson2.kml(&apos;test.geojson&apos;, &apos;./out.kml&apos;, function (err) &#123; console.log(&quot;finish&quot;)&#125;) 執行node test.js 結果out.kml12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;kml xmlns=&quot;http://www.opengis.net/kml/2.2&quot;&gt;&lt;Document id=&quot;root_doc&quot;&gt;&lt;Folder&gt;&lt;name&gt;OGRGeoJSON&lt;/name&gt; &lt;Placemark&gt; &lt;name&gt;Dinagat Islands&lt;/name&gt; &lt;Point&gt;&lt;coordinates&gt;125.6,10.1&lt;/coordinates&gt;&lt;/Point&gt; &lt;/Placemark&gt;&lt;/Folder&gt;&lt;/Document&gt;&lt;/kml&gt; geojson2這個模組，包含了四個子功能 geojson2csv geojson2shape geojson2kml geojson2topojson 有需要可以自行測試！ 其中官方文件提到，若要輸出kml and shp. 須先安裝gdalRun ‘brew install gdal’ on OSX,or ‘sudo apt-get install gdal’ on linux. shapefile資料轉換工具：這邊一樣使用NPM上的shp2json 一樣須先安裝gdalRun ‘brew install gdal’ on OSX,or ‘sudo apt-get install gdal’ on linux. 安裝npm install shp2json. 建立test.js123var toJSON = require(&apos;shp2json&apos;);var result = toJSON.fromShpFile(&apos;out.shp&apos;).pipe(process.stdout);console.log(result); 執行node test.js 結果1234567891011&#123; &quot;type&quot;: &quot;FeatureCollection&quot;, &quot;features&quot;: [ &#123; &quot;type&quot;: &quot;Feature&quot;, &quot;properties&quot;: &#123; &quot;name&quot;: &quot;Dinagat Islands&quot; &#125;, &quot;geometry&quot;: &#123; &quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;: [125.6, 10.1] &#125; &#125; ]&#125; kml資料轉換工具：使用NPM上的kml-stream 安裝kml-streamnpm install kml-stream test.js12345var fs = require(&apos;fs&apos;);var KmlStream = require(&quot;kml-stream&quot;);var data = fs.createReadStream(&apos;./out.kml&apos;).pipe(new KmlStream()).on(&apos;data&apos;, function (d) &#123; console.log(d);&#125;); 執行node test.js 結果12345&#123; type: &apos;Feature&apos;, properties: &#123; &#125;, geometry: &#123; type: &apos;Point&apos;, coordinates: [125.6, 10.1] &#125;&#125; 後記基本上只要掌握了這三類資料互轉，大多數webgis線上資源的格式應該幾乎可以掌握了，後續如果真的有其他GIS資料轉換及讀取的問題，建議可進一步研究專業的GIS軟體：QGIS，由於本次鐵人賽的目標是快速上手webgis，比較可惜無法操作太多QGIS，QGIS無論在轉檔、分析及處理等功能都很強大，可以自行試看看唷。","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"Node","slug":"Node","permalink":"https://chimin17.github.io/tags/Node/"},{"name":"javascript","slug":"javascript","permalink":"https://chimin17.github.io/tags/javascript/"}]},{"title":"鐵人賽Day 6-常見的GIS資料格式","slug":"ironman-2018-day6","date":"2017-12-25T15:26:43.000Z","updated":"2018-10-16T13:27:12.119Z","comments":true,"path":"2017/12/25/ironman-2018-day6/","link":"","permalink":"https://chimin17.github.io/2017/12/25/ironman-2018-day6/","excerpt":"前兩天我們先用CARTO(CartoDB)實作了一些基本的GIS資料視覺化，接觸了GIS資料。 延續 [Day3] 談互操作性及Web Map Service 標準議題，我們在處理資料時可能會遇到各種GIS格式，今日就來攻略幾種web常用的GIS資料格式。","text":"前兩天我們先用CARTO(CartoDB)實作了一些基本的GIS資料視覺化，接觸了GIS資料。 延續 [Day3] 談互操作性及Web Map Service 標準議題，我們在處理資料時可能會遇到各種GIS格式，今日就來攻略幾種web常用的GIS資料格式。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 先釐清一下資料型態根據教科書，所謂GIS資料就是具備空間資訊的資料，依照資料型態可以分成兩類 網格資料(raster) 向量資料(vector) 網格資料：網格資料指的通常是影像類型等規則網格的資料，例如衛星影像、高程模型(用來表示地形)，以像元(pixel)為基礎，每個pixel會有一些資訊如R,G,B, 或是深度、高度，等，賦予每一個pixel對應的空間坐標，就是一個網格式GIS資料，而賦予坐標的做法通常是定義網格大小、起始網格坐標、以及方向，定義這些資訊的檔案稱作 world file，常用的格式如geotiff、tiff、jpg、bmp等影像檔具有world file都屬於此類。 向量資料：比起網格式資料可能都是使用專業人員處理好的資料，向量式資料在應用上常見得多，又依表示方法分成：點、線、面（註） 註：點線面是統稱，在2D 又可細分為multi points, multi polygon…etc. 在3D GIS的世界，相關格式另有一片天….。 本篇主要談的資料格式屬於向量式資料geojson (http://geojson.org/)geojson我們在第二天的範例中就已經在地圖上介接了一個開放資料範例，而跟前幾天提到GIS常用的OGC標準不同，geojson非OGC標準，是由IETF(Internet Engineering Task Force)組織訂定的，因為是json物件的方式表現，使用起來可說是簡單好用，於webgis廣為流通，目前版本的geojson(RFC 7946)具有以下特徵： JSON，流通方便 一個geojson結構如下： 12345678910&#123; &quot;type&quot;: &quot;Feature&quot;, &quot;geometry&quot;: &#123; &quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;: [125.6, 10.1] &#125;, &quot;properties&quot;: &#123; &quot;name&quot;: &quot;Dinagat Islands&quot; &#125;&#125; 幾何樣態（geometry Type）：Point, LineString, Polygon, MultiPoint, MultiLineString, and MultiPolygon 坐標(coordinates)：不同幾何形態有不同坐標值記錄方式，可以參考 wiki範例，而且並沒有定義投影坐標系統的欄位，通常默認為EPSG4326(也就是wgs84經緯度) 屬性(properties)：在properties以key-value方式記錄每一筆資料的屬性欄位 ESRI shapefile(shp)shapefile在GIS領域廣為使用多年，目前仍廣泛使用中，它是GIS應用軟體供應商ESRI定義的格式，亦已部分公開相關結構，大多數GIS軟體(如QGIS、Arcgis等)也都支援。要解析shapefile，可參考github上有許多shapefile library，而一個shapefile通常包含很多附屬檔案(wiki)： Shapefile圖形格式 (.shp) Shapefile圖形索引格式(.shx) Shapefile屬性格式(.dbf)，屬性資料庫 Shapefile投影格式(.prj)，紀錄坐標系統 Shapefile空間索引格式(.sbn) 一個shapefile只會有一種幾何形態，共支援Point, Polyline, Polygon, 等13類的幾何型態資料，更多shape資料問題可參考wiki。 這邊要特別分享一個小小使用經驗： shapefile因為具有(.prj)檔案記錄投影坐標系統的特性，與geojson有個不同的地方在於它可以使用不同的坐標系統(一般來說geojson都是使用ESPG4326，也就是wgs84經緯度)，我們拿到一份shapefile可能會是各式各樣坐標系統，這些坐標值是存在shp內，當我們偶爾會拿到沒有prj檔的shapefile時，可能會遇到對於shp內坐標值到底是啥而一頭霧水的現象，這時便需要經驗判斷資料的坐標系統喔！(關於坐標系統，預計過兩天再來攻略^^) kmlkml是OGC規範格式，廣泛用於Google Earth等平台上，它是xml方式表達GIS資料，並且包含了其在Google Earth上的樣式資料，基本上都使用ESPG4326的經緯度坐標，範例如下(wiki)123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;kml xmlns=&quot;http://www.opengis.net/kml/2.2&quot;&gt;&lt;Document&gt;&lt;Placemark&gt; &lt;name&gt;New York City&lt;/name&gt; &lt;description&gt;New York City&lt;/description&gt; &lt;Point&gt; &lt;coordinates&gt;-74.006393,40.714172,0&lt;/coordinates&gt; &lt;/Point&gt;&lt;/Placemark&gt;&lt;/Document&gt;&lt;/kml&gt; 在我過去使用kml的經驗，Google Earth對於kml在樣式屬性上實在非常具有彈性，他甚至可以定義其在Google Earth上的Popup內容、視角、事件等等，個人覺得算是很單純但又很難掌握(ㄊㄠˇ 一ㄢˋ)的格式(樣式部分) topojsontopojson是geojson的擴充，大致上是基於geojson但具資訊壓縮並考量位相關係的(topology)的資料格式(請參考topojson spec文件)，廣泛用於webgis及d3.js資料視覺化(作者同時也是d3.js作者Mike Bostock)，關於topojson詳細的規格可以直接參考文件，在這邊我們先快速來看看一個Taiwan.TopoJSON範例(因長度關係，請直接前往github上的範例)。 拿到資料後，我們把資料複製到json edirtor檢視： 從資料格式架構中可以看到，topojson相較於geojson多增加了幾個項目:bbox、transform、arcs bbox: 記錄的是這份geojson的邊界 transfrom: 記錄兩個尺度及兩個平移參數，在topojson中為了減少記錄位數，坐標都是用int方式記錄，再靠transform參數還原 arcs: 記錄資料中的邊，arcs分兩個部分，一個是最外層的arcs記錄所有的邊，第二個是每個幾何物件中的arcs記錄的為arc index，每個幾何物件內的arcs都參照最外層arcs，如此是以共邊的概念記錄每個物件的幾何，減低資料量並保有位相關係(topology) objects: GIS資料物件陣列，包含幾何及屬性 後記geojson、shapefile、kml在webgis中最常被用到，資料交換也常依賴這幾類格式，大多數webgis平台都支援這些資料形式，因此大家一定會碰到，今天先介紹這些格式，明天預計來攻略這幾類的資料轉換(這應該才是最重要的^^)。","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"},{"name":"json","slug":"json","permalink":"https://chimin17.github.io/tags/json/"}]},{"title":"鐵人賽Day 3-談互操作性及Web service 標準","slug":"ironman-2018-day3","date":"2017-12-22T15:26:43.000Z","updated":"2018-10-16T13:27:14.000Z","comments":true,"path":"2017/12/22/ironman-2018-day3/","link":"","permalink":"https://chimin17.github.io/2017/12/22/ironman-2018-day3/","excerpt":"前一天用了Leaflet了一個地圖，並接了國土測繪中心的WMTS跟一個geojson，像是WMTS(Web Map Tile Service)這類web service已廣泛流通於webgis世界，今天試著來使用這些標準。 Interoperability &amp; Standard在進入今天的主題「空間資料的格式及標準」之前，先來個名詞解釋—Interoperability。Interoperability中文為互操作性，IEEE對於互操作性的定義如下(維基百科) 兩個或多個系統之間交換信息之能力，以及對交換的信息加以使用之能力","text":"前一天用了Leaflet了一個地圖，並接了國土測繪中心的WMTS跟一個geojson，像是WMTS(Web Map Tile Service)這類web service已廣泛流通於webgis世界，今天試著來使用這些標準。 Interoperability &amp; Standard在進入今天的主題「空間資料的格式及標準」之前，先來個名詞解釋—Interoperability。Interoperability中文為互操作性，IEEE對於互操作性的定義如下(維基百科) 兩個或多個系統之間交換信息之能力，以及對交換的信息加以使用之能力 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 看完這句話，或許各位還是對於interoperability感到抽象。各位可以想像一下，若兩千多年前秦始皇沒有統一文字、統一度量衡、統一貨幣，那會是個什麼樣的狀況？是不是大家難以溝通，公說公有理，婆說婆有理，無法達到「共識」。 為了解決這樣異質性的問題，「標準」(standard)就因此誕生了！大家只要遵照著標準，就能夠理解對方所說的話、做的事，達到互操作性。 那標準是誰來訂定的呢？其實世界上有許多不為人知的標準組織為各自領域努力建立標準（像螞蟻～默默做自己～～）。標準組織百百種，而最有名的就屬ISO (International Organization for Standardization)。由於組織規模大，其所訂定的標準也是包山包海，像是常聽到的ISO 9001（品質管理系統）、ISO 22000（食品安全管理系統）及ISO 27001（資訊安全管理系統）等驗證均是由ISO國際標準組織所制訂。 而地理資訊的開放標準是由一個叫 OGC(Open Geospatial Consortium) 的組織來訂定。OGC成立於1994年，是一個國際的非營利組織，由許多公司、政府單位及學術研究機構所組成。其建立了50多項地理資訊標準（官方網站），如 KML，為用於Google Earth展示向量資料（點、線、面）的檔案格式。 WMS(Web Map Service)為網路地圖服務。 WMTS(Web Map Tile Service)也是地圖服務，和WMS不同的是WMTS是提供地圖的「圖磚」(Tiles)，也就是把地圖切成一小塊一小塊給用戶端，提高展示效能。 WFS(Web Feature Service)是負責提供向量資料的服務。 SOS(Sensor Observation Service)則是提供感測器資料，如雨量、氣溫等觀測資料的服務。 另外其他許多OGC標準的網路服務或資料格式，族繁不及備載。除了OGC，ESRI的Shapefile也是常見的地理資料標準，但並不是開放標準。註:常見的geojson也非OGC標準，這些資料格式後面幾天找機會攻略 WMS使用教學上面提到那麼多OGC的網路服務，包含我們前一天接的WMTS也屬其中之一，這邊就挑WMS來為各位示範如何透過WMS來取得地圖。 取得地圖分為兩個步驟，分別是GetCapabilities以及GetMap。 GetCapabilities就是取得網路服務的詮釋資料（metadata），意思是先看看這個服務提供哪些地圖？地圖範圍如何？坐標系統是什麼？諸如此類的資料描述都會在這個步驟取得，才能夠決定你要哪張地圖。 而GetMap則是根據上一步驟的資訊，向服務提出取得地圖的要求。 範例如下： 在WMS服務網址 https://neo.sci.gsfc.nasa.gov/wms/wms 後加上request參數?service=WMS&amp;request=GetCapabilities，代表對WMS服務寄送一個GetCapabilities的要求，如下所示。若要求成功會收到一份XML資料，:::successhttps://neo.sci.gsfc.nasa.gov/wms/wms?service=WMS&amp;request=GetCapabilities::: 我們先跳到GetMap要求，GetMap要求所需的參數如下： 參數 描述 version=VERSION WMS版本 request=GetMap 對WMS送GetMap request layers=LAYERNAME WMS的地圖單位為Layer，此參數為Layer名稱 style=STYLE 黑白或彩色影像 crs=CRS 坐標系統 bbox=MINX,MINY,MAXX,MAXY 欲取得的地圖範圍 width=WIDTH 輸出地圖寬度 height=HEIGHT 輸出地圖高度 format=FORMAT 輸出地圖格式 而這些參數就是從步驟一的Capabilities XML來取得。 GetMap要求範例如下：:::successhttps://neo.sci.gsfc.nasa.gov/wms/wms?version=1.3.0&amp;request=GetMap&amp;layers=MOD14A1_M_FIRE&amp;style=rgb&amp;crs=CRS:84&amp;bbox=-180,-90,180,90&amp;width=720&amp;height=360&amp;format=image/png::: 得到的Map如下： 用一個GET request的方式就能夠得到一張地圖影像，使用者只需根據自己的需求來調整參數，是不是很方便呢？ 結語隨這網際網路的發展，地理資訊也逐漸朝向WebGIS的方向前進。越來越多人能夠透過網路交流地理資訊，因此標準及網路服務即是奠定的基礎。 像是Leaflet.js這類的前端地圖框架，當然支援WMS標準的資料介接，也因此我們可以使用它們官方文件的方法去接地圖資料，例如我們昨天使用的內政部國土測繪中心WMTS (WMTS即是WMS加入Tiled web map的概念，加快服務存取效率)。 今天主要整理了WMS的說明，後續仍有webGIS會遇到的各種GIS格式及坐標系統攻略，在介紹資料之前，接下來兩天會先用一些線上GIS資料視覺化SDK，看一下GIS資料可以怎麼用。","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"}]},{"title":"鐵人賽Day 2-webGIS初步","slug":"ironman-2018-day2","date":"2017-12-21T15:26:43.000Z","updated":"2018-10-16T13:26:00.124Z","comments":true,"path":"2017/12/21/ironman-2018-day2/","link":"","permalink":"https://chimin17.github.io/2017/12/21/ironman-2018-day2/","excerpt":"webgis：從Client端及Server端談起Clinet端：跟一般網頁應用程式一樣，webgis需要前端程式與使用者互動，要開發一個webgis，開發者可以使用各種前端框架。然而，要炒一盤webgis的菜，就必須要有專屬於gis/地圖的前端框架 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 這些框架主要功能包含提供地圖，圖層渲染，基本地圖互動、介接資料等功能，Javascript常見的webgis框架包含: (1)leaflet (2)openlayers (3)google maps api (4)esri javascript api 一個地圖框架提供我們基本地圖操作，把地圖元素(含空間坐標物件)轉換成前端可操作的元件(DOM等)，而為使地圖互動更生動活潑，其它前端工具當然也是可以整合進來的，包含Jquery, Vue, React, Angularjs…甚至D3.js, C3.js等可能都需要整合在webGIS中。","text":"webgis：從Client端及Server端談起Clinet端：跟一般網頁應用程式一樣，webgis需要前端程式與使用者互動，要開發一個webgis，開發者可以使用各種前端框架。然而，要炒一盤webgis的菜，就必須要有專屬於gis/地圖的前端框架 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 這些框架主要功能包含提供地圖，圖層渲染，基本地圖互動、介接資料等功能，Javascript常見的webgis框架包含: (1)leaflet (2)openlayers (3)google maps api (4)esri javascript api 一個地圖框架提供我們基本地圖操作，把地圖元素(含空間坐標物件)轉換成前端可操作的元件(DOM等)，而為使地圖互動更生動活潑，其它前端工具當然也是可以整合進來的，包含Jquery, Vue, React, Angularjs…甚至D3.js, C3.js等可能都需要整合在webGIS中。 Server端：Web service及資料庫在webGIS應用程式中，可以透過Web service來進行資料操作，這之中最常使用到的是網路圖磚服務(WMTS)，例如我們透過 Google maps api 在網頁之中建立一個地圖，這時可以看到Google maps的底圖，這個底圖服務就是透過類似WMTS的概念來實作的。 另一個面向是資料庫，具有空間資料的資料庫稱作「空間資料庫」，空間資料庫能夠執行各種空間查詢，目前包含MSSQL(SQL Spatial)、Postgressql(PostGIS)、 Oracle(Oracel Spatial)、MySQL、MongoDB等各大資料庫系統都有支援空間資料庫的格式及模組。 先直接來個範例上面長篇大論講了一堆，本次鐵人賽的目標是把這些事情說清楚，逐一擊破。 以下先快速開始一個範例:我們使用leaflet.js new一個地圖並以線上WMTS作為底圖，並把一些資料放上圖台，這樣其實就是最簡單的一個webGIS。 引入必要元件12345&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.2.0/dist/leaflet.css&quot; /&gt;&lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.min.js&quot; integrity=&quot;sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/leaflet@1.2.0/dist/leaflet.js&quot;&gt;&lt;/script&gt; 初始化一個地圖並設定中心經緯度為[25.0375928,121.5529563], 比例尺尺度為10的視角12&lt;div id=&apos;map_div&apos; style=&quot;height:100%&quot;&gt;&lt;/div&gt;var map = L.map(&apos;map_div&apos;).setView([25.0375928,121.5529563], 10); 一個地圖應用都需要底圖，這邊我們使用官方維護的內政部國土測繪中心wmts123var basemap = L.tileLayer(&apos;https://wmts.nlsc.gov.tw/wmts/EMAP/default/GoogleMapsCompatible/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;&apos;, &#123; attribution: &apos;&amp;copy; &lt;a href=&quot;http://osm.org/copyright&quot;&gt;OpenStreetMap&lt;/a&gt; contributors&apos;&#125;).addTo(map); 接下來，webGIS都會有自己的資料，可能是靜態的，也可以是需要資料庫IO的可能需要從Server side 寫一個api接口取資料c#:(示意)1234567891011//取資料接口..[Route(&quot;api/Poi&quot;)][httpget] public JsonResult Poi()&#123; //Bson collection example [&#123;&quot;name&quot;:&quot;市府店&quot;,&quot;geo&quot;:[25.0375,121.5529]&#125;,&#123;&quot;name&quot;:&quot;西門店&quot;,&quot;geo&quot;:[25.0401,121.509]&#125;....] List&lt;PoiDataModel&gt; pois = List&lt;PoiDataModel&gt;(); //取資料... 略.. return Json(...)&#125; client side:接上面的api,把資料放在地圖上12345678910111213$.ajax(&#123; url: &quot;/api/Poi&quot;, contentType: &apos;application/json&apos;, type: &apos;GET&apos;, contentType: &apos;application/json; charset=utf-8&apos;, success: function(data) &#123; $.each(data.pois, function(k, v) &#123; L.marker([v[0], v[1]]).addTo(map) .bindPopup(v.name) .openPopup(); &#125;); &#125;&#125;); 另外，可能需要介接其它api資料，我們的範例資料是一個展店的計畫，在此，我們有需求是看看周圍的商家資料。這邊我們介接經濟部開放資料說明: A-3 鄰近商家查詢：透過坐標參數，查詢所在位置鄰近商家清冊資料。 接到的資料是geojson，把它們放到地圖上並以不同符號表示12345678910111213141516171819$.ajax(&#123; url: &quot;https://egis.moea.gov.tw/MoeaEGFxData_WebAPI_Inside/InnoServe/BusinessBUSM?resptype=GeoJson&amp;x=121.509&amp;y=25.0401&amp;buffer=1000&quot;, type: &apos;GET&apos;, success: function (data) &#123; var symbol = &#123; radius: 3, fillColor: &quot;#ff7800&quot;, color: &quot;#000&quot;, weight: 1, opacity: 1, fillOpacity: 0.8 &#125;; L.geoJSON(data, &#123; pointToLayer: function (feature, latlng) &#123; return L.circleMarker(latlng, symbol); &#125; &#125;).addTo(map); &#125;&#125;); 完整程式碼 client side(map.html):1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.2.0/dist/leaflet.css&quot; /&gt;&lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.min.js&quot; integrity=&quot;sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/leaflet@1.2.0/dist/leaflet.js&quot;&gt;&lt;/script&gt;&lt;div id=&apos;map_div&apos; style=&quot;height:100%&quot;&gt;&lt;/div&gt;&lt;script&gt;//利用leaflet初始化地圖var map = L.map(&apos;map_div&apos;).setView([25.0375928,121.5529563], 10);//加入內政部國土測繪中心wmtsvar basemap=L.tileLayer(&apos;https://wmts.nlsc.gov.tw/wmts/EMAP/default/GoogleMapsCompatible/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;&apos;, &#123; attribution: &apos;&amp;copy; &lt;a href=&quot;http://osm.org/copyright&quot;&gt;OpenStreetMap&lt;/a&gt; contributors&apos; &#125;).addTo(map);//從Server端API接口把POI展在地圖上,並binding一個popup$.ajax(&#123; url: &quot;/api/Poi&quot;, contentType: &apos;application/json&apos;, type: &apos;GET&apos;, contentType: &apos;application/json; charset=utf-8&apos;, success: function(data) &#123; $.each(data.pois, function(k, v) &#123; L.marker([v[0], v[1]]).addTo(map) .bindPopup(v.name) .openPopup(); &#125;); &#125;&#125;);//介接經濟部商家查詢api$.ajax(&#123; url: &quot;https://egis.moea.gov.tw/MoeaEGFxData_WebAPI_Inside/InnoServe/BusinessBUSM?resptype=GeoJson&amp;x=121.509&amp;y=25.0401&amp;buffer=1000&quot;, type: &apos;GET&apos;, success: function (data) &#123; var symbol = &#123; radius: 3, fillColor: &quot;#ff7800&quot;, color: &quot;#000&quot;, weight: 1, opacity: 1, fillOpacity: 0.8 &#125;; L.geoJSON(data, &#123; pointToLayer: function (feature, latlng) &#123; return L.circleMarker(latlng, symbol); &#125; &#125;).addTo(map); &#125;&#125;);&lt;/script&gt; server side(ApiController.cs):API接口取資料庫中的據點資料，假設使用mongodb去Query到bson document..123456789101112131415161718192021//取資料接口..[Route(&quot;api/Poi&quot;)][httpget] public JsonResult Poi()&#123; //Bson collection example [&#123;&quot;name&quot;:&quot;市府店&quot;,&quot;geo&quot;:[25.0375,121.5529]&#125;,&#123;&quot;name&quot;:&quot;西門店&quot;,&quot;geo&quot;:[25.0401,121.509]&#125;....] List&lt;PoiDataModel&gt; pois = List&lt;PoiDataModel&gt;(); //取資料... 略.. return Json(...)&#125;//新增資料接口...[Route(&quot;api/Poi&quot;)][httppost]public JsonResult GetPois(PoiDataModel poi)&#123; //新增資料進資料庫... 略..&#125; 上面範例，結果如下:","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"}]},{"title":"鐵人賽Day 1-webGIS:資訊時代的地理大發現","slug":"ironman-2018-day1","date":"2017-12-20T15:26:43.000Z","updated":"2018-10-16T13:25:37.085Z","comments":true,"path":"2017/12/20/ironman-2018-day1/","link":"","permalink":"https://chimin17.github.io/2017/12/20/ironman-2018-day1/","excerpt":"webGIS-資訊時代的地理大發現在現代的網頁應用中，地圖應用已經成為了不可或缺的網頁元素，一個現代網頁中，有了地圖應用，可以讓使用者查詢空間資訊；開發者亦可實踐各種LBS(Location Based Services)及IOT(Internet of Things)的應用。 目前網路上有許多開發資源可以協助我們建構一些地圖應用，並且透過資料視覺化及UI/UX，使空間資訊有效地呈現給user，user也可以request資訊，讓系統是雙向互動的，相關的應用國內外都有很多案例。 然而，目前線上整合這些資源且能涵蓋背後相關技術的完整介紹並不多，我們團隊希望藉由2018 IT邦鐵人賽機會，除整合資源應用外，再加碼一些GIS相關技術面探討，目標是運用開源軟體，30天打造一個webGIS系統。","text":"webGIS-資訊時代的地理大發現在現代的網頁應用中，地圖應用已經成為了不可或缺的網頁元素，一個現代網頁中，有了地圖應用，可以讓使用者查詢空間資訊；開發者亦可實踐各種LBS(Location Based Services)及IOT(Internet of Things)的應用。 目前網路上有許多開發資源可以協助我們建構一些地圖應用，並且透過資料視覺化及UI/UX，使空間資訊有效地呈現給user，user也可以request資訊，讓系統是雙向互動的，相關的應用國內外都有很多案例。 然而，目前線上整合這些資源且能涵蓋背後相關技術的完整介紹並不多，我們團隊希望藉由2018 IT邦鐵人賽機會，除整合資源應用外，再加碼一些GIS相關技術面探討，目標是運用開源軟體，30天打造一個webGIS系統。 本文是參加鐵人賽的文章，同步發表於 “2018鐵人賽-30天打造我的WebGIS系列” 地圖應用與webGISGIS是地理資訊系統(Geographical Information System)的英文縮寫，GIS在學術及產業應用上發展已經蓬勃發展數十年，而webGIS簡單來說就是把GIS應用在網頁相關平台上。 根據GIS應用軟體供應商龍頭Esri的定義： In its simplest form, web GIS can be defined as any GIS that uses web technology to communicate between a server and a client (Esri) 更具體一點，Esri認為webGIS包含以下元素 The server has a URL so that clients can find it on the web. The client relies on HTTP specifications to send - requests to the server. The server performs the requested GIS operations and &gt; sends responses to the client via HTTP. The format of the response sent to the client can be in many formats, such as HTML, binary image, XML (Extensible Markup Language), or JSON (JavaScript Object Notation). 上述文字基本上描述了webGIS的核心，在此我們可以加以擴充，有了webGIS技術，配合前後端技術的整合，得以讓網頁加入地圖應用元素。 參考文獻: http://www.geo-jobe.com/videos/web-gis-explained-5-essential-elements-web-gis/ 規劃架構以下是擬定的架構，希望能完整走過： 開發之前，先暸解資料：GIS資料基本概念、資料處理、如何自製資料 一些既有的線上SDK: CARTO, Google Fusion table webGIS開發資源: 資源介紹, 創造資源(OSM) 資源實作: 開始整合各種接API 進階處理: 空間資料庫處理、空間運算 綜合演練 關於作者服務於國內知名工程顧問公司的GIS應用開發團隊，希望藉由此次經驗，強化自己對開源軟體及本身核心技術的暸解！","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"2018鐵人賽-30天打造我的WebGIS系列","slug":"2018鐵人賽-30天打造我的WebGIS系列","permalink":"https://chimin17.github.io/tags/2018鐵人賽-30天打造我的WebGIS系列/"},{"name":"web","slug":"web","permalink":"https://chimin17.github.io/tags/web/"},{"name":"GIS","slug":"GIS","permalink":"https://chimin17.github.io/tags/GIS/"}]},{"title":"annaconda python環境快速搭建","slug":"annaconda","date":"2017-08-26T13:50:34.000Z","updated":"2017-12-27T04:59:30.731Z","comments":true,"path":"2017/08/26/annaconda/","link":"","permalink":"https://chimin17.github.io/2017/08/26/annaconda/","excerpt":"","text":"annoconda快速搭建 1.下載–首先去annconda官網下載選擇x64環境或是x86之安裝檔例如要跑arcpy必須在x86 環境執行經測試x86 跟x64 annaconda可以並存 2. 安裝1.一鍵安裝Anaconda2.Anaconda Navigator 設定環境(例如設定python2.7, python3.6環境) 3.使用conda prompt pip install 可擴充相關模組 4.IPython 逐行操作 5.使用spyder run, variable viewer 3.模組1.Anaconda 32bit- with python2.72.Archook Arcpy 找尋環境中的python路徑 -Github Githook pip install archook123456python=1import archook #The module which locates arcgisarchook.get_arcpy()import arcpy#下面就可以寫python了# 4.基本操作1.if2.for3.list, array,tuple============================ 5.常用模組1.shapefile2.math,csv3.繪圖matplotlib","categories":[{"name":"python","slug":"python","permalink":"https://chimin17.github.io/categories/python/"}],"tags":[]},{"title":"Hello Hexo","slug":"hello-world","date":"2017-08-25T12:15:00.000Z","updated":"2017-08-27T23:29:24.000Z","comments":true,"path":"2017/08/25/hello-world/","link":"","permalink":"https://chimin17.github.io/2017/08/25/hello-world/","excerpt":"","text":"Hexo 是基於node.js 開發的部落格框架，文章內容主要是以markdown撰寫，並可藉由hexo-git-deploy部署到 Github pages靜態網頁服務部署完成後網址: https://&lt;帳號&gt;.github.io 官網 Hexo ps.似乎國人開發的 主題包 themes 搭建Hexo步驟如下 安裝Node.js 安裝Hexo 1$ npm install hexo -g 創建專案資料夾，並在裡面初始化初始化： 1$ hexo init 喜好設定 _config.yml （可使用預設） 喜好設定 下載next主題(官網有很多主題) 1git clone https://github.com/iissnan/hexo-theme-next.git themes/next 喜好設定 修改_config.yml的theme為next 1- theme: next 喜好設定 修改theme/next/_config.yml的menu項目自定義選單 如果要新增貼文 1$ hexo new post hello world 如果要新增頁面 1$ hexo new page about 編譯 1$ hexo generate 在本機運行 1$ hexo server 如要部署到Github.io 創建一個repository名稱為&lt;帳號&gt;.github.io 在repository開通Github pages 設定好 _config.yml 的 deploy參數 (github), 部署 Docs: https://hexo.io/docs/deployment.html1234deploy:type: gitrepository: git@github.com:&lt;帳號&gt;/&lt;帳號&gt;.github.io.gitbranch: master 1$ hexo delploy","categories":[{"name":"web","slug":"web","permalink":"https://chimin17.github.io/categories/web/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://chimin17.github.io/tags/Hexo/"},{"name":"github","slug":"github","permalink":"https://chimin17.github.io/tags/github/"}]}]}