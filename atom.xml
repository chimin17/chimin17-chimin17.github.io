<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chimin&#39;s Blog</title>
  
  <subtitle>Chimin&#39;s 技術分享筆記</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chimin17.github.io/"/>
  <updated>2018-11-28T04:27:38.069Z</updated>
  <id>https://chimin17.github.io/</id>
  
  <author>
    <name>Chi-Min Chiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>鐵人賽2019 Day30 GIS Day(完結)</title>
    <link href="https://chimin17.github.io/2018/11/14/ironman-2019-day30/"/>
    <id>https://chimin17.github.io/2018/11/14/ironman-2019-day30/</id>
    <published>2018-11-14T15:30:36.000Z</published>
    <updated>2018-11-28T04:27:38.069Z</updated>
    
    <content type="html"><![CDATA[<p>首先，宣傳一下我的團隊：<a href="https://ithelp.ithome.com.tw/ironman/signup/team/44" target="_blank" rel="noopener">這樣母Tom姆熊</a><br>這30天要不是硬拉了這些隊友，然後看他們一天天準時發文，可能會因為各種原因而寫不下去XD。</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181114/20107816v4m4DXg8FC.png" alt="https://ithelp.ithome.com.tw/upload/images/20181114/20107816v4m4DXg8FC.png"><br><img src="https://ithelp.ithome.com.tw/upload/images/20181114/201078160Ym2daNvAr.png" alt="https://ithelp.ithome.com.tw/upload/images/20181114/201078160Ym2daNvAr.png"></p><a id="more"></a><h2 id="GIS與AI"><a href="#GIS與AI" class="headerlink" title="GIS與AI"></a>GIS與AI</h2><p>GIS常會出現在AI相關的主題中，例如[<a href="https://azure.microsoft.com/en-us/blog/announcing-azure-location-based-services-public-preview/" target="_blank" rel="noopener">LBS</a>]、[<a href="https://www.youtube.com/watch?v=3C1Cd2wHh-c" target="_blank" rel="noopener">即時導航與交通</a>]、[<a href="http://technews.tw/2018/01/31/esri-collaborates-with-mobileye-to-bring-real-time-sensor-data-to-public-transit/" target="_blank" rel="noopener">交通事故的防範與檢討</a>]、[<a href="https://www.softwareadvice.com/resources/optimize-utility-asset-management-with-gis/" target="_blank" rel="noopener">道路工程的管理</a>]、[<a href="https://www.esri.com/about/newsroom/publications/wherenext/enterprise-technology-behind-big-business-decisions/" target="_blank" rel="noopener">商業開發分析</a>]，[<a href="https://www.esri.com/en-us/arcgis/real-time" target="_blank" rel="noopener">智慧城市與物聯網</a>]，以及[<a href="https://www.tomtom.com/automotive/automotive-solutions/automated-driving/hd-map-roaddna/" target="_blank" rel="noopener">現在進行式的自駕車地圖</a>]。</p><p>前陣子看到一個<a href="https://www.youtube.com/watch?v=kJXUUO5M4ok" target="_blank" rel="noopener">Scipy演講</a>，提到在某民宿網站的分析中(使用KNeighborsRegressor)，加入民宿的位置資訊的分析結果比單純使用用戶資訊的結果有更好的精度，相關案例國內外都有很多，空間資料的價值無需再多點綴。</p><p>然而，以上的案例與說明幾乎沒有在本系列文出現XD。</p><p>這次花了30天每天用一點時間完成挑戰，希望能把投入回歸到GIS工程本身(雖然很快發現非三言兩語就可以消化並寫出來，所以只敢寫少少的)，畢竟要有好的應用系統，絕對是要有好的資料、QA與持續更新的資料架構，而這30天依循自己的想像，建構GIS資料處理上或遇到的課題脈絡，循著這些<code>GIS資料分析</code>的脈絡尋找實作方法與工具。</p><p>當然，還是老套的說，這只是開始，資料工程上還是要持續擴充與學習。</p><h2 id="索引目錄"><a href="#索引目錄" class="headerlink" title="索引目錄"></a>索引目錄</h2><p>以下是這30天的索引目錄</p><p><a href="https://ithelp.ithome.com.tw/articles/10201932" target="_blank" rel="noopener">Day01 前言與目標 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天</a></p><p>向量資料處理<br><a href="https://ithelp.ithome.com.tw/articles/10202336" target="_blank" rel="noopener">Day02 Geopandas初探 </a><br><a href="https://ithelp.ithome.com.tw/articles/10202839" target="_blank" rel="noopener">Day03 從Pandas到Geopandas的幾種方法 </a><br><a href="https://ithelp.ithome.com.tw/articles/10203180" target="_blank" rel="noopener">Day04 幾何資料基本運算 </a><br><a href="https://ithelp.ithome.com.tw/articles/10203391" target="_blank" rel="noopener">Day05 基本的資料聚合 </a><br><a href="https://ithelp.ithome.com.tw/articles/10203720" target="_blank" rel="noopener">Day06 其它資料聚合與geohash </a><br><a href="https://ithelp.ithome.com.tw/articles/10204209" target="_blank" rel="noopener">Day07 進階幾何資料處理 </a></p><p>簡易資料展示<br><a href="https://ithelp.ithome.com.tw/articles/10204536" target="_blank" rel="noopener">Day08 GIS資料基本繪圖 </a><br><a href="https://ithelp.ithome.com.tw/articles/10204839" target="_blank" rel="noopener">Day09 使用GeoPlot </a><br><a href="https://ithelp.ithome.com.tw/articles/10205182" target="_blank" rel="noopener">Day10 地圖互動folium </a><br><a href="https://ithelp.ithome.com.tw/articles/10205489" target="_blank" rel="noopener">Day11 台鐵意外事件與folium練習-前處理 </a><br><a href="https://ithelp.ithome.com.tw/articles/10205831" target="_blank" rel="noopener">Day12 台鐵意外事件與folium練習(續篇) </a><br><a href="https://ithelp.ithome.com.tw/articles/10206107" target="_blank" rel="noopener">Day13 台鐵意外事件與folium練習-繪圖 </a></p><blockquote><p>ps. 後來發現有邦友寫Folium30天，提了很多細節，只能推了<br>[使用Leaflet及Folium開啟網頁地圖大門 系列]<br>(<a href="https://ithelp.ithome.com.tw/users/20112552/ironman/2074" target="_blank" rel="noopener">https://ithelp.ithome.com.tw/users/20112552/ironman/2074</a>)<br>或是可以參考去年的鐵人賽<br><a href="https://ithelp.ithome.com.tw/users/20107816/ironman/1541" target="_blank" rel="noopener">30天打造我的WebGIS 系列</a></p></blockquote><p>基礎建設<br><a href="https://ithelp.ithome.com.tw/articles/10206275" target="_blank" rel="noopener">Day14 PostGIS的安裝 </a><br><a href="https://ithelp.ithome.com.tw/articles/10206732" target="_blank" rel="noopener">Day15 PostGIS與Geopandas </a><br><a href="https://ithelp.ithome.com.tw/articles/10207021" target="_blank" rel="noopener">Day16 WKT與PostGIS的運算 </a><br><a href="https://ithelp.ithome.com.tw/articles/10207289" target="_blank" rel="noopener">Day17 Geogig GIS版本控制 </a></p><p>交通與路網<br><a href="https://ithelp.ithome.com.tw/articles/10207559" target="_blank" rel="noopener">Day18 networkX與GIS資料初探 </a><br><a href="https://ithelp.ithome.com.tw/articles/10207749" target="_blank" rel="noopener">Day19 OSMnx取得OpenStreetMap資料 </a><br><a href="https://ithelp.ithome.com.tw/articles/10207981" target="_blank" rel="noopener">Day20 OSMnx應用 </a><br><a href="https://ithelp.ithome.com.tw/articles/10208239" target="_blank" rel="noopener">Day21 OSMnx應用(續篇) </a><br><a href="https://ithelp.ithome.com.tw/articles/10208846" target="_blank" rel="noopener">Day24 交通資料-國道ETC </a></p><p>資料的品質<br><a href="https://ithelp.ithome.com.tw/articles/10208453" target="_blank" rel="noopener">Day22 資料品質：幾何檢查 </a><br><a href="https://ithelp.ithome.com.tw/articles/10208645" target="_blank" rel="noopener">Day23 資料品質：幾何檢查(續篇) </a></p><p>網格與空間自相關<br><a href="https://ithelp.ithome.com.tw/articles/10209023" target="_blank" rel="noopener">Day25 用Owslib操作WMS </a><br><a href="https://ithelp.ithome.com.tw/articles/10209222" target="_blank" rel="noopener">Day26 網格資料的處理-Rasterio初探 </a><br><a href="https://ithelp.ithome.com.tw/articles/10209417" target="_blank" rel="noopener">Day 27 計算NDVI </a><br><a href="https://ithelp.ithome.com.tw/articles/10209595" target="_blank" rel="noopener">Day28 20米DEM資料處理 </a><br><a href="https://ithelp.ithome.com.tw/articles/10209784" target="_blank" rel="noopener">Day29 Pysal空間自相關 </a></p><h2 id="回顧"><a href="#回顧" class="headerlink" title="回顧"></a>回顧</h2><p>30天還有些想寫還沒寫(或寫不出來XD)，要說比較可惜的部分：</p><ul><li>特徵工程</li><li>交通運輸的GIS資料架構(試著寫怕太深但又怕搔不到癢處)</li><li>資料更新與維護</li><li>談QA與自動化(但隱含其中了)</li></ul><p>既然30天結束了，只好以後自己在找時間整理手邊工作與文獻。</p><h2 id="其它推薦的GIS工具"><a href="#其它推薦的GIS工具" class="headerlink" title="其它推薦的GIS工具"></a>其它推薦的GIS工具</h2><ul><li>QGIS<br>會來看這篇的人應該都知道QGIS，bj4，然而比起使用PyQGIS中，個人比較喜歡直接用GDAL等..(除非是開發plugin或是跟UI有關的)</li><li><a href="https://grass.osgeo.org/grass74/manuals/index.html" target="_blank" rel="noopener">GRASS</a><br>GRASS裡面實作許多經典的GIS演算法，在<code>QGIS</code>中也可以直接使用(GRASS也有Python Caller)</li><li>FME<br>FME是一套GIS工程好用的商業ETL工具，具有UI及強大的資料格式轉換引擎，許多(我)GIS工程師愛用每一天用。</li><li>ArcGIS<br>ArcGIS大受GIS使用者喜愛，擁有豐富的Toolbox，而最近也看到更多資料分析的功能(例如出了ipython的介面)</li></ul><h2 id="GIS-day"><a href="#GIS-day" class="headerlink" title="GIS day"></a>GIS day</h2><p>最後，看臉書得知今天是2018 GIS Day<br><a href="https://www.gisday.com/" target="_blank" rel="noopener">GIS Day November 14, 2018 - Discovering the World Through GIS</a></p><p>好像滿巧的，敬所有GIS工程師！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，宣傳一下我的團隊：&lt;a href=&quot;https://ithelp.ithome.com.tw/ironman/signup/team/44&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;這樣母Tom姆熊&lt;/a&gt;&lt;br&gt;這30天要不是硬拉了這些隊友，然後看他們一天天準時發文，可能會因為各種原因而寫不下去XD。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ithelp.ithome.com.tw/upload/images/20181114/20107816v4m4DXg8FC.png&quot; alt=&quot;https://ithelp.ithome.com.tw/upload/images/20181114/20107816v4m4DXg8FC.png&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://ithelp.ithome.com.tw/upload/images/20181114/201078160Ym2daNvAr.png&quot; alt=&quot;https://ithelp.ithome.com.tw/upload/images/20181114/201078160Ym2daNvAr.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day29 Pysal空間自相關</title>
    <link href="https://chimin17.github.io/2018/11/13/ironman-2019-day29/"/>
    <id>https://chimin17.github.io/2018/11/13/ironman-2019-day29/</id>
    <published>2018-11-13T15:30:36.000Z</published>
    <updated>2018-11-28T04:27:34.926Z</updated>
    
    <content type="html"><![CDATA[<p>Tobler地理學第一定律：all attribute values on a geographic surface are related to each other, but closer values are more strongly related than are more distant ones.</p><p><code>空間自相關</code>指的是空間單元的數據與其周遭空間單元的相似性，<br>今天我們以Pysal的說明頁面(<a href="http://darribas.org/gds_scipy16/ipynb_md/04_esda.html" target="_blank" rel="noopener">ESDA with PySAL</a>)為主軸，一步步進行與<code>空間自相關</code>相關的測試</p><a id="more"></a><p>大綱:</p><ul><li>spatial weight與attribute weight</li><li>全域空間自相關</li><li>區域空間自相關</li></ul><h2 id="spatial-weight與attribute-weight"><a href="#spatial-weight與attribute-weight" class="headerlink" title="spatial weight與attribute weight"></a>spatial weight與attribute weight</h2><p>最簡單的<code>spatial weight</code>可以<code>距離相關</code>為weight<br>以外，可以進一步用<code>相鄰性</code>計算spatial weight，常見包含Rook、Queen、Bishop等相鄰性<br>請參考<a href="http://darribas.org/gds_scipy16/ipynb_md/03_spatial_weights.html" target="_blank" rel="noopener">Pysal</a><br>還有其他如<code>核密度權重</code>等等</p><p>在計算之前，需要一些前處理<br>我們在第九天處理一個行政區路燈統計<br>今天進一步計算路燈<code>永和區</code>的路燈分佈密度(以里為單元)<br>看看是否有哪幾區特別亮：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import geopandas as gpd</span><br><span class="line">light=gpd.read_file(&apos;output/light.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">light=light[light.is_valid]</span><br><span class="line">light=light[light[&apos;district&apos;]==&apos;永和區&apos;]</span><br><span class="line">light.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; </span><br><span class="line">light=light.reset_index()</span><br><span class="line">village=gpd.read_file(&apos;data/village/village.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">village=village[village.is_valid]</span><br><span class="line">village=village[village[&apos;ADMIT&apos;]==&apos;永和區&apos;]</span><br><span class="line">village.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; </span><br><span class="line">village=village.reset_index()</span><br><span class="line">result=gpd.tools.sjoin(light[[&apos;geometry&apos;,&apos;district&apos;]], village[[&apos;ADMIV&apos;,&apos;ADMIT&apos;,&apos;geometry&apos;]], op=&apos;within&apos;,how=&quot;right&quot;)</span><br><span class="line">result[&apos;count&apos;]=1</span><br><span class="line">result=result.dissolve(by=&apos;ADMIV&apos;, aggfunc=&apos;sum&apos;)</span><br><span class="line">result[&apos;avg&apos;]=result[&apos;count&apos;]/result.area</span><br><span class="line">result</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181113/20107816Gd7bRaRbqi.png" alt="https://ithelp.ithome.com.tw/upload/images/20181113/20107816Gd7bRaRbqi.png"></p><p>經過以上計算，路燈密度欄位為<code>count</code><br>使用Pysal將<code>count</code>分成五個量級，並繪圖展示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cl = pysal.Quantiles(result[&apos;count&apos;], k=5)</span><br><span class="line">result.assign(cl=cl.yb).plot(&apos;cl&apos;, legend=True, categorical=True)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181113/20107816kvLMZ8BZUb.png" alt="https://ithelp.ithome.com.tw/upload/images/20181113/20107816kvLMZ8BZUb.png"></p><p>以上成果是原始的面量圖呈現</p><p>以下我們用Pysal計算spatial weight，採用<code>Queen</code>的相鄰性<br>如果要使用GeoDataFrame的話，可以透過libpysal<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wq =  libpysal.weights.Queen.from_dataframe(result)</span><br><span class="line">wq.transform = &apos;r&apos; #  row standardization</span><br></pre></td></tr></table></figure></p><p>有了spatial Weight，可以計算<code>spatial lag</code>空間間隔<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = result[&apos;count&apos;]</span><br><span class="line">ylag = libpysal.weights.lag_spatial(wq, y)</span><br></pre></td></tr></table></figure></p><p>一樣分成五個等級繪圖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cl = pysal.Quantiles(ylag, k=5)</span><br><span class="line">result.assign(cl=cl.yb).plot(&apos;cl&apos;, legend=True, cmap=&apos;GnBu&apos;, categorical=True)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181113/201078169Fcq3GQoI7.png" alt="https://ithelp.ithome.com.tw/upload/images/20181113/201078169Fcq3GQoI7.png"></p><blockquote><p>注意：不同的spatial weight會產生完全不同的結果，邦友可以自行測試</p></blockquote><p><code>spatial lag</code>的結果，我們以散布圖與原本的值比較(Moran Scatterplot)<br>看看是否合理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">y = result[&apos;count&apos;]</span><br><span class="line">b, a = np.polyfit(y, ylag, 1)</span><br><span class="line">f, ax = plt.subplots(1, figsize=(9, 9))</span><br><span class="line"></span><br><span class="line">plt.plot(y, ylag, &apos;.&apos;, color=&apos;firebrick&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.vlines(y.mean(), ylag.min(), ylag.max(), linestyle=&apos;--&apos;)</span><br><span class="line">plt.hlines(ylag.mean(), y.min(), y.max(), linestyle=&apos;--&apos;)</span><br><span class="line"></span><br><span class="line">plt.plot(y, a + b*y, &apos;r&apos;)</span><br><span class="line">plt.title(&apos;Moran Scatterplot&apos;)</span><br><span class="line">plt.ylabel(&apos;Spatial Lag of count&apos;)</span><br><span class="line">plt.xlabel(&apos;count&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181113/20107816JBzcmiVdEb.png" alt="https://ithelp.ithome.com.tw/upload/images/20181113/20107816JBzcmiVdEb.png"></p><h3 id="全域空間自相關"><a href="#全域空間自相關" class="headerlink" title="全域空間自相關"></a>全域空間自相關</h3><p>全域自相關的部分，在<code>Python</code>中可使用Pysal <code>esda</code>計算Moran’s I全域空間自相關</p><blockquote><p>Moran’s I的公式說明詳見<a href="http://desktop.arcgis.com/zh-cn/arcmap/10.3/tools/spatial-statistics-toolbox/h-how-spatial-autocorrelation-moran-s-i-spatial-st.htm" target="_blank" rel="noopener">說明</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import esda</span><br><span class="line">mi = esda.moran.Moran(y, wq)</span><br><span class="line">mi.I</span><br></pre></td></tr></table></figure><p>結果：<code>0.171730</code></p><p>全域Moran’s I的值在-1至1，接近1表示資料正相關，也就是有群聚性，接近-1則是越顯分散<br>此外，越接近0表示自相關程度不高(越不顯著)</p><blockquote><p>注意：不同的spatial weight會產生完全不同的結果，邦友可以自行測試</p></blockquote><h3 id="區域空間自相關"><a href="#區域空間自相關" class="headerlink" title="區域空間自相關"></a>區域空間自相關</h3><p>從上面的成果看來，可知永和區的路燈密，在空間上具有<code>不明顯</code>的<code>群聚的現象</code><br>(有偏袒，沒有特別偏袒)</p><p>接下來使用<code>esda</code>計算Moran區域型的空間自相關<br>看看哪邊特別<code>亮</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">li = esda.moran.Moran_Local(y, wq)</span><br><span class="line">li.q</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：不同的spatial weight會產生完全不同的結果，邦友可以自行測試</p></blockquote><p>繪圖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.assign(cl=li.q).plot(&apos;cl&apos;, legend=True, cmap=&apos;GnBu&apos;, categorical=True)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181113/20107816a15ZTDAKN4.png" alt="https://ithelp.ithome.com.tw/upload/images/20181113/20107816a15ZTDAKN4.png"></p><p><code>Local Moran’I</code>會算出1-4個等級，<br>在區域型的空間自相關的計算中，會進行假設檢定的統計測試，以測試所算之值顯不顯著</p><p>在範例中，設定通過0.05顯著水準的P測試<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sig = li.p_sim &lt; 0.05</span><br><span class="line">hotspot = 1 * (sig * li.q==1)</span><br><span class="line">coldspot = 3 * (sig * li.q==3)</span><br><span class="line">doughnut = 2 * (sig * li.q==2)</span><br><span class="line">diamond = 4 * (sig * li.q==4)</span><br><span class="line">spots = hotspot + coldspot + doughnut + diamond</span><br><span class="line"></span><br><span class="line">spot_labels = [ &apos;0 ns&apos;, &apos;1 hot spot&apos;, &apos;2 doughnut&apos;, &apos;3 cold spot&apos;, &apos;4 diamond&apos;]</span><br><span class="line">labels = [spot_labels[i] for i in spots]</span><br><span class="line">result.assign(cl=labels).plot(&apos;cl&apos;, legend=True, cmap=&apos;GnBu&apos;, categorical=True)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181114/20107816HBGWlyiQrP.png" alt="https://ithelp.ithome.com.tw/upload/images/20181114/20107816HBGWlyiQrP.png"></p><p>也可以獨立來看<br>hotspot：自相關高，正相關，通過設定的統計測試<br>也就是自己亮周遭也亮的區域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spots = [&apos;n.sig.&apos;, &apos;hotspot&apos;]</span><br><span class="line">labels = [spots[i] for i in hotspot*1]</span><br><span class="line">result.assign(cl=labels).plot(&apos;cl&apos;, legend=True, cmap=&apos;GnBu&apos;, categorical=True)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181113/20107816cKmnN01rdO.png" alt="https://ithelp.ithome.com.tw/upload/images/20181113/20107816cKmnN01rdO.png"></p><p>例如：所謂一支獨秀<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spots = [&apos;n.sig.&apos;, &apos;diamond&apos;]</span><br><span class="line">labels = [spots[i] for i in diamond*1]</span><br><span class="line">result.assign(cl=labels).plot(&apos;cl&apos;, legend=True, cmap=&apos;GnBu&apos;, categorical=True)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181113/20107816G2NpcEw9bu.png" alt="https://ithelp.ithome.com.tw/upload/images/20181113/20107816G2NpcEw9bu.png"></p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p>由於<code>空間自相關</code>的公式較多，在此篇幅無法一一表達清楚，僅能針對操作稍做測試<br>相關細節歡迎邦友參考：<br><a href="https://www.geog-daily.org/geogforum/14" target="_blank" rel="noopener">地理論壇 Geogforum - GEOGDAILY．地理眼</a><br><a href="http://desktop.arcgis.com/zh-cn/arcmap/10.3/tools/spatial-statistics-toolbox/h-how-spatial-autocorrelation-moran-s-i-spatial-st.htm" target="_blank" rel="noopener">Global Moran’s I| ArcGIS for Desktop</a><br><a href="http://darribas.org/gds_scipy16/ipynb_md/04_esda.html" target="_blank" rel="noopener">ESDA with PySAL</a><br><a href="https://github.com/pysal/esda" target="_blank" rel="noopener">GitHub - pysal/esda: statistics and classes for exploratory spatial data analysis</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tobler地理學第一定律：all attribute values on a geographic surface are related to each other, but closer values are more strongly related than are more distant ones.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;空間自相關&lt;/code&gt;指的是空間單元的數據與其周遭空間單元的相似性，&lt;br&gt;今天我們以Pysal的說明頁面(&lt;a href=&quot;http://darribas.org/gds_scipy16/ipynb_md/04_esda.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ESDA with PySAL&lt;/a&gt;)為主軸，一步步進行與&lt;code&gt;空間自相關&lt;/code&gt;相關的測試&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day28 20米DEM資料處理</title>
    <link href="https://chimin17.github.io/2018/11/12/ironman-2019-day28/"/>
    <id>https://chimin17.github.io/2018/11/12/ironman-2019-day28/</id>
    <published>2018-11-12T15:30:36.000Z</published>
    <updated>2018-11-28T04:27:31.951Z</updated>
    
    <content type="html"><![CDATA[<p>DEM(Digital Elevation Model)以二維網格的方式呈現地形，也是GIS資料常見得網格式資料，我們今天將會使用<a href="https://data.moi.gov.tw/MoiOD/Data/DataDetail.aspx?oid=84CF211B-4788-4FEF-B296-0F292C1DCBB8" target="_blank" rel="noopener">內政資料開放平臺</a>的20米全台DEM資料，他的副檔名是grd格式(ascii)，我們可以使用<code>Rasterio</code>讀取資料，並做一些處理。(ps.如果要使用全球的DEM，可以使用<a href="https://lta.cr.usgs.gov/SRTM1Arc" target="_blank" rel="noopener">SRTM</a>)</p><a id="more"></a><p>大綱:</p><ul><li>網格檔案GRD操作</li><li>暈渲圖(Hillshading) </li><li>坡度坡向</li></ul><h2 id="網格檔案GRD操作"><a href="#網格檔案GRD操作" class="headerlink" title="網格檔案GRD操作"></a>網格檔案GRD操作</h2><p>grd格式可以使用GDAL中讀取，當然<code>rasterio</code>也可以直接讀取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import rasterio</span><br><span class="line">src=rasterio.open(&apos;data/95191010dem.grd&apos;)</span><br><span class="line"></span><br><span class="line">import matplotlib.pyplot as pltfrom </span><br><span class="line">from rasterio import plot</span><br><span class="line">%matplotlib inline</span><br><span class="line">plot.show(src)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181112/20107816K4qFZL49ZR.png" alt="https://ithelp.ithome.com.tw/upload/images/20181112/20107816K4qFZL49ZR.png"></p><p>在資料處理方面，可以使用numpy以array方式處理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">height=src.read(1)  # 通常就是一個band</span><br><span class="line">height</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181112/20107816c3lSI4lY3A.png" alt="https://ithelp.ithome.com.tw/upload/images/20181112/20107816c3lSI4lY3A.png"></p><p>如果要轉格式，也可以把array另存成tif等格式<br>tif,png等等都可以是GIS網格資料的格式<br>(配合wordfile<a href="https://ithelp.ithome.com.tw/articles/10194831" target="_blank" rel="noopener">請參考[Day 14] WebGIS中的網格資料</a>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with rasterio.open(&apos;output/dem.tif&apos;, &apos;w&apos;, driver=&apos;GTiff&apos;, height=height.shape[0], width=height.shape[1], count=1, dtype=height.dtype) as dst:</span><br><span class="line">    dst.write(height, 1)</span><br></pre></td></tr></table></figure></p><h2 id="暈渲圖-Hillshading"><a href="#暈渲圖-Hillshading" class="headerlink" title="暈渲圖(Hillshading)"></a>暈渲圖(Hillshading)</h2><p>暈渲圖是地形資料常見的呈現方式，主要概念是將光源投射在地形上的時候，將光照區及陰影區一同呈現在圖上，常見於地質極大地測量等應用。</p><p>暈渲圖的計算，是假設源在某個方向和某個太陽高度下，賦予每個像元其周遭的像元的值計算而成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def hillshade(array, azimuth, angle_altitude):</span><br><span class="line"></span><br><span class="line">    # 取自: http://geoexamples.blogspot.com.br/2014/03/shaded-relief-images-using-gdal-python.html</span><br><span class="line"></span><br><span class="line">    x, y = np.gradient(array)</span><br><span class="line">    slope = np.pi/2. - np.arctan(np.sqrt(x*x + y*y))</span><br><span class="line">    aspect = np.arctan2(-x, y)</span><br><span class="line">    azimuth = azimuth*np.pi / 180.</span><br><span class="line">    altitude = angle_altitude*np.pi / 180.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    shade = np.sin(altitude) * np.sin(slope)  + np.cos(altitude) * np.cos(slope)   * np.cos(azimuth - aspect)</span><br><span class="line">    return 255*(shade + 1)/2</span><br></pre></td></tr></table></figure><p>計算太陽方向及入射角皆為30的暈渲圖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot.show(hillshade(height, 30, 30))</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181112/20107816aSloCrDU9O.png" alt="https://ithelp.ithome.com.tw/upload/images/20181112/20107816aSloCrDU9O.png"></p><p>換個角度可以看到，暈渲圖的效果不同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot.show(hillshade(height, 280, 25))</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181112/20107816WmmSZ89qxH.png" alt="https://ithelp.ithome.com.tw/upload/images/20181112/20107816WmmSZ89qxH.png"></p><p><code>關於暈渲圖計算可以參考以下的詳細說明&lt;https://hk.saowen.com/a/56273e57ea6fbfc59bffd030dd8a7e5741cf1d72ec4a2436dd027012ea8ff8ec&gt;</code></p><h2 id="坡度"><a href="#坡度" class="headerlink" title="坡度"></a>坡度</h2><p>坡度及坡向也是DEM常用的計算<br>坡度坡向的計算，可以使用numpy的計算<br>計算方式請參考<br><a href="http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-slope-works.htm" target="_blank" rel="noopener">How Slope works—Help | ArcGIS for Desktop</a></p><p>而下面則是直接使用GDAL的模組計算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import gdal</span><br><span class="line">import numpy as np</span><br><span class="line">import rasterio</span><br><span class="line"></span><br><span class="line"># 坡度</span><br><span class="line">gdal.DEMProcessing(&apos;output/slope.tif&apos;, &apos;data/95191010dem.grd&apos;, &apos;slope&apos;)</span><br><span class="line">with rasterio.open(&apos;output/slope.tif&apos;) as dataset:</span><br><span class="line">    slope=dataset.read(1)</span><br><span class="line"></span><br><span class="line"># 坡向</span><br><span class="line">gdal.DEMProcessing(&apos;output/aspect.tif&apos;, &apos;data/95191010dem.grd&apos;, &apos;aspect&apos;)</span><br><span class="line">with rasterio.open(&apos;output/aspect.tif&apos;) as dataset:</span><br><span class="line">    aspect=dataset.read(1)</span><br><span class="line">slope</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181112/20107816YbmMxTl9nT.png" alt="https://ithelp.ithome.com.tw/upload/images/20181112/20107816YbmMxTl9nT.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aspect</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181112/201078162ufZTyAfy3.png" alt="https://ithelp.ithome.com.tw/upload/images/20181112/201078162ufZTyAfy3.png"></p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="http://pangea.stanford.edu/~samuelj/musings/dems-in-python-pt-1-intro.html" target="_blank" rel="noopener">http://pangea.stanford.edu/~samuelj/musings/dems-in-python-pt-1-intro.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DEM(Digital Elevation Model)以二維網格的方式呈現地形，也是GIS資料常見得網格式資料，我們今天將會使用&lt;a href=&quot;https://data.moi.gov.tw/MoiOD/Data/DataDetail.aspx?oid=84CF211B-4788-4FEF-B296-0F292C1DCBB8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;內政資料開放平臺&lt;/a&gt;的20米全台DEM資料，他的副檔名是grd格式(ascii)，我們可以使用&lt;code&gt;Rasterio&lt;/code&gt;讀取資料，並做一些處理。(ps.如果要使用全球的DEM，可以使用&lt;a href=&quot;https://lta.cr.usgs.gov/SRTM1Arc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SRTM&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day27 計算NDVI</title>
    <link href="https://chimin17.github.io/2018/11/11/ironman-2019-day27/"/>
    <id>https://chimin17.github.io/2018/11/11/ironman-2019-day27/</id>
    <published>2018-11-11T15:30:36.000Z</published>
    <updated>2018-11-28T04:27:29.216Z</updated>
    
    <content type="html"><![CDATA[<p>昨天使用的Rasterio是一個方便的工具，它主要是包了一些GDAL等等的GIS套件，<br>使用GIS資料分析，當然一定會接觸到GDAL，<a href="https://www.gdal.org/" target="_blank" rel="noopener">GDAL Geospatial Data Abstraction Library</a>可以說是始祖，Rasterio建構於它之上讓資料分析更加方便。</p><p>持續Rasterio的主題，今天要測試的項目是NDVI。</p><a id="more"></a><p>大綱:</p><ul><li>NDVI</li><li>NDVI計算: rasterio, numpy</li></ul><h2 id="NDVI"><a href="#NDVI" class="headerlink" title="NDVI"></a>NDVI</h2><p>NDVI是常態化植生指標<a href="https://zh.wikipedia.org/wiki/%E5%B8%B8%E6%85%8B%E5%8C%96%E5%B7%AE%E5%80%BC%E6%A4%8D%E7%94%9F%E6%8C%87%E6%A8%99" target="_blank" rel="noopener">參考wiki常態化差值植生指標</a>，計算方式是利用紅光與近紅外光波段，代表植物生長與覆蓋的指數，其數值愈大表示植物生長愈多。<br>公式：<br><img src="https://ithelp.ithome.com.tw/upload/images/20181111/20107816tfuXryBeN2.png" alt="https://ithelp.ithome.com.tw/upload/images/20181111/20107816tfuXryBeN2.png"></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181111/20107816hPk2rvpANE.png" alt="https://ithelp.ithome.com.tw/upload/images/20181111/20107816hPk2rvpANE.png"></p><p>NIR為近紅外光反射；RED為紅光反射，NDVI之值介於-1到1之間。 當RED=0時，有最大值1；反之，當NIR=0時，有最小值-1。<br>(取自<a href="https://zh.wikipedia.org/wiki/%E5%B8%B8%E6%85%8B%E5%8C%96%E5%B7%AE%E5%80%BC%E6%A4%8D%E7%94%9F%E6%8C%87%E6%A8%99" target="_blank" rel="noopener">wiki常態化差值植生指標</a>與<a href="https://www.neonscience.org/calc-ndvi-py" target="_blank" rel="noopener">Calculate NDVI &amp; Extract Spectra Using Masks in Python - Flightline Data | NSF NEON | Open Data to Understand our Ecosystems</a>)</p><h2 id="NDVI計算-rasterio-numpy"><a href="#NDVI計算-rasterio-numpy" class="headerlink" title="NDVI計算: rasterio, numpy"></a>NDVI計算: rasterio, numpy</h2><p>讀取影像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import rasterio</span><br><span class="line">src=rasterio.open(&apos;data/rasterio/data/test.tif&apos;)</span><br></pre></td></tr></table></figure></p><p>然後，取得波段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b1, b2, b3, b4 = src.read()</span><br></pre></td></tr></table></figure></p><p>波段計算，我們使用numpy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy</span><br><span class="line">ndvi = numpy.zeros(b1.shape)</span><br><span class="line">ndvi = (b1-b2)/(b1+b2)</span><br></pre></td></tr></table></figure></p><p>展示成果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from rasterio import plot</span><br><span class="line">%matplotlib inline</span><br><span class="line">plot.show(ndvi)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181111/20107816zXs0MWveIK.png" alt="https://ithelp.ithome.com.tw/upload/images/20181111/20107816zXs0MWveIK.png"></p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>計算NDVI需要NIR為近紅外光反射的影像，如果需要影像可以使用USGS的Landsat影像：</p><p><a href="https://earthexplorer.usgs.gov/" target="_blank" rel="noopener">EarthExplorer - Home</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天使用的Rasterio是一個方便的工具，它主要是包了一些GDAL等等的GIS套件，&lt;br&gt;使用GIS資料分析，當然一定會接觸到GDAL，&lt;a href=&quot;https://www.gdal.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GDAL Geospatial Data Abstraction Library&lt;/a&gt;可以說是始祖，Rasterio建構於它之上讓資料分析更加方便。&lt;/p&gt;
&lt;p&gt;持續Rasterio的主題，今天要測試的項目是NDVI。&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day26 網格資料的處理-Rasterio初探</title>
    <link href="https://chimin17.github.io/2018/11/10/ironman-2019-day26/"/>
    <id>https://chimin17.github.io/2018/11/10/ironman-2019-day26/</id>
    <published>2018-11-10T15:10:31.000Z</published>
    <updated>2018-11-28T04:27:25.264Z</updated>
    
    <content type="html"><![CDATA[<p>網格資料處理跟主要指的是遙測影像的處理，Python影像處理有許多方便的工具，而今天使用的<code>Rasterio</code>比較針對遙測影像的常見的方法。</p><a id="more"></a><p>大綱:</p><ul><li>Rasterio I/O</li><li>影像波段操作</li></ul><h2 id="Rasterio-I-O"><a href="#Rasterio-I-O" class="headerlink" title="Rasterio I/O"></a>Rasterio I/O</h2><blockquote><p>安裝Rasterio<br><code>conda install -c conda-forge rasterio</code></p></blockquote><p><code>Rasterio</code>主要功能是遙測影像的處理<br>讀取影像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import rasterio</span><br><span class="line">src = rasterio.open(&quot;output/image.png&quot;)</span><br></pre></td></tr></table></figure></p><p>基本資訊<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(src.width, src.height) # 長寬</span><br><span class="line">print(src.crs) #crs</span><br><span class="line">print(src.indexes)</span><br></pre></td></tr></table></figure></p><p>回傳：<br><code>600 300None(1, 2, 3, 4)</code></p><p>顯示影像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from rasterio import plot</span><br><span class="line">plot.show(src)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181110/201078161MTaHTip92.png" alt="https://ithelp.ithome.com.tw/upload/images/20181110/201078161MTaHTip92.png"></p><h2 id="影像波段操作"><a href="#影像波段操作" class="headerlink" title="影像波段操作"></a>影像波段操作</h2><p>遙測影像會有多個波段，波段間的運算或融合是常常需要的</p><p>顯示波段數量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src.count</span><br></pre></td></tr></table></figure></p><p>回應：<code>4</code></p><p>顯示每個波段的型別<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src.dtypes</span><br></pre></td></tr></table></figure></p><p>回應：<code>(&#39;uint8&#39;, &#39;uint8&#39;, &#39;uint8&#39;, &#39;uint8&#39;)</code></p><p>顯示單一波段的影像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot.show((src, 1), cmap=&apos;Reds&apos;, title=&apos;channel1&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181110/20107816iV1A7tw8Td.png" alt="https://ithelp.ithome.com.tw/upload/images/20181110/20107816iV1A7tw8Td.png"></p><p>顯示波段的灰階統計資訊<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plot.show_hist(src, bins=50, lw=0.0, stacked=False, alpha=0.3, </span><br><span class="line">               histtype=&apos;stepfilled&apos;, title=&quot;Histogram&quot;)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181110/201078168uWjDN7XIm.png" alt="https://ithelp.ithome.com.tw/upload/images/20181110/201078168uWjDN7XIm.png"></p><p>波段操作的的部分，使用numpy<br>波段計算的範例，將影像波段融合(參考官網)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">b1,b2,b3,b4 = src.read()</span><br><span class="line">total = np.zeros(b1.shape)</span><br><span class="line">for band in b1, b2, b3,b4:</span><br><span class="line">    total += band</span><br><span class="line">total /= 4</span><br><span class="line"></span><br><span class="line">profile = src.profile</span><br><span class="line">profile.update(dtype=rasterio.uint8, count=1, compress=&apos;lzw&apos;)</span><br><span class="line"></span><br><span class="line">with rasterio.open(&apos;output/test-total.tif&apos;, &apos;w&apos;, **profile) as dst:</span><br><span class="line">    dst.write(total.astype(rasterio.uint8), 1)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181110/20107816XY6UaypY1P.png" alt="https://ithelp.ithome.com.tw/upload/images/20181110/20107816XY6UaypY1P.png"></p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p><code>rasterio</code>還有其他幾何資料操作的功能(例如·mask,polygonize等等)，有興趣的人可以去<a href="https://github.com/mapbox/rasterio" target="_blank" rel="noopener">官網</a>看看喔</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;網格資料處理跟主要指的是遙測影像的處理，Python影像處理有許多方便的工具，而今天使用的&lt;code&gt;Rasterio&lt;/code&gt;比較針對遙測影像的常見的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day25 用Owslib操作WMS</title>
    <link href="https://chimin17.github.io/2018/11/09/ironman-2019-day25/"/>
    <id>https://chimin17.github.io/2018/11/09/ironman-2019-day25/</id>
    <published>2018-11-09T13:30:36.000Z</published>
    <updated>2018-11-28T04:27:22.384Z</updated>
    
    <content type="html"><![CDATA[<p>今天要來介紹<code>owslib</code>，這個套件是python中拿來處理wms/wmts等服務的套件，<br>在<a href="https://matplotlib.org/basemap/api/basemap_api.html" target="_blank" rel="noopener">matplotlib basemap</a>也是使用這個套件，另外QGIS軟體中也有使用。</p><a id="more"></a><p>大綱：</p><ul><li>安裝</li><li>owslib初探</li><li>取得Layer資訊</li><li>GetMap</li></ul><h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><p>首先，安裝owslib的部分我們使用使用conda，打開cmd輸入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c conda-forge owslib</span><br></pre></td></tr></table></figure></p><h2 id="owslib初探"><a href="#owslib初探" class="headerlink" title="owslib初探"></a>owslib初探</h2><p>我們用owslib來呼叫一個wms</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from owslib.wms import WebMapService</span><br><span class="line">wms = WebMapService(&apos;https://webmap.ornl.gov/ogcbroker/wms&apos;, version=&apos;1.1.1&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>WMS介紹與說明: <a href="https://ithelp.ithome.com.tw/articles/10192948" target="_blank" rel="noopener">[Day 3] 談互操作性及Web Map Service 標準 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天</a></p><p>常用WMS清單: <a href="https://ithelp.ithome.com.tw/articles/10195607?sc=iThelpR" target="_blank" rel="noopener">[Day 15] wms,wmts資源彙整與OSM - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天</a></p></blockquote><p>wms服務中的圖層清單取得可以透過下列方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for item in list(wms.contents):</span><br><span class="line">    print(layer+&quot;:&quot;+wms[item].title)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181109/20107816WjKlbxAWXZ.png" alt="https://ithelp.ithome.com.tw/upload/images/20181109/20107816WjKlbxAWXZ.png"></p><h2 id="取得Layer資訊"><a href="#取得Layer資訊" class="headerlink" title="取得Layer資訊"></a>取得Layer資訊</h2><p>根據上面的圖層清單，我們先呼叫其中一個<code>1353_1</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer=wms[&apos;1353_1&apos;]</span><br></pre></td></tr></table></figure><p>從layer物件可以看看圖層的基本內容</p><p>例如：bbox範圍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.boundingBoxWGS84</span><br></pre></td></tr></table></figure></p><p>回應：<code>(-181.117, 57.0998, -138.538, 71.6062)</code></p><p>title<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.title</span><br></pre></td></tr></table></figure></p><p>回應：<code>&#39;Alaska Arctic AVHRR False-color Infrared Base Map&#39;</code></p><p>坐標系統<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.crsOptions</span><br></pre></td></tr></table></figure></p><p>回應：<code>[&#39;epsg:900913&#39;,&#39;epsg:4326&#39;,&#39;epsg:54004&#39;, &#39;epsg:3338&#39;, &#39;epsg:54008&#39;,&#39;epsg:3785&#39;,&#39;epsg:54009&#39;]</code></p><h2 id="GetMap"><a href="#GetMap" class="headerlink" title="GetMap"></a>GetMap</h2><p>GetMap是WMS規範中取得影像/網格資料的方法<br>在這邊的操作也是使用GetMap取得網格資料，<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img = wms.getmap(    </span><br><span class="line">      layers=[&apos;1353_1&apos;], </span><br><span class="line">      styles=[&apos;default&apos;], </span><br><span class="line">      srs=&apos;EPSG:4326&apos;, </span><br><span class="line">      bbox=(-181.117, 57.0998, -138.538, 71.6062), </span><br><span class="line">      size=(600, 300), </span><br><span class="line">      format=&apos;image/png&apos;, </span><br><span class="line">      transparent=True)</span><br></pre></td></tr></table></figure></p><p>取得影像後，可以把圖片存起來<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">out = open(&apos;image.png&apos;, &apos;wb&apos;)</span><br><span class="line">out.write(img.read())</span><br><span class="line">out.close()</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181109/201078167MK9ry3FqM.png" alt="https://ithelp.ithome.com.tw/upload/images/20181109/201078167MK9ry3FqM.png"><br>可以看到，影像被儲存了。</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>今天使用<code>owslib</code>取得WMS資料，預計接下來幾天會進入網格資料的GIS操作喔！</p><p>參考資料：<br><a href="https://webmap.ornl.gov/ogc/help/wms_script_python.html#section_examples" target="_blank" rel="noopener">SDAT Help: Use ORNL DAAC WMS Service in Python</a></p><p><a href="https://matplotlib.org/basemap/api/basemap_api.html" target="_blank" rel="noopener">matplotlib basemap toolkit</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天要來介紹&lt;code&gt;owslib&lt;/code&gt;，這個套件是python中拿來處理wms/wmts等服務的套件，&lt;br&gt;在&lt;a href=&quot;https://matplotlib.org/basemap/api/basemap_api.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;matplotlib basemap&lt;/a&gt;也是使用這個套件，另外QGIS軟體中也有使用。&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day24 交通資料-國道ETC</title>
    <link href="https://chimin17.github.io/2018/11/08/ironman-2019-day24/"/>
    <id>https://chimin17.github.io/2018/11/08/ironman-2019-day24/</id>
    <published>2018-11-08T15:30:36.000Z</published>
    <updated>2018-11-28T04:27:19.792Z</updated>
    
    <content type="html"><![CDATA[<p>今天試著來看看高速公路局ETC的資料。</p><p>交通與GIS的結合有許多應用，在實務上也有各種不同的議題，三言兩語也討論不完<br>既然討論不完就找一個資料來試試…</p><a id="more"></a><p>大綱:</p><ul><li>關於旅次資料</li><li>資料解析</li><li>門架資料</li><li>進休息站旅次</li></ul><h2 id="關於旅次資料"><a href="#關於旅次資料" class="headerlink" title="關於旅次資料"></a>關於旅次資料</h2><p>高速公路局提供了每小時ETC旅次流量等資料，<br>幾乎隔天就可以下載前一天的ETC資料，<a href="http://tisvcloud.freeway.gov.tw/" target="_blank" rel="noopener">下載請點這</a><br>我們下載的是<a href="http://tisvcloud.freeway.gov.tw/TISVCloud_web.files/TDCS_M06A.htm" target="_blank" rel="noopener">M06A</a>中的11/5 下午五點的資料做測試</p><p>M06A每一筆資料代表一個旅次，包含：(取自<a href="http://tisvcloud.freeway.gov.tw/TISVCloud_web.files/TDCS_M06A.htm" target="_blank" rel="noopener">M06A</a>)<br>VehicleType：車種，31小客車、32小貨車、41大客車、42大貨車、5聯結車。<br>DerectionTime_O：車輛通過本旅次第1個測站時間。<br>Gantry_O：車輛通過本旅次第1個測站編號。<br>DerectionTime_D：車輛通過本旅次最後1個測站時間。<br>Gantry_D：車輛通過本旅次最後1個測站編號。<br>TripLength：本旅次行駛距離。<br>TripEnd：旅次標記(Y正常結束，N異常)<br>TripInformation：本旅次經過各個測站之通過時間及編號。</p><h2 id="資料解析"><a href="#資料解析" class="headerlink" title="資料解析"></a>資料解析</h2><p>今天我們想看看11/5五點這份旅次資料經過<code>清水休息站</code>的可能旅次<br>首先我們先把資料讀起來<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">csv=pd.read_csv(fname, header=None, engine=&apos;python&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">csv.columns[&apos;VehicleType&apos;,&apos;DerectionTime_O&apos;,&apos;GantryID_O&apos;,&apos;DerectionTime_D&apos;,&apos;GantryID_D&apos;,&apos;TripLength&apos;,&apos;TripEnd&apos;,&apos;TripInformation&apos;]</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181108/20107816kRk2nOBh4p.png" alt="https://ithelp.ithome.com.tw/upload/images/20181108/20107816kRk2nOBh4p.png"></p><h2 id="門架資料"><a href="#門架資料" class="headerlink" title="門架資料"></a>門架資料</h2><p>接下來我們要知道清水休息站在哪，<br>我們下載國道門架資料<a href="https://data.gov.tw/dataset/21165" target="_blank" rel="noopener">國道計費門架座標及里程牌價表</a></p><p>打開QGIS並把圖層匯進去<br>找到清水休息站<br><img src="https://ithelp.ithome.com.tw/upload/images/20181108/20107816TG2gLlqcRX.png" alt="https://ithelp.ithome.com.tw/upload/images/20181108/20107816TG2gLlqcRX.png"></p><p>我們觀察清水交流道大致位於03F1710與03F1739兩個區間內<br>把它挑出來</p><p>利用正規表達式挑出<code>TripInformation</code>含有這門架的資料</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">service_go=[]</span><br><span class="line">for idx,row in  csv.iterrows():</span><br><span class="line">    if len(re.findall(&apos;03F1739&apos;,str(row[&apos;TripInformation&apos;])))&gt;0 or  len(re.findall(&apos;03F1710&apos;,str(row[&apos;TripInformation&apos;])))&gt;0:</span><br><span class="line">        service_go.append(row)</span><br><span class="line">df=pd.DataFrame(service_go)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181108/201078163j67Ycxt76.png" alt="https://ithelp.ithome.com.tw/upload/images/20181108/201078163j67Ycxt76.png"></p><h2 id="進休息站的旅次"><a href="#進休息站的旅次" class="headerlink" title="進休息站的旅次"></a>進休息站的旅次</h2><p>我們進一步將資料分為北上與南下，並取出<code>TripInformation</code>中經過03F1710與03F1739的時間<br>(有點醜見諒啦~~)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 03F1739 南方門架</span><br><span class="line"># 03F1710 北方門架</span><br><span class="line">for idx,row in df.iterrows():</span><br><span class="line">    trip=df.at[idx,&apos;TripInformation&apos;]</span><br><span class="line">    check_time=0</span><br><span class="line">    for triptime in trip.split(&apos;; &apos;):</span><br><span class="line">        if len(re.findall(&apos;03F1739&apos;,triptime))&gt;0:</span><br><span class="line">            df.at[idx,&apos;03F1739_t&apos;]=pd.Timestamp(triptime[:19])</span><br><span class="line">            check_time+=1   </span><br><span class="line">        if len(re.findall(&apos;03F1710&apos;,triptime))&gt;0:</span><br><span class="line">            df.at[idx,&apos;03F1710_t&apos;]=pd.Timestamp(triptime[:19])</span><br><span class="line">            check_time+=1</span><br><span class="line">        if check_time&gt;1:</span><br><span class="line">            if df.at[idx,&apos;03F1710_t&apos;]&gt;df.at[idx,&apos;03F1739_t&apos;]:</span><br><span class="line">                df.at[idx,&apos;direction&apos;]=&apos;S&apos;</span><br><span class="line">                df.at[idx,&apos;start&apos;] = df.at[idx,&apos;03F1739_t&apos;] </span><br><span class="line">                df.at[idx,&apos;end&apos;] = df.at[idx,&apos;03F1710_t&apos;] </span><br><span class="line">                df.at[idx,&apos;diff&apos;] = (df.at[idx,&apos;03F1710_t&apos;] - df.at[idx,&apos;03F1739_t&apos;])</span><br><span class="line">            else:</span><br><span class="line">                df.at[idx,&apos;direction&apos;]=&apos;N&apos;</span><br><span class="line">                df.at[idx,&apos;start&apos;] = df.at[idx,&apos;03F1710_t&apos;] </span><br><span class="line">                df.at[idx,&apos;end&apos;] = df.at[idx,&apos;03F1739_t&apos;] </span><br><span class="line">                df.at[idx,&apos;diff&apos;] = (df.at[idx,&apos;03F1739_t&apos;] - df.at[idx,&apos;03F1710_t&apos;])</span><br><span class="line">            break</span><br><span class="line">            </span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181108/20107816egBNLdtsl2.png" alt="https://ithelp.ithome.com.tw/upload/images/20181108/20107816egBNLdtsl2.png"></p><p>其中<code>direction</code>是南北向<br><code>start</code>經過休息站之前的門架時間<br><code>end</code>為遠離休息站後的門架時間<br><code>diff</code>為這兩段的時間</p><p>為了能繼續下去，只經過一次的我們就不算啦…<br>這邊假設經過這兩個門架的時間越長代表有進去休息站<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_new=df[df[&apos;start&apos;].notna()]</span><br><span class="line">df_new=df_new[df_new[&apos;end&apos;].notna()]</span><br><span class="line">df_new=df_new[df_new[&apos;diff&apos;].notna()]</span><br></pre></td></tr></table></figure></p><p>先排序觀察看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sorting</span><br><span class="line">df_new[df_new[&apos;direction&apos;].notna()].sort_values(&apos;diff&apos;,ascending=False).head()</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181108/20107816gPjRqLEaoz.png" alt="https://ithelp.ithome.com.tw/upload/images/20181108/20107816gPjRqLEaoz.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sorting</span><br><span class="line">df_new[df_new[&apos;direction&apos;].notna()].sort_values(&apos;diff&apos;,ascending=True).head()</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181108/20107816xuuf9S7qN1.png" alt="https://ithelp.ithome.com.tw/upload/images/20181108/20107816xuuf9S7qN1.png"></p><p>觀察後可能還不夠明顯，我們把時間尺度方到17-18時，並繪製散布圖</p><p>先做一些處理，把時間拆解，並把資料異常的刪除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">df_new[&apos;h&apos;]=df_new[&apos;start&apos;].dt.hour</span><br><span class="line">df_new[&apos;m&apos;]=df_new[&apos;start&apos;].dt.minute</span><br><span class="line">df_new[&apos;diff_s&apos;]=[pd.Timedelta.total_seconds(row[&apos;diff&apos;]) for idx, row in df_new.iterrows()]</span><br></pre></td></tr></table></figure></p><p>用散布圖呈現17-18時的資料，x軸是時間(分鐘)，y軸為經過這個區間的時間(單位是秒)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">df17=df_new[df_new[&apos;h&apos;]==17]</span><br><span class="line">df17.plot.scatter(x=&apos;m&apos;,y=&apos;diff_s&apos;,c=&apos;DarkBlue&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181108/20107816LZBDflxFr7.png" alt="https://ithelp.ithome.com.tw/upload/images/20181108/20107816LZBDflxFr7.png"></p><p>上面的成果可以看到大部分的車子經過的時間都差不多，明顯地離群值就是進站的車次<br>(我們可以用二階多項式擬合這些散佈點，並找出其除離群值，這邊就先跳過了直接手動給應門檻200秒)<br>綠色為進站，紅色為未進站<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax=df17[df17[&apos;diff_s&apos;]&gt;200].plot.scatter(x=&apos;m&apos;,y=&apos;diff_s&apos;,c=&apos;green&apos;)</span><br><span class="line">df17[df17[&apos;diff_s&apos;]&lt;=200].plot.scatter(x=&apos;m&apos;,y=&apos;diff_s&apos;,c=&apos;red&apos;,ax=ax)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181108/20107816UHgGrXR42F.png" alt="https://ithelp.ithome.com.tw/upload/images/20181108/20107816UHgGrXR42F.png"></p><p>ps.今天只拿11/06 17時開始偵測到的旅次，正式計算應該把整天的旅次都讀進來分析喔！</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>今天只是簡單試試高速公路ETC資料<br>個人認為台灣國道的交通資料是相對單純的，幾乎是單一線路<br>交通資訊的發布可能是點狀(車禍)的或線狀和面狀的(塞車，封路)，<br>為了將資訊映射到路網或是地圖上，有一些問題需要探討<br>有機會再分享與討論囉！</p><p>參考資料<br><a href="https://github.com/tomtom-international/openlr-js" target="_blank" rel="noopener">https://github.com/tomtom-international/openlr-js</a><br><a href="http://openlr.itinero.tech/?code=CwKhciRM1yMoLP6KBAUjcyEE" target="_blank" rel="noopener">http://openlr.itinero.tech/?code=CwKhciRM1yMoLP6KBAUjcyEE</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天試著來看看高速公路局ETC的資料。&lt;/p&gt;
&lt;p&gt;交通與GIS的結合有許多應用，在實務上也有各種不同的議題，三言兩語也討論不完&lt;br&gt;既然討論不完就找一個資料來試試…&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day23 資料品質：幾何檢查(續篇)</title>
    <link href="https://chimin17.github.io/2018/11/07/ironman-2019-day23/"/>
    <id>https://chimin17.github.io/2018/11/07/ironman-2019-day23/</id>
    <published>2018-11-07T15:30:36.000Z</published>
    <updated>2018-11-28T04:27:17.189Z</updated>
    
    <content type="html"><![CDATA[<p>今天繼續GIS的幾何檢查的部分，主要處理的是polygon的接邊問題，這是一種常見的topology的問題。</p><a id="more"></a><p>大綱: </p><ul><li>gap and sliver polygon</li><li>檢查方法</li><li>修正</li></ul><h2 id="gap-and-sliver-polygon"><a href="#gap-and-sliver-polygon" class="headerlink" title="gap and sliver polygon"></a>gap and sliver polygon</h2><p>兩個相接的polygon可能因為繪製的錯誤，或是浮點數的位數問題，造成邊界些微的不吻合(shp檔沒有儲存topology)，可能有兩種情況，第一種是中間有縫隙(gap)，第二種則是中間有一些重疊(sliver)。</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181107/20107816SzAZQoYlpv.png" alt="https://ithelp.ithome.com.tw/upload/images/20181107/20107816SzAZQoYlpv.png"><br><img src="https://ithelp.ithome.com.tw/upload/images/20181107/20107816Fc64O9SC1P.png" alt="https://ithelp.ithome.com.tw/upload/images/20181107/20107816Fc64O9SC1P.png"></p><h2 id="檢查方法"><a href="#檢查方法" class="headerlink" title="檢查方法"></a>檢查方法</h2><p>為了測試，我自行畫了一個範例：<br><img src="https://ithelp.ithome.com.tw/upload/images/20181107/20107816euXaTBcYPC.png" alt="https://ithelp.ithome.com.tw/upload/images/20181107/20107816euXaTBcYPC.png"></p><p>總共有三個Polygon，紅色部分highlight起來凸顯邊界問題，另外一個Polygon則是分開的</p><p>要檢查是否有因邊界不吻合所造成gap或sliver，<br>最簡單的方法，可以將polygon組為multyPolygon，利用shapely的is_valid檢查：</p><blockquote><p>A valid MultiPolygon may not collect any overlapping polygons.  — Shapely</p></blockquote><p>用Geopandas讀自己畫的Polygon<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import geopandas as gpd</span><br><span class="line">from shapely.geometry import MultiPolygon, Polygon</span><br><span class="line">test=gpd.read_file(&apos;data/test.shp&apos;,encoding=&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181107/20107816a5xCXg1QjZ.png" alt="https://ithelp.ithome.com.tw/upload/images/20181107/20107816a5xCXg1QjZ.png"></p><p>將polygon丟進去multypolygon</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from shapely.geometry import MultiPolygon, Polygon</span><br><span class="line">data=[]</span><br><span class="line">for i in range(len(test.geometry)):</span><br><span class="line">    data.append(test[&apos;geometry&apos;][i])</span><br><span class="line">mp = MultiPolygon(data)</span><br><span class="line">mp_obj = gpd.GeoSeries(mp)</span><br><span class="line">mp_obj.is_valid</span><br></pre></td></tr></table></figure><p>回傳:<code>False</code><br>由於很明顯有不一致的現象，所以回傳是False</p><h2 id="修正"><a href="#修正" class="headerlink" title="修正"></a>修正</h2><p>確定這分資料有邊界的問題後，接下來是修正<br>昨天提到，修正最好還是在GIS軟體中編修介面中操作，<br>但我們可以試著將要修正的區塊找出來</p><p>首先可以使用unary_union將聯集的部分合併<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">union = test.geometry.unary_union</span><br><span class="line">union</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181107/20107816nbMLpVpqm6.png" alt="https://ithelp.ithome.com.tw/upload/images/20181107/20107816nbMLpVpqm6.png"></p><p>結果由三個polygon被合併為兩個<br>1號polygon是被合併的部分，我們試著找出邊界不一致的區塊<br>可以例用<code>difference</code>跟<code>intersection</code>的運算找出gap或sliver</p><p>找gap:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># gap</span><br><span class="line">gap = list(union)[1]  # </span><br><span class="line">gap=gap.difference(test[&apos;geometry&apos;][2]).difference(test[&apos;geometry&apos;][1])</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181107/20107816orUuH7zKCb.png" alt="https://ithelp.ithome.com.tw/upload/images/20181107/20107816orUuH7zKCb.png"></p><p>找sliver<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sliver</span><br><span class="line">sliver=test[&apos;geometry&apos;][2].intersection(test[&apos;geometry&apos;][1])</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181107/20107816cWR4bVRJxM.png" alt="https://ithelp.ithome.com.tw/upload/images/20181107/20107816cWR4bVRJxM.png"></p><p>把成果疊一起示意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ax=mp_obj.plot()</span><br><span class="line">gap_obj = gpd.GeoSeries(gap)</span><br><span class="line">sliver_obj = gpd.GeoSeries(sliver)</span><br><span class="line">ax=gap_obj.plot(ax=ax,color=&apos;yellow&apos;)</span><br><span class="line">sliver_obj.plot(ax=ax,color=&apos;red&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181107/20107816BIYcx2Ldzr.png" alt="https://ithelp.ithome.com.tw/upload/images/20181107/20107816BIYcx2Ldzr.png"></p><p>找出gap及sliver的區塊以後，建議回到QGIS加以編修，利用正確的數化工具將錯誤修正。<br>個人認為找出錯誤的部分比自動修正還要重要，<br>因為自動修正時編號1號的區塊很難程式化的決定要採取左邊或右邊的邊界，<br>有時候會遇到硬條件或是其他因素，自動化會比較瑣碎<br>(工人智慧?XD)</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>幾何資料的正確性對資料品質影響很大，錯誤的資料在幾何運算也會有問題<br>今天的案例是一個測試，跟幾何有關的情況還有一些，有機會再來研究。</p><p>參考資料<br><a href="https://gis.stackexchange.com/questions/277334/shapely-polygon-union-results-in-strange-artifacts-of-tiny-non-overlapping-area" target="_blank" rel="noopener">https://gis.stackexchange.com/questions/277334/shapely-polygon-union-results-in-strange-artifacts-of-tiny-non-overlapping-area</a><br><a href="https://www.gislounge.com/digitizing-errors-in-gis/" target="_blank" rel="noopener">https://www.gislounge.com/digitizing-errors-in-gis/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天繼續GIS的幾何檢查的部分，主要處理的是polygon的接邊問題，這是一種常見的topology的問題。&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day22 資料品質：幾何檢查</title>
    <link href="https://chimin17.github.io/2018/11/06/ironman-2019-day22/"/>
    <id>https://chimin17.github.io/2018/11/06/ironman-2019-day22/</id>
    <published>2018-11-06T14:30:36.000Z</published>
    <updated>2018-11-28T04:27:14.134Z</updated>
    
    <content type="html"><![CDATA[<p>GIS生產的過程中，在向量幾何資料部分有一些常用的位向關係檢查，這些檢查的品質指標在ArcGIS或是QGIS中都有各自的模組，例如商用軟體<code>ArcGIS</code>的<code>topology</code>系列模組(e.g. <code>Creating a topology</code>)。</p><a id="more"></a><p>大綱：</p><ul><li>check geometry</li><li>自相交</li><li>重複的節點</li><li>多邊形小於三個節點或面積長度過小</li></ul><h2 id="check-geometry"><a href="#check-geometry" class="headerlink" title="check geometry"></a>check geometry</h2><p>在QGIS部分，個人使用過<a href="https://docs.qgis.org/2.14/en/docs/user_manual/plugins/plugins_geometry_checker.html" target="_blank" rel="noopener">check geometry</a>這個模組，他可以解決大部分的需求，它包含了許多在處理GIS資料時需檢查的幾何特性，主要操作方法是在QGIS投入shp，其提供一個互動介面，可以在UI上修正(也支援自動修正)這些問題。</p><p>以下是一些檢查項目的示意圖：<br><img src="https://ithelp.ithome.com.tw/upload/images/20181106/20107816jOoYDMP68b.png" alt="https://ithelp.ithome.com.tw/upload/images/20181106/20107816jOoYDMP68b.png"><br><img src="https://ithelp.ithome.com.tw/upload/images/20181106/20107816xdoAn3pDZo.png" alt="https://ithelp.ithome.com.tw/upload/images/20181106/20107816xdoAn3pDZo.png"><br><a href="https://docs.qgis.org/2.14/en/docs/user_manual/plugins/plugins_geometry_checker.html" target="_blank" rel="noopener">取自QGIS Geometry Checker Plugin</a></p><p>有些問題很明顯是數化上的失誤或是演算法處理所造成的不合理現象，應加以排除。</p><p>今天就以QGIS check geometry這個plug-in提供的一些功能，這個plug-in的指標包含了主要的位相關係檢查，這幾個指標可作為資料ETL的品質指標，今天來看看如何在<code>python</code>做這些檢查。</p><blockquote><p>找到問題後，建議回到QGIS手動編修，某些品質問題採用全自動的編修是危險的。</p></blockquote><h2 id="自相交"><a href="#自相交" class="headerlink" title="自相交"></a>自相交</h2><p>polygon的自相交應是不被允許的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from shapely.geometry import Polygon</span><br><span class="line">pp = Polygon([(0, 0), (1, 1), (1, -1), (0, 1)])</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181106/20107816N1wJhx0J1U.png" alt="https://ithelp.ithome.com.tw/upload/images/20181106/20107816N1wJhx0J1U.png"></p><p>檢查自相交的方法，可以用shapely的<code>is_valid</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pp.is_valid</span><br></pre></td></tr></table></figure></p><p>回傳：<code>False</code></p><blockquote><p>shapely: A valid Polygon may not possess any overlapping exterior or interior rings. </p></blockquote><p>或是另一種方法<br>把節點轉成lineString,記得把最後一點補上以完成封閉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from shapely.geometry import LineString</span><br><span class="line">ls=LineString(data[:]+data[0:1])</span><br><span class="line">ls</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181106/201078161j6svkHpW0.png" alt="https://ithelp.ithome.com.tw/upload/images/20181106/201078161j6svkHpW0.png"></p><p>使用unary_union，回傳會得到MultiLineString<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from shapely.ops import unary_union</span><br><span class="line">mls = unary_union(ls) </span><br><span class="line">mls.geom_type # MultiLineString&apos;</span><br></pre></td></tr></table></figure></p><p>使用polygonize，將其分開<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from shapely.ops import polygonize </span><br><span class="line">for polygon in polygonize(mls): </span><br><span class="line">    print(polygon)</span><br></pre></td></tr></table></figure></p><p>回傳</p><blockquote><p>POLYGON ((0.333 0.333, 0 0, 0 1, 0.333 0.333))<br>POLYGON ((0.333 0.333 0.333 0.333, 1 1, 1 -1, 0.333 0.333 0.333 0.333))</p></blockquote><p>偵測到自相交的多邊形後，可能有兩種處理方式，一種是刪除其中一個（數化錯誤），一種是分離，而上面已經提供了分離的方法。</p><p>若要刪除，可進一步將分離的兩部分計算其面積，太小的則可能是錯誤：</p><p>計算面積(shapely)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">polygon.area</span><br></pre></td></tr></table></figure></p><p>數化錯誤產生的自相交，例如</p><p>(乍看問題不大)<br><img src="https://ithelp.ithome.com.tw/upload/images/20181106/201078165FS42bhoEg.png" alt="https://ithelp.ithome.com.tw/upload/images/20181106/201078165FS42bhoEg.png"><br>(放大來看)<br><img src="https://ithelp.ithome.com.tw/upload/images/20181106/20107816nA4YkoVyO6.png" alt="https://ithelp.ithome.com.tw/upload/images/20181106/20107816nA4YkoVyO6.png"></p><h2 id="重複的節點"><a href="#重複的節點" class="headerlink" title="重複的節點"></a>重複的節點</h2><p>在polyline(lineString)或polygon重複的節點當然是不被允許的，以下我們故意重複一個節點</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data2=[(0, 0), (1, 1),(1,1),(2,3),(0,2)]</span><br><span class="line">pp2 = Polygon(data2)</span><br><span class="line">pp2</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181106/20107816u27NOKh925.png" alt="https://ithelp.ithome.com.tw/upload/images/20181106/20107816u27NOKh925.png"></p><p>要檢查這個問題，可以簡單的遍歷節點確認<br>或是使用以下方法直接將重複的點刪除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(list(pp2.simplify(0).exterior.coords))</span><br></pre></td></tr></table></figure></p><p>回傳：<code>[(0.0, 0.0), (1.0, 1.0), (2.0, 3.0), (0.0, 2.0), (0.0, 0.0)]</code></p><h2 id="多邊形小於三個節點或面積長度過小"><a href="#多邊形小於三個節點或面積長度過小" class="headerlink" title="多邊形小於三個節點或面積長度過小"></a>多邊形小於三個節點或面積長度過小</h2><p>多邊形一定要至少三個節點，否則是錯誤的，而面積大小也會是過濾或品質檢查的指標。</p><p>用shapely new一個polygon，兩個節點是不允損的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data=[(0, 0),(0,2)]</span><br><span class="line">pp = Polygon(data3)</span><br><span class="line">pp ### A LinearRing must have at least 3 coordinate tuples</span><br></pre></td></tr></table></figure></p><p>polyhon面積不一定是檢查的項目，但可以避免錯誤<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data=[(0, 0),(1,1),(2,3),(0,2)]</span><br><span class="line">pp2= Polygon(data)</span><br><span class="line">pp.area # if smaller than xxx</span><br></pre></td></tr></table></figure></p><p>而多邊形中有一些特別小的點，除了可以每條edge檢查外，也可以使用shapely的simplify簡化以減少不必要的儲存量<br>simplify有兩種方法，preserve_topology=True僅檢查距離，如果preserve_topology=False則會使用Douglas-Peucker演算法，可以更簡化資料但是可能會有一些變形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data=[(0, 0),(0.002, 0.006), (1, 1),(1,1),(2,3),(0,2)]</span><br><span class="line">pp = Polygon(data)</span><br><span class="line">print(list(pp.simplify(0.1, ).exterior.coords))</span><br></pre></td></tr></table></figure></p><p>回傳:<code>[(0.0, 0.0), (1.0, 1.0), (2.0, 3.0), (0.0, 2.0), (0.0, 0.0)]</code></p><p>如果調成0.002，則這點被保留<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(list(pp3.simplify(0.002).exterior.coords))</span><br></pre></td></tr></table></figure></p><p>回傳：<code>[(0.0, 0.0), (0.002, 0.006), (1.0, 1.0), (2.0, 3.0), (0.0, 2.0), (0.0, 0.0)]</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GIS生產的過程中，在向量幾何資料部分有一些常用的位向關係檢查，這些檢查的品質指標在ArcGIS或是QGIS中都有各自的模組，例如商用軟體&lt;code&gt;ArcGIS&lt;/code&gt;的&lt;code&gt;topology&lt;/code&gt;系列模組(e.g. &lt;code&gt;Creating a topology&lt;/code&gt;)。&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day21 OSMnx應用(續篇)</title>
    <link href="https://chimin17.github.io/2018/11/05/ironman-2019-day21/"/>
    <id>https://chimin17.github.io/2018/11/05/ironman-2019-day21/</id>
    <published>2018-11-05T12:30:36.000Z</published>
    <updated>2018-11-28T04:27:11.139Z</updated>
    
    <content type="html"><![CDATA[<p>昨天我們主要應用OSM的路網資料，除了路網，OSMnx還有其他的資料可以使用，今天就繼續OSMnx吧！</p><a id="more"></a><p>大綱：</p><ul><li>building</li><li>街道方向角</li></ul><h2 id="building"><a href="#building" class="headerlink" title="building"></a>building</h2><p>OSMnx有一個buidling模組，跟路網一樣，他可以把OSM上的建物輪廓資料取下，取下來的資料是GeoDataFrame</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b=ox.buildings.buildings_from_point((25.048545,121.51123), 300, retain_invalid=False)</span><br><span class="line">b</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181105/20107816qJaf5ZbYgW.png" alt="https://ithelp.ithome.com.tw/upload/images/20181105/20107816qJaf5ZbYgW.png"><br>building可以直接繪圖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ox.buildings.plot_buildings(b)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181105/20107816NTJMUoMbmc.png" alt="https://ithelp.ithome.com.tw/upload/images/20181105/20107816NTJMUoMbmc.png"></p><p>繪圖的部分，還可以加入一些效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">point = (25.048545,121.51123)</span><br><span class="line">dist = 300</span><br><span class="line">gdf = ox.buildings_from_point(point=point, distance=dist)</span><br><span class="line">gdf_proj = ox.project_gdf(gdf)</span><br><span class="line">bbox = ox.bbox_from_point(point=point, distance=dist, project_utm=True)</span><br><span class="line">ox.plot_buildings(gdf_proj, bgcolor=&apos;#333333&apos;, color=&apos;w&apos;, figsize=(4,4), bbox=bbox, close=True)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181105/20107816R4s1H8uIBK.png" alt="https://ithelp.ithome.com.tw/upload/images/20181105/20107816R4s1H8uIBK.png"></p><p>下面網站有一些世界各國城市的某些角落，有興趣的人可以看看！<br><a href="https://geoffboeing.com/2017/04/urban-form-analysis-openstreetmap/" target="_blank" rel="noopener">Urban Form Analysis with OpenStreetMap Data - Geoff Boeing</a></p><h2 id="街道方向角"><a href="#街道方向角" class="headerlink" title="街道方向角"></a>街道方向角</h2><p>OSMnx有提供一個計算街道方向角的範例，使用<code>add_edge_bearings</code>，而方向角的值域是0-360度，官網也提供一個圖表範例，看起來滿有fu的。</p><p>我們就以台北火車站為中心，方圓1.5km，大概就是古台北城的範圍來做範例吧！</p><p>台北火車站的坐標大概是<code>25.048545,121.51123</code>，取得資料<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">G = ox.graph_from_point((25.048545,121.51123), distance=1500, network_type=&apos;drive&apos;)</span><br><span class="line">fig, ax = ox.plot_graph(ox.project_graph(G), node_size=0)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181105/20107816KzcQiTB79J.png" alt="https://ithelp.ithome.com.tw/upload/images/20181105/20107816KzcQiTB79J.png"></p><p>計算方向角add edge bearings:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G = ox.add_edge_bearings(G)</span><br></pre></td></tr></table></figure></p><p>把方向角整理一下，bar chart<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bearings = pd.Series([data[&apos;bearing&apos;] for u, v, k, data in G.edges(keys=True, data=True)])</span><br><span class="line">ax = bearings.hist(bins=30, zorder=2, alpha=0.8)</span><br><span class="line">xlim = ax.set_xlim(0, 360)</span><br><span class="line">ax.set_title(&apos;bearning&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181105/20107816VegBOoGXsH.png" alt="https://ithelp.ithome.com.tw/upload/images/20181105/20107816VegBOoGXsH.png"></p><p>以雷達圖繪圖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">n = 30</span><br><span class="line">bins = [ang * 360 / n for ang in range(0, n + 1)]</span><br><span class="line">count, division = np.histogram(bearings, bins=bins, range=(bearings.min(), bearings.max()))</span><br><span class="line">division = division[0:-1]</span><br><span class="line">width =  2 * np.pi/n</span><br><span class="line">ax = plt.subplot(111, projection=&apos;polar&apos;)</span><br><span class="line">ax.set_theta_zero_location(&apos;N&apos;)</span><br><span class="line">ax.set_theta_direction(&apos;clockwise&apos;)</span><br><span class="line">bars = ax.bar(division * np.pi/180 - width * 0.5 , count, width=width, bottom=20.0)</span><br><span class="line">ax.set_title(&apos;street network edge bearings&apos;, y=1.1)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181105/20107816erpFbC3Axc.png" alt="https://ithelp.ithome.com.tw/upload/images/20181105/20107816erpFbC3Axc.png"></p><p>(台北市應該算滿正的)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天我們主要應用OSM的路網資料，除了路網，OSMnx還有其他的資料可以使用，今天就繼續OSMnx吧！&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day20 OSMnx應用</title>
    <link href="https://chimin17.github.io/2018/11/04/ironman-2019-day20/"/>
    <id>https://chimin17.github.io/2018/11/04/ironman-2019-day20/</id>
    <published>2018-11-04T14:30:36.000Z</published>
    <updated>2018-11-28T04:27:08.286Z</updated>
    
    <content type="html"><![CDATA[<p>OSMnx除了介接了Overpass API，可以透過python方便的取得OpenStreetMap的圖資以外，它還提供了一些路網相關的分析方法，這些方法主要是來自networkX。</p><a id="more"></a><p>大綱:</p><ul><li>計算最短路徑</li><li>服務範圍、等時圈</li></ul><h2 id="計算最短路徑"><a href="#計算最短路徑" class="headerlink" title="計算最短路徑"></a>計算最短路徑</h2><p>計算最短路徑跟<code>前兩天</code>測試的是networkX差不多的:</p><p>首先，先取得資料<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import osmnx as ox</span><br><span class="line">G = ox.graph_from_point((25.048545,121.51123), distance=3000, network_type=&apos;drive&apos;)</span><br><span class="line">ox.plot_graph(G)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181104/201078165AMVlwogBT.png" alt="https://ithelp.ithome.com.tw/upload/images/20181104/201078165AMVlwogBT.png"></p><p>接著我們給定原點跟目的地的坐標，然後計算其node的編號，使用的是<code>ox.get_nearest_node</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin = ox.get_nearest_node(G, (25.049545,121.5599))</span><br><span class="line">destination = ox.get_nearest_node(G, (25.048545,121.51123))</span><br></pre></td></tr></table></figure></p><p>要計算最短路徑，用的是networkx的<code>shortest_path()</code>方法，把剛剛的origin與destination輸入並繪圖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import networkx as nx</span><br><span class="line">route = nx.shortest_path(G, origin, destination)</span><br><span class="line">ox.plot_graph_route(G, route)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181104/201078161ZDflqcBtY.png" alt="https://ithelp.ithome.com.tw/upload/images/20181104/201078161ZDflqcBtY.png"></p><h2 id="服務範圍、等時圈"><a href="#服務範圍、等時圈" class="headerlink" title="服務範圍、等時圈"></a>服務範圍、等時圈</h2><p>除了最短路徑分析以外，<br>等時圈也是路網分析的經典演算法，透過路網可以算出以某點為中心點，特定時間內可以抵達的範圍：</p><p>首先，我們先取得資料(跟上面一樣)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import osmnx as ox</span><br><span class="line">G = ox.graph_from_point((25.048545,121.51123), distance=2000, network_type=&apos;drive&apos;)</span><br><span class="line">ox.plot_graph(G)</span><br><span class="line">G = ox.project_graph(G) # 投影</span><br></pre></td></tr></table></figure></p><p>接著，以下方法取得中心點node<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">center_node = ox.get_nearest_node(G, (25.048545,121.51123))</span><br></pre></td></tr></table></figure></p><p>給予每個edge<code>速度</code>，單位是每分鐘的公尺數<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meters_per_minute = 10 * 1000 / 60 # 每小時10公里</span><br><span class="line">for u, v, k, data in G.edges(data=True, keys=True):</span><br><span class="line">    data[&apos;time&apos;] = data[&apos;length&apos;] / meters_per_minute</span><br></pre></td></tr></table></figure></p><p>官網提供的範例是利用networkx的<code>ego_graph</code>，ego_graph會回傳一個graph中心點一定範圍的節點子graph，運算的單位可以是edge的weight等等，這邊範例是使用time（所以要配合上面先提供每個edge’time’），詳請請看networkx官方文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import networkx as nx</span><br><span class="line">trip_times = [5, 8, 12] #分鐘</span><br><span class="line"># 給定顏色</span><br><span class="line">iso_colors = ox.get_colors(n=len(trip_times), cmap=&apos;Reds&apos;, start=0.3, return_hex=True)</span><br><span class="line">node_colors = &#123;&#125;</span><br><span class="line">for trip_time, color in zip(sorted(trip_times, reverse=True), iso_colors):</span><br><span class="line">    subgraph = nx.ego_graph(G, center_node, radius=trip_time, distance=&apos;time&apos;)</span><br><span class="line">    for node in subgraph.nodes():</span><br><span class="line">        node_colors[node] = color # 抵達的node給顏色</span><br></pre></td></tr></table></figure></p><p>根據上面抵達的node邊界，再給一次範圍內的顏色，並畫圖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc = [node_colors[node] if node in node_colors else &apos;none&apos; for node in G.nodes()]</span><br><span class="line">ns = [20 if node in node_colors else 0 for node in G.nodes()]</span><br><span class="line">fig, ax = ox.plot_graph(G, fig_height=8, node_color=nc, node_size=ns, node_alpha=0.8, node_zorder=2)</span><br></pre></td></tr></table></figure></p><p>成果:<br><img src="https://ithelp.ithome.com.tw/upload/images/20181104/20107816ZkaXMC0jLW.png" alt="https://ithelp.ithome.com.tw/upload/images/20181104/20107816ZkaXMC0jLW.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OSMnx除了介接了Overpass API，可以透過python方便的取得OpenStreetMap的圖資以外，它還提供了一些路網相關的分析方法，這些方法主要是來自networkX。&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day19 OSMnx取得OpenStreetMap資料</title>
    <link href="https://chimin17.github.io/2018/11/03/ironman-2019-day19/"/>
    <id>https://chimin17.github.io/2018/11/03/ironman-2019-day19/</id>
    <published>2018-11-03T14:30:36.000Z</published>
    <updated>2018-11-28T04:27:04.571Z</updated>
    
    <content type="html"><![CDATA[<p>昨天簡單介紹了<code>networkX</code>，我們可以透過把路網polyline轉為node,edge的graph(<code>s2g</code>)來做graph相關操作，例如最短路徑等等。</p><p><code>OSMnx</code>也是相關的應用，OSMnx結合了<code>Overpass API</code>，讓開發者可以在python中快速取得OpenStreetMap的資料，在路網圖層中，其與<code>networkX</code>結合可進行一些grpah的分析操作。<br>ps.除了路網外，OSMnx也可取得其他OpenStreetMap的圖層喔</p><a id="more"></a><p>大綱：</p><ul><li>安裝OSMnx</li><li>取得路網</li><li>輸出路網</li></ul><h2 id="安裝OSMnx"><a href="#安裝OSMnx" class="headerlink" title="安裝OSMnx"></a>安裝OSMnx</h2><p>OSMnx建議使用conda安裝<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c conda-forge osmnx</span><br></pre></td></tr></table></figure></p><p>如果使用pip安裝目前可能會遇到一些問題，<br>建議開一個乾淨的的virtual environment再來安裝</p><h2 id="取得路網"><a href="#取得路網" class="headerlink" title="取得路網"></a>取得路網</h2><p>OSMnx取得OSM的來源是<code>Overpass API</code>，得到資料後會對OSM資料做處理，變成node+edge的graph<br>給定一個坐標<code>(25.0528108,121.6137452)</code>後，設定一個範圍<code>(distance=750)</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import osmnx as ox</span><br><span class="line">G = ox.graph_from_point((25.0528108,121.6137452), distance=750, network_type=&apos;drive&apos;)</span><br><span class="line">ox.plot_graph(G)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181103/20107816aJc3ZQkTBw.png" alt="https://ithelp.ithome.com.tw/upload/images/20181103/20107816aJc3ZQkTBw.png"></p><blockquote><p>osmnx還有其他query的方法，包括輸入city name, bounding box及address等等，</p></blockquote><p>列出edge，並是以坐標表示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G.edges</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181103/20107816wtOK23KcsU.png" alt="https://ithelp.ithome.com.tw/upload/images/20181103/20107816wtOK23KcsU.png"></p><p>當然也可以看到node的列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G.nodes</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181103/20107816I8TMJ7RT7D.png" alt="https://ithelp.ithome.com.tw/upload/images/20181103/20107816I8TMJ7RT7D.png"></p><h2 id="輸出路網"><a href="#輸出路網" class="headerlink" title="輸出路網"></a>輸出路網</h2><p>osmnx可以把組成的graph成果輸出，graph的組成是edge跟node</p><p>把edge跟node輸出可做其他用途<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">G_proj = ox.project_gdf(G)</span><br><span class="line">ox.save_graph_shapefile(G_projected, filename=&apos;network-shape&apos;)</span><br></pre></td></tr></table></figure></p><p>上面的輸出為edge以及node的shp<br>另一種可行的輸出格式GraphML()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ox.save_graphml(G_projected, filename=&apos;network.graphml&apos;)</span><br></pre></td></tr></table></figure></p><blockquote><p>有關GraphML<br><a href="http://graphml.graphdrawing.org/" target="_blank" rel="noopener">The GraphML File Format</a></p></blockquote><p>OSMnx很方便地讓我們取得路網資料(以及其他OpenStreetMap資料)，<br>對於GIS分析人員來說，不怕手邊沒資料啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天簡單介紹了&lt;code&gt;networkX&lt;/code&gt;，我們可以透過把路網polyline轉為node,edge的graph(&lt;code&gt;s2g&lt;/code&gt;)來做graph相關操作，例如最短路徑等等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OSMnx&lt;/code&gt;也是相關的應用，OSMnx結合了&lt;code&gt;Overpass API&lt;/code&gt;，讓開發者可以在python中快速取得OpenStreetMap的資料，在路網圖層中，其與&lt;code&gt;networkX&lt;/code&gt;結合可進行一些grpah的分析操作。&lt;br&gt;ps.除了路網外，OSMnx也可取得其他OpenStreetMap的圖層喔&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day18 networkX與GIS資料初探</title>
    <link href="https://chimin17.github.io/2018/11/02/ironman-2019-day18/"/>
    <id>https://chimin17.github.io/2018/11/02/ironman-2019-day18/</id>
    <published>2018-11-02T15:30:31.000Z</published>
    <updated>2018-11-28T04:27:00.702Z</updated>
    
    <content type="html"><![CDATA[<p>今天要來寫GIS與路網相關的(當然只要跟graph有關的都可以使用，例如管線)一些應用。</p><p>在GIS及LBS應用中少不了路徑規劃，這些路網資料的應用路主要基於graph，<code>networkX</code>可以用來建立及操作graph的工具，它可以產生各種garph，也包含了很多graph演算法。</p><a id="more"></a><p>大綱：</p><ul><li>路網圖資</li><li>建立garph</li><li>graph操作</li></ul><h2 id="路網圖資"><a href="#路網圖資" class="headerlink" title="路網圖資"></a>路網圖資</h2><p>路網系統有很多應用，今天將使用<a href="http://gishub.taichung.gov.tw/" target="_blank" rel="noopener">台中市數位地圖館</a>的台中市路網資料來做測試。</p><h2 id="建立garph"><a href="#建立garph" class="headerlink" title="建立garph"></a>建立garph</h2><p><code>networkX</code>有支援將shp格式的node與edge轉為garph，然而我們原始拿到的路網資料並無node，需要拆解，這邊我們簡單使用一套s2g(shape2graph)的工具(產生無向圖)</p><p>我們先切一小塊來看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import geopandas as gpd</span><br><span class="line">road = gpd.read_file(&apos;data/Road/road.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">road</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181102/20107816FzJWNwNOSf.png" alt="https://ithelp.ithome.com.tw/upload/images/20181102/20107816FzJWNwNOSf.png"><br><img src="https://ithelp.ithome.com.tw/upload/images/20181102/20107816RbHZfdagR9.png" alt="https://ithelp.ithome.com.tw/upload/images/20181102/20107816RbHZfdagR9.png"></p><p>這邊發現這份路網是linestring Z，我們先把它轉為linestring，並轉坐標系統<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from shapely.geometry import shape,LineString,Point</span><br><span class="line">geoms =road[&apos;geometry&apos;]</span><br><span class="line"></span><br><span class="line">geoms = [LineString([xy[0:2] for xy in list(geom.coords)])  for geom in geoms]</span><br><span class="line">road[&apos;geometry&apos;]=geoms</span><br><span class="line">road.to_file(&apos;data/Road/road2.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">road</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181103/201078169rjwa8h5NI.png" alt="https://ithelp.ithome.com.tw/upload/images/20181103/201078169rjwa8h5NI.png"></p><p>確認為linestring後，<br>使用sg ShapeGraph 把shp丟進去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from s2g import ShapeGraph</span><br><span class="line">import networkx as nx</span><br><span class="line"></span><br><span class="line">sg = ShapeGraph(shapefile=&apos;data/Road/road2.shp&apos;, to_graph=True)</span><br><span class="line">g_nw = sg.to_networkx()</span><br></pre></td></tr></table></figure></p><p>s2g產生要計算一段時間，產生下列訊息<br><img src="https://ithelp.ithome.com.tw/upload/images/20181102/20107816jNiCyeYKUa.png" alt="https://ithelp.ithome.com.tw/upload/images/20181102/20107816jNiCyeYKUa.png"><br>拿到的g_nw就是networkX的graph格式</p><h2 id="graph操作"><a href="#graph操作" class="headerlink" title="graph操作"></a>graph操作</h2><p>graph可以算node間的最短路徑，使用`shortest_path’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nearest_path= nx.shortest_path(graph, source=start_id, target=end_id)</span><br></pre></td></tr></table></figure></p><p>其中input的是node的id<br>這邊我們先用sg物件內存的節點來手動給<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sg.node_xy</span><br></pre></td></tr></table></figure></p><p>我們先手動給start_id=1, end_id=30</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nearest_path= nx.shortest_path(g_nw, source=5, target=19)</span><br><span class="line">nearest_path</span><br></pre></td></tr></table></figure><p>回傳結果：<code>[5, 11, 14, 3, 18, 19]</code></p><p>繪圖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">base=road.plot()</span><br><span class="line">geoms=[]</span><br><span class="line">for item in nearest_path:</span><br><span class="line">    geoms.append(sg.node_xy[item])</span><br><span class="line"></span><br><span class="line">train_lines = gpd.GeoDataFrame(crs= &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125;,geometry=[LineString(geoms)])</span><br><span class="line">train_lines.plot(ax=base,color=&apos;red&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181103/20107816SntOGemFm2.png" alt="https://ithelp.ithome.com.tw/upload/images/20181103/20107816SntOGemFm2.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天要來寫GIS與路網相關的(當然只要跟graph有關的都可以使用，例如管線)一些應用。&lt;/p&gt;
&lt;p&gt;在GIS及LBS應用中少不了路徑規劃，這些路網資料的應用路主要基於graph，&lt;code&gt;networkX&lt;/code&gt;可以用來建立及操作graph的工具，它可以產生各種garph，也包含了很多graph演算法。&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day17 Geogig GIS版本控制</title>
    <link href="https://chimin17.github.io/2018/11/01/ironman-2019-day17/"/>
    <id>https://chimin17.github.io/2018/11/01/ironman-2019-day17/</id>
    <published>2018-11-01T13:59:49.000Z</published>
    <updated>2018-11-28T04:26:57.004Z</updated>
    
    <content type="html"><![CDATA[<p>今天的主題與Python較於無關，這陣子遇到資料版本控制的需求，有搜尋並測試了一下<code>geogig</code>這個軟體，在此稍微紀錄一下。</p><p><code>geogig</code>是個開源專案，使用JAVA開發並以BSD授權，主要目的是做GIS資料的版本控制，整個操作經驗與<code>git</code>類似，支援的GIS資料包含<code>shapefile</code>、<code>PostGIS</code>、<code>SpatiaLite</code>等，對每一次commit的GIS追蹤管理，也可對資料開分支、遠端分支等等功能。</p><p>今天就記錄一下比較基本的步驟。</p><a id="more"></a><h3 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h3><p>Geogig官網以包好exe，前往官網下載<br><a href="http://geogig.org/#install" target="_blank" rel="noopener">GeoGig by LocationTech</a></p><p>解壓縮到<code>D:\</code>後，把路徑加入<code>系統環境變數</code>中<br><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816ZpA7vOTKYw.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816ZpA7vOTKYw.png"></p><p>我們測試一下，打開cmd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816eeZKSoSSFH.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816eeZKSoSSFH.png"></p><p>設定好路徑並有反應了，我們可以開始操作Geogig了</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化一個repo，這邊的初始化跟git一樣：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig init</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816dFbuNcWgzo.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816dFbuNcWgzo.png"></p><p>我們把rail.shp加入一個commit，在這之前要先用<code>shp import</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig shp import rail.shp -d rail</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816t4swAL4Khq.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816t4swAL4Khq.png"></p><p>上面的import跟一般git比等於是多一步，import之後可以add，這個動作跟<code>git add .</code>一樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig add</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/2010781607eqR3FT2S.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/2010781607eqR3FT2S.png"></p><p>然後，就可以commit了，這邊的commit跟git也是一樣的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig commit -m &quot;init&quot;</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816SIvZ7BhaLV.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816SIvZ7BhaLV.png"></p><blockquote><p>這邊操作的時候跳了一個錯，因為第一次操作時，Geogig會要求輸入user config，跟git一樣，如果遇到就這步驟設定就好了<br><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816o0W9mwq8HQ.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816o0W9mwq8HQ.png"></p></blockquote><p>成功操作<br><img src="https://ithelp.ithome.com.tw/upload/images/20181101/201078162awtAJfyOk.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/201078162awtAJfyOk.png"></p><h4 id="如果要update資料"><a href="#如果要update資料" class="headerlink" title="如果要update資料"></a>如果要update資料</h4><p>我們進入<code>QGIS</code>給資料一些異動，<br>我們直接修改資料的屬性(修改數筆DEFINITION)<br><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816DS6120zyr4.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816DS6120zyr4.png"></p><p>要再提供一次commit 要把<code>shp import</code>跟<code>add</code> 在操作一次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig shp import rail.shp -d rail</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816Z0N6bHF8M6.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816Z0N6bHF8M6.png"></p><p>add，這邊可以看到一些異動資訊<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig add</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816CwndjHznwy.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816CwndjHznwy.png"></p><p>commit，然後第二個版本的資料就被記錄上去了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig commit -m &quot;second round&quot;</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816Mdho2Be8Ne.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816Mdho2Be8Ne.png"><br>從上可以看到版本間的異動</p><h3 id="基本資訊"><a href="#基本資訊" class="headerlink" title="基本資訊"></a>基本資訊</h3><p>接下來來看看repo與commit的資訊</p><p>觀看repo內容用<code>ls</code><br>看到目前的repo中的資料集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig ls</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816gy7HGRq5Bm.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816gy7HGRq5Bm.png"></p><p><code>log</code> 看版本的歷史過程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig log</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/201078161GJXrFm6mZ.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/201078161GJXrFm6mZ.png"></p><h3 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h3><p>Geogig在QGIS與Geoserver有外掛可以使用，今天先以git的觀點進行基本操作，有興趣者可操作看看！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的主題與Python較於無關，這陣子遇到資料版本控制的需求，有搜尋並測試了一下&lt;code&gt;geogig&lt;/code&gt;這個軟體，在此稍微紀錄一下。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;geogig&lt;/code&gt;是個開源專案，使用JAVA開發並以BSD授權，主要目的是做GIS資料的版本控制，整個操作經驗與&lt;code&gt;git&lt;/code&gt;類似，支援的GIS資料包含&lt;code&gt;shapefile&lt;/code&gt;、&lt;code&gt;PostGIS&lt;/code&gt;、&lt;code&gt;SpatiaLite&lt;/code&gt;等，對每一次commit的GIS追蹤管理，也可對資料開分支、遠端分支等等功能。&lt;/p&gt;
&lt;p&gt;今天就記錄一下比較基本的步驟。&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day16 WKT與PostGIS的運算</title>
    <link href="https://chimin17.github.io/2018/10/31/ironman-2019-day16/"/>
    <id>https://chimin17.github.io/2018/10/31/ironman-2019-day16/</id>
    <published>2018-10-31T14:02:39.000Z</published>
    <updated>2018-11-28T04:26:50.629Z</updated>
    
    <content type="html"><![CDATA[<p>在昨天的文章中，我們要把資料倒入PostGIS前，需要使用geoalchemy2把坐標資料轉成<code>WKT element</code>，今天來理解一下WKT</p><h3 id="WKT"><a href="#WKT" class="headerlink" title="WKT"></a>WKT</h3><p>WKT的全寫是(Well Known Text)，是OGC SFS（Simple Features Interface Standard）對於資料庫中GIS資料的架構定義，全文可從<a href="http://www.opengeospatial.org/standards/sfa" target="_blank" rel="noopener">連結</a>下載，另外SQL語法對於GIS處理的定義，也是在這份文件中定義，大多數GIS資料庫都有提供SFS的基本定義及功能。</p><p>有關SFS的幾何類型參考下圖：<br><img src="https://ithelp.ithome.com.tw/upload/images/20181031/20107816auFnhEeYJX.png" alt="https://ithelp.ithome.com.tw/upload/images/20181031/20107816auFnhEeYJX.png"><br>(取自<a href="http://www.opengeospatial.org/standards/sfa" target="_blank" rel="noopener">OGC</a>)</p><a id="more"></a><p>WKT是以文字方式表達幾何，以下從網站上擷取一些類型(取自<a href="https://en.wikipedia.org/wiki/Well-known_text" target="_blank" rel="noopener">WIKI</a>)<br><img src="https://ithelp.ithome.com.tw/upload/images/20181031/20107816yTOer2h25Y.png" alt="https://ithelp.ithome.com.tw/upload/images/20181031/20107816yTOer2h25Y.png"></p><h3 id="WKB"><a href="#WKB" class="headerlink" title="WKB"></a>WKB</h3><p>WKB(Well Known Binary)顧名思義就是將WKT加以binary編碼，[<a href="https://blog.csdn.net/yaoxiaochuang/article/details/53117693" target="_blank" rel="noopener">1</a>]有對於WKB位數儲存有一些說明，而WKB主要是讓WKT更加緊湊。</p><h3 id="WKT與GeoDataFrame"><a href="#WKT與GeoDataFrame" class="headerlink" title="WKT與GeoDataFrame"></a>WKT與GeoDataFrame</h3><p>PostGIS的空間屬性是根據OGC SFS，<br>前幾天有提到Geopandas的空間資料是使用shapely的定義，昨天的範例主要是透過<a href="https://geoalchemy-2.readthedocs.io/en/latest/" target="_blank" rel="noopener">geoalchemy2</a>將shapely的geometry轉為PostGIS的geometry，以方便幾何資料的ORM<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from geoalchemy2 import Geometry, WKTElement</span><br><span class="line">gdf=gpd.read_file(&apos;data/Rail/Rail.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">gdf[&apos;geom&apos;] = gdf[&apos;geometry&apos;].apply(lambda x: WKTElement(x.wkt, srid=3826))</span><br><span class="line">gdf.drop(&apos;geometry&apos;, 1, inplace=True)</span><br><span class="line">type(gdf.at[0,&apos;geom&apos;] )</span><br></pre></td></tr></table></figure></p><p>結果為<code>geoalchemy2.elements.WKTElement</code></p><p>to_sql<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy import create_engine</span><br><span class="line">engine = create_engine(&apos;postgresql://postgres:postgres@localhost:5432/public&apos;)</span><br><span class="line">gdf.to_sql(&apos;rail&apos;, engine, if_exists=&apos;replace&apos;, index=False, schema=&apos;public&apos;</span><br><span class="line">           ,dtype=&#123;&apos;geom&apos;: Geometry(&apos;LINESTRING&apos;, srid= 3826)&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="PostGIS"><a href="#PostGIS" class="headerlink" title="PostGIS"></a>PostGIS</h3><p>OGC SFS有定義幾何運算的實踐，在PostGIS可以進行操作，大致包含了<br><img src="https://ithelp.ithome.com.tw/upload/images/20181031/20107816tdHE4yn5MT.png" alt="https://ithelp.ithome.com.tw/upload/images/20181031/20107816tdHE4yn5MT.png"><br>(取自<a href="http://www.opengeospatial.org/standards/sfa" target="_blank" rel="noopener">OGC</a>)</p><p>我們把SQL語法執行並直接用GeoDataFrame接，例如我們要對每一個線段做buffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql=&apos;select ST_buffer(rail.geom,0.0001) as geometry from public.rail &apos;</span><br><span class="line">df = gpd.GeoDataFrame.from_postgis(sql, engine, geom_col=&apos;geometry&apos; )</span><br><span class="line">df</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181031/20107816kajGxaeFtb.png" alt="https://ithelp.ithome.com.tw/upload/images/20181031/20107816kajGxaeFtb.png"></p><p>而其他的幾何操作，可以參考<a href="https://postgis.net/docs/reference.html" target="_blank" rel="noopener">PostGIS Reference</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在昨天的文章中，我們要把資料倒入PostGIS前，需要使用geoalchemy2把坐標資料轉成&lt;code&gt;WKT element&lt;/code&gt;，今天來理解一下WKT&lt;/p&gt;
&lt;h3 id=&quot;WKT&quot;&gt;&lt;a href=&quot;#WKT&quot; class=&quot;headerlink&quot; title=&quot;WKT&quot;&gt;&lt;/a&gt;WKT&lt;/h3&gt;&lt;p&gt;WKT的全寫是(Well Known Text)，是OGC SFS（Simple Features Interface Standard）對於資料庫中GIS資料的架構定義，全文可從&lt;a href=&quot;http://www.opengeospatial.org/standards/sfa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;連結&lt;/a&gt;下載，另外SQL語法對於GIS處理的定義，也是在這份文件中定義，大多數GIS資料庫都有提供SFS的基本定義及功能。&lt;/p&gt;
&lt;p&gt;有關SFS的幾何類型參考下圖：&lt;br&gt;&lt;img src=&quot;https://ithelp.ithome.com.tw/upload/images/20181031/20107816auFnhEeYJX.png&quot; alt=&quot;https://ithelp.ithome.com.tw/upload/images/20181031/20107816auFnhEeYJX.png&quot;&gt;&lt;br&gt;(取自&lt;a href=&quot;http://www.opengeospatial.org/standards/sfa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OGC&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day15 PostGIS與Geopandas</title>
    <link href="https://chimin17.github.io/2018/10/30/ironman-2019-day15/"/>
    <id>https://chimin17.github.io/2018/10/30/ironman-2019-day15/</id>
    <published>2018-10-30T13:20:40.000Z</published>
    <updated>2018-11-28T04:26:51.736Z</updated>
    
    <content type="html"><![CDATA[<p>昨天安裝完了PostGIS，<br>今天我們就在GeoPandas做資料讀寫，<br>另外QGIS對於PostGIS支援度也很高，把資料匯入後，也可以使用QGIS對資料做讀寫。</p><blockquote><p>ps. 安裝完PostGIS，我們需要在DB中啟用<br>若未啟用postgis安裝完後在pgAdmin4或是psql輸入<br>postgres=# CREATE EXTENSION postgis;</p></blockquote><a id="more"></a><p>為了用PostGIS讀寫資料<br>我們使用data/Rail/Rail.shp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import geopandas as gpd</span><br><span class="line"></span><br><span class="line">rail=gpd.read_file(&apos;data/Rail/Rail.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">rail.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; </span><br><span class="line">rail=rail.to_crs(epsg=4326)</span><br><span class="line">rail.head()</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181030/20107816SLrMqcJL0F.png" alt="https://ithelp.ithome.com.tw/upload/images/20181030/20107816SLrMqcJL0F.png"><br><img src="https://ithelp.ithome.com.tw/upload/images/20181030/20107816A9eW0TsvlS.png" alt="https://ithelp.ithome.com.tw/upload/images/20181030/20107816A9eW0TsvlS.png"><br>在GeoPandas，可以使用sqlalchemy建立資料庫連線的instance，對資料庫IO</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy import create_engine</span><br><span class="line">engine = create_engine(&apos;postgresql://postgres:postgres@localhost:5432/postgres&apos;)</span><br></pre></td></tr></table></figure><p>接著，使用to_sql這個方法，其中呢必須把geometry包成wkt element，由於一般使用geom作為PostGIS的空間屬性，這邊也一並處理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from geoalchemy2 import Geometry, WKTElement</span><br><span class="line">rail[&apos;geom&apos;] = rail[&apos;geometry&apos;].apply(lambda x: WKTElement(x.wkt, srid=4326))</span><br><span class="line">rail.drop(&apos;geometry&apos;, 1, inplace=True)</span><br></pre></td></tr></table></figure></p><p>在to_sql的時候要設定連線實體、dtype(空間資料的坐標系統及幾何類型，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rail.to_sql(&apos;rail&apos;, engine, if_exists=&apos;replace&apos;, index=False, schema=&apos;public&apos;,</span><br><span class="line">           dtype=&#123;&apos;geom&apos;: Geometry(&apos;LINESTRING&apos;, srid= 4326)&#125;)</span><br></pre></td></tr></table></figure></p><p>如果是其他的型別如，Point或Polygon，記得要修改</p><p>資料進PostGIS後，可以使用QGIS瀏覽、處理資料，有時需要編輯幾何資料的時候，使用QGIS很方便，熟悉QGIS的邦友可以使用DB Manager對PostGIS做操作<br><img src="https://ithelp.ithome.com.tw/upload/images/20181030/20107816kzOS2GxW7Z.png" alt="https://ithelp.ithome.com.tw/upload/images/20181030/20107816kzOS2GxW7Z.png"><br><img src="https://ithelp.ithome.com.tw/upload/images/20181030/20107816Jna9KThbm8.png" alt="https://ithelp.ithome.com.tw/upload/images/20181030/20107816Jna9KThbm8.png"></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181030/20107816c2Kdm92utv.png" alt="https://ithelp.ithome.com.tw/upload/images/20181030/20107816c2Kdm92utv.png"></p><p>而剛剛的資料也可以在讀回Geopandas</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql=&apos;select * from public.rail &apos;</span><br><span class="line">df = gpd.GeoDataFrame.from_postgis(sql, engine, geom_col=&apos;geom&apos; )</span><br><span class="line">df</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181030/201078168t7lrmhqJZ.png" alt="https://ithelp.ithome.com.tw/upload/images/20181030/201078168t7lrmhqJZ.png"><br>使用資料庫是資料處理及資料分析不可或缺的一環，在空間資料庫中，PostGIS非常方便，建議大家使用！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天安裝完了PostGIS，&lt;br&gt;今天我們就在GeoPandas做資料讀寫，&lt;br&gt;另外QGIS對於PostGIS支援度也很高，把資料匯入後，也可以使用QGIS對資料做讀寫。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ps. 安裝完PostGIS，我們需要在DB中啟用&lt;br&gt;若未啟用postgis安裝完後在pgAdmin4或是psql輸入&lt;br&gt;postgres=# CREATE EXTENSION postgis;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day14 PostGIS的安裝</title>
    <link href="https://chimin17.github.io/2018/10/29/ironman-2019-day14/"/>
    <id>https://chimin17.github.io/2018/10/29/ironman-2019-day14/</id>
    <published>2018-10-29T15:11:22.000Z</published>
    <updated>2018-11-28T04:09:41.221Z</updated>
    
    <content type="html"><![CDATA[<p>PostGIS是<code>PostgreSQL</code>對於OpenGIS空間資料規範的擴充，</p><p>目前各大家資料庫對GIS資料都有支援及擴充</p><p>不過就以易用性來說，開源軟體<code>QGIS</code>對於PostGIS的支援度很高，而<code>Geopandas</code>對於PostGIS的支援也十分友善。</p><p>因此，十分建議常使用GIS資料的人安裝PostGIS在本機進行操作。</p><p>今天我們來執行單機版PostGIS的安裝(使用windows)</p><a id="more"></a><p>首先到<a href="https://www.enterprisedb.com/software-downloads-postgres" target="_blank" rel="noopener">EnterpriseDB Software Downloads | EnterpriseDB</a>下載PostgreSQL安裝檔<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816KOjCaGjq7C.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816KOjCaGjq7C.png"></p><p>打開安裝檔，開始安裝PostgreSQL<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816XRxLFuRfWw.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816XRxLFuRfWw.png"></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816aZv1zfyknE.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816aZv1zfyknE.png"></p><p>選擇要安裝的元件，為了安裝PostGIS，請把Stack Builder要打勾<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816IzzzxlSBjO.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816IzzzxlSBjO.png"></p><p>接下來選擇資料庫的路徑<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816RhTWuuBAmf.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816RhTWuuBAmf.png"></p><p>設定資料庫的密碼，輸入後請記得<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/201078167sSI8HXnbJ.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/201078167sSI8HXnbJ.png"></p><p>port設定(預設即可)<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816H3JdKLWvo7.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816H3JdKLWvo7.png"></p><p>地區<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816U80z5Pevzm.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816U80z5Pevzm.png"></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181029/201078169iyuKsIIsb.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/201078169iyuKsIIsb.png"></p><p>然後就開始安裝<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816BmqvmCDMR8.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816BmqvmCDMR8.png"></p><p>以上，完成了PostgreSQL 的安裝</p><p>接下來要安裝PostGIS<br>打開<code>Stack Builder</code><br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816rSDvsTRCkF.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816rSDvsTRCkF.png"></p><p>選擇已安裝的PostgreSQL 版本</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816apVBlYXz5a.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816apVBlYXz5a.png"></p><p>選擇要安裝的元件，PostGIS在spatial extension下面</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816X0rSOnwBCU.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816X0rSOnwBCU.png"></p><p>stack builder會先下載檔案，因此選擇下載的路徑</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181029/201078167iHjOUx3DU.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/201078167iHjOUx3DU.png"></p><p>下載完成，下一步開始安裝</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181029/201078162N3LQmcOqq.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/201078162N3LQmcOqq.png"></p><p>開始安裝PostGIS<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816ad4idzH8Qd.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816ad4idzH8Qd.png"></p><p>選擇PostGIS<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816rsPKOYZfgH.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816rsPKOYZfgH.png"></p><p>最後，選擇路徑與下一步完成安裝。<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816WchP58rso6.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816WchP58rso6.png"></p><p>按照以上步驟，完成了PostgreSQL +PostGIS資料庫的安裝，<br>接下來我們會開始資料庫的操作</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PostGIS是&lt;code&gt;PostgreSQL&lt;/code&gt;對於OpenGIS空間資料規範的擴充，&lt;/p&gt;
&lt;p&gt;目前各大家資料庫對GIS資料都有支援及擴充&lt;/p&gt;
&lt;p&gt;不過就以易用性來說，開源軟體&lt;code&gt;QGIS&lt;/code&gt;對於PostGIS的支援度很高，而&lt;code&gt;Geopandas&lt;/code&gt;對於PostGIS的支援也十分友善。&lt;/p&gt;
&lt;p&gt;因此，十分建議常使用GIS資料的人安裝PostGIS在本機進行操作。&lt;/p&gt;
&lt;p&gt;今天我們來執行單機版PostGIS的安裝(使用windows)&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day13 台鐵意外事件與folium練習-繪圖</title>
    <link href="https://chimin17.github.io/2018/10/28/ironman-2019-day13/"/>
    <id>https://chimin17.github.io/2018/10/28/ironman-2019-day13/</id>
    <published>2018-10-28T13:10:01.000Z</published>
    <updated>2018-11-28T04:09:38.723Z</updated>
    
    <content type="html"><![CDATA[<p>昨天我們已經整合了台鐵路線與對話的資料<br>今天就把圖畫完吧！</p><p>首先，<br>再次看看昨天的成果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_lines_talk</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181028/201078166JDsBw1Y1c.png" alt="https://ithelp.ithome.com.tw/upload/images/20181028/201078166JDsBw1Y1c.png"></p><a id="more"></a><p>有了這樣的資料，可以開始畫圖了<br>第一種畫法我們使用circlemarker<br>我們以點的方式來呈現資訊</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import folium</span><br><span class="line">m = folium.Map((25.01743512170683,121.9402276726103),zoom_start=13)</span><br><span class="line">for idx,row in train_lines_talk.iterrows():</span><br><span class="line">    folium.CircleMarker(</span><br><span class="line">        location=(list(row[&apos;geometry&apos;].coords)[0][1],list(row[&apos;geometry&apos;].coords)[0][0]),</span><br><span class="line">        radius=20,</span><br><span class="line">        popup=row[&apos;text&apos;],</span><br><span class="line">        color=&apos;#3186cc&apos;,</span><br><span class="line">        fill=True,</span><br><span class="line">        fill_color=&apos;#3186cc&apos;</span><br><span class="line">    ).add_to(m)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">m</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181028/201078165DyRzjrZQN.png" alt="https://ithelp.ithome.com.tw/upload/images/20181028/201078165DyRzjrZQN.png"></p><p>為了更清楚呈現資訊，把路線的資訊加進來<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">folium.GeoJson(</span><br><span class="line">    train_lines.to_json(),</span><br><span class="line">    name=&apos;geojson&apos;).add_to(m)</span><br><span class="line">m</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181028/201078168bzIK8NICo.png" alt="https://ithelp.ithome.com.tw/upload/images/20181028/201078168bzIK8NICo.png"></p><p>最後，我們試著把時間資料加進來</p><p>並使用TimestampedGeoJson這個外掛</p><p>要先把我們的資料整合成TimestampedGeoJson<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">features = [</span><br><span class="line">    &#123;</span><br><span class="line">        &apos;type&apos;: &apos;Feature&apos;,</span><br><span class="line">        &apos;geometry&apos;: &#123;</span><br><span class="line">            &apos;type&apos;: &apos;Point&apos;,</span><br><span class="line">            &apos;coordinates&apos;:  list(row[&apos;geometry&apos;].coords)[0],</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;properties&apos;: &#123;</span><br><span class="line">            &apos;times&apos;: [&apos;2018-10-21T&apos;+row[&apos;time&apos;][0],&apos;2018-10-21T&apos;+row[&apos;time&apos;][1]],</span><br><span class="line">            &apos;talk&apos;: row[&apos;text&apos;],</span><br><span class="line">             &apos;location&apos;:row[&apos;location&apos;],</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for idx,row in train_lines_talk.iterrows()</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import folium</span><br><span class="line">m = folium.Map((25.01743512170683,121.9402276726103),zoom_start=13)</span><br><span class="line"></span><br><span class="line">folium.GeoJson(</span><br><span class="line">    train_lines.to_json(),</span><br><span class="line">    name=&apos;geojson&apos;).add_to(m)</span><br><span class="line"></span><br><span class="line">plugins.TimestampedGeoJson(&#123;</span><br><span class="line">    &apos;type&apos;: &apos;FeatureCollection&apos;,</span><br><span class="line">    &apos;features&apos;: features,</span><br><span class="line">    </span><br><span class="line">&#125;, period=&apos;PT1M&apos;, add_last_point=True).add_to(m)</span><br><span class="line"></span><br><span class="line">m</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181028/201078169ZyYVVd0VR.png" alt="https://ithelp.ithome.com.tw/upload/images/20181028/201078169ZyYVVd0VR.png"><br>完成！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天我們已經整合了台鐵路線與對話的資料&lt;br&gt;今天就把圖畫完吧！&lt;/p&gt;
&lt;p&gt;首先，&lt;br&gt;再次看看昨天的成果&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;train_lines_talk&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://ithelp.ithome.com.tw/upload/images/20181028/201078166JDsBw1Y1c.png&quot; alt=&quot;https://ithelp.ithome.com.tw/upload/images/20181028/201078166JDsBw1Y1c.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day12 台鐵意外事件與folium練習-續篇</title>
    <link href="https://chimin17.github.io/2018/10/27/ironman-2019-day12/"/>
    <id>https://chimin17.github.io/2018/10/27/ironman-2019-day12/</id>
    <published>2018-10-27T15:33:01.000Z</published>
    <updated>2018-11-28T04:09:35.089Z</updated>
    
    <content type="html"><![CDATA[<p>昨天做了一些前處理，<br>今天把昨天的處理好的資料做整合</p><p>首先是宜蘭縣鐵道(polyline)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import geopandas as gpd</span><br><span class="line">rail_yilan=gpd.read_file(&apos;output/Rail_yilan.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">rail_yilan</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>匯入車站資料，並進一步篩選通話中的車站</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">station=gpd.read_file(&apos;output/station.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">station_list=[&apos;貢寮&apos;,&apos;福隆&apos;,&apos;大里&apos;,&apos;大溪&apos;,&apos;龜山&apos;,&apos;頭城&apos;,&apos;宜蘭&apos;,&apos;二結&apos;,&apos;羅東&apos;,&apos;冬山&apos;,&apos;新馬&apos;]</span><br><span class="line">station=station[station[&apos;Station_Na&apos;].isin(station_list)]</span><br><span class="line">station=station.reset_index(drop=True)</span><br><span class="line">station</span><br></pre></td></tr></table></figure><p>最後的是對話資料<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd </span><br><span class="line">talk=pd.read_csv(&apos;output/talk.csv&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">talk[&apos;time&apos;]=[row[&apos;time&apos;][:-2]+&quot;00&quot; for idx,row in talk.iterrows()]</span><br><span class="line">talk</span><br></pre></td></tr></table></figure></p><p>接下來，我們把原始的路線資料切成通訊對話逐字稿的模式，這裡會用到graph的資訊計算，</p><ul><li>把polyline換算成graph</li><li>分別把車站設為起終點，計算路徑</li><li>例如在graph輸入宜蘭最近的node及羅東站最近的node,計算的得到這兩個站的路線<br>會採用這樣的做法是臨時決定的&gt;.&lt; 說不定改天有更好的做法<br>細節今天就先跳過，過幾天會講到，反正最終結果是要把polyline變成像是</li></ul><p><code>福隆-貢寮</code> 或是 <code>宜蘭-二結</code>的這種模式的線</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">## 這邊先手動整理對照表(對照上表)</span><br><span class="line">routes=[[9,10],</span><br><span class="line">[3,4],</span><br><span class="line">[3,3],</span><br><span class="line">[2,3],</span><br><span class="line">[6,7],</span><br><span class="line">[6,6],</span><br><span class="line">[0,2],</span><br><span class="line">[8,9] ,   </span><br><span class="line">[1,0],</span><br><span class="line">[4,5]]  </span><br><span class="line"></span><br><span class="line">from shapely.geometry import LineString,Point</span><br><span class="line">from s2g import ShapeGraph</span><br><span class="line">import networkx as nx</span><br><span class="line">sg = ShapeGraph(shapefile=&apos;output/Rail_yilan.shp&apos;, to_graph=True)</span><br><span class="line">graph = sg.to_networkx()</span><br><span class="line"></span><br><span class="line">line_gs=[]</span><br><span class="line">line_name=[]</span><br><span class="line">for route in routes:</span><br><span class="line"></span><br><span class="line">    min_distance=999</span><br><span class="line">    start_id=0</span><br><span class="line">    for num in range(sg.nodes_counter):</span><br><span class="line">        xy=sg.node_xy[num]</span><br><span class="line">        if Point(xy).distance(station.at[route[0],&apos;geometry&apos;])&lt;min_distance:</span><br><span class="line">            min_distance=Point(xy).distance(station.at[route[0],&apos;geometry&apos;])</span><br><span class="line">            start_id=num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    min_distance=999</span><br><span class="line">    end_id=0</span><br><span class="line">    for num in range(sg.nodes_counter):</span><br><span class="line">        xy=sg.node_xy[num]</span><br><span class="line">        if Point(xy).distance(station.at[route[1],&apos;geometry&apos;])&lt;min_distance:</span><br><span class="line">            min_distance=Point(xy).distance(station.at[route[1],&apos;geometry&apos;])</span><br><span class="line">            end_id=num</span><br><span class="line">            nearest_path= nx.shortest_path(graph, source=start_id, target=end_id)</span><br><span class="line">    geoms=[]</span><br><span class="line">    for item in nearest_path:</span><br><span class="line">            geoms.append(sg.node_xy[item])</span><br><span class="line">    try:</span><br><span class="line">        line_gs.append(LineString(geoms))</span><br><span class="line">        line_name.append(&quot;（地點：&quot;+station.at[route[0],&apos;Station_Na&apos;]+&quot;-&quot;+station.at[route[1],&apos;Station_Na&apos;]+&quot;)&quot;)</span><br><span class="line">    except:pass</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">train_lines = gpd.GeoDataFrame(crs= &#123;&apos;init&apos; :&apos;epsg:4326&apos;&#125;,geometry=line_gs)</span><br><span class="line">train_lines[&apos;location&apos;]=line_name</span><br><span class="line">train_lines</span><br></pre></td></tr></table></figure><p>以下是我們要的路線整合結果：<br><img src="https://ithelp.ithome.com.tw/upload/images/20181028/201078160IMKGXYicV.png" alt="https://ithelp.ithome.com.tw/upload/images/20181028/201078160IMKGXYicV.png"></p><p>最後整合對話與路線，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 初始化</span><br><span class="line">talk[&apos;geometry&apos;]=talk[&apos;location&apos;]</span><br><span class="line">for i1,r1 in talk.iterrows():</span><br><span class="line">    for i2,r2 in  train_lines.iterrows():</span><br><span class="line">        if r1[&apos;location&apos;]==r2[&apos;location&apos;]:</span><br><span class="line">            talk.at[i1,&apos;geometry&apos;]=r2[&apos;geometry&apos;]</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            talk.at[i1,&apos;geometry&apos;]=talk.at[0,&apos;geometry&apos;]</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">st=talk.at[0,&apos;time&apos;]</span><br><span class="line">temp_text=&quot;&quot;         </span><br><span class="line">geoms=[]</span><br><span class="line">temp_location=talk.at[0,&apos;location&apos;]</span><br><span class="line">for i1,r1 in talk.iterrows():</span><br><span class="line">    if temp_location!=talk.at[i1,&apos;location&apos;]:</span><br><span class="line">        geoms.append([talk.at[i1-1,&apos;geometry&apos;],[st,talk.at[i1-1,&apos;time&apos;]],talk.at[i1-1,&apos;location&apos;],temp_text])</span><br><span class="line">       </span><br><span class="line">        ##release</span><br><span class="line">        temp_location=talk.at[i1,&apos;location&apos;]</span><br><span class="line">        temp_text=&quot;&quot; </span><br><span class="line">        st=talk.at[i1,&apos;time&apos;]</span><br><span class="line">    else:</span><br><span class="line">        temp_text+=talk.at[i1,&apos;content&apos;]+&quot;;&quot;</span><br><span class="line">geoms.append([talk.at[i1,&apos;geometry&apos;],[st,talk.at[i1,&apos;time&apos;]],talk.at[i1,&apos;location&apos;],temp_text])      </span><br><span class="line">train_lines_talk= gpd.GeoDataFrame(geoms)</span><br><span class="line">train_lines_talk.columns=[&apos;geometry&apos;,&apos;time&apos;,&apos;location&apos;,&apos;text&apos;]</span><br><span class="line">train_lines_talk</span><br></pre></td></tr></table></figure></p><p>最終成果：<br><img src="https://ithelp.ithome.com.tw/upload/images/20181028/20107816JHBMzwq4Ud.png" alt="https://ithelp.ithome.com.tw/upload/images/20181028/20107816JHBMzwq4Ud.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天做了一些前處理，&lt;br&gt;今天把昨天的處理好的資料做整合&lt;/p&gt;
&lt;p&gt;首先是宜蘭縣鐵道(polyline)&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import geopandas as gpd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rail_yilan=gpd.read_file(&amp;apos;output/Rail_yilan.shp&amp;apos;,encoding=&amp;apos;utf-8&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rail_yilan&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day11 台鐵意外事件與folium練習-前處理</title>
    <link href="https://chimin17.github.io/2018/10/26/ironman-2019-day11/"/>
    <id>https://chimin17.github.io/2018/10/26/ironman-2019-day11/</id>
    <published>2018-10-26T13:39:55.000Z</published>
    <updated>2018-11-28T04:09:31.625Z</updated>
    
    <content type="html"><![CDATA[<p>最近的台鐵意外事件，看到有媒體及網友製作前端的網頁地圖呈現通話紀錄，剛好昨天使用了folium，一時興起今天也來用folium做看看，今天先來做一些前處理</p><blockquote><p>ps. 另外，也祝傷者平安及亡者安息</p></blockquote><a id="more"></a><h3 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h3><p>要呈現這樣的圖，包括了以下幾種資料：</p><ul><li><a href="https://data.gov.tw/dataset/73220" target="_blank" rel="noopener">臺灣鐵路 | 政府資料開放平臺</a></li><li><a href="https://www.railway.gov.tw/Upload/UserFiles/%E8%BB%8A%E7%AB%99%E5%9F%BA%E6%9C%AC%E8%B3%87%E6%96%99.json" target="_blank" rel="noopener">台鐵車站基本資料</a>（<a href="https://www.railway.gov.tw/tw/CP.aspx?sn=16938&amp;n=19573" target="_blank" rel="noopener">台鐵</a>）</li><li><a href="https://news.ftv.com.tw/AMP/News_Amp.aspx?id=2018A25W0003" target="_blank" rel="noopener">普悠瑪翻車前257句43分鐘對話曝光！ 司機一路求援邊開邊修-民視新聞網</a></li></ul><h3 id="逐字稿文字資料整理"><a href="#逐字稿文字資料整理" class="headerlink" title="逐字稿文字資料整理"></a>逐字稿文字資料整理</h3><p>網站上的逐字稿在上面的新聞網站可以看到<br><img src="https://ithelp.ithome.com.tw/upload/images/20181026/20107816cLUgXXES29.png" alt="https://ithelp.ithome.com.tw/upload/images/20181026/20107816cLUgXXES29.png"></p><p>我們試著把它結構化，我們使用requests去get網頁文檔，並用BeautifulSoup結構化資料<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import pandas as pd </span><br><span class="line">import geopandas as gpd</span><br><span class="line">import re</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">result=requests.get(&apos;https://news.ftv.com.tw/AMP/News_Amp.aspx?id=2018A25W0003&apos;)</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(result.text, &apos;html.parser&apos;)</span><br></pre></td></tr></table></figure></p><p>有關這些技術細節，請參考以下程式碼<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">p_count=0</span><br><span class="line">start_flag=False</span><br><span class="line">p_contents=soup.find_all(&apos;p&apos;)</span><br><span class="line">all_data=[]</span><br><span class="line">location=&quot;&quot;</span><br><span class="line">time=&quot;&quot;</span><br><span class="line">for p_item in p_contents:</span><br><span class="line">    </span><br><span class="line">    text=str(p_item.text)</span><br><span class="line">    if text ==&apos;完整通聯紀錄：&apos;:</span><br><span class="line">        start_flag=True</span><br><span class="line">        p_count+=1</span><br><span class="line">        continue</span><br><span class="line">    </span><br><span class="line">    if len(re.findall(&apos;地點&apos;,text))&gt;0:</span><br><span class="line">        location=text</span><br><span class="line">        continue</span><br><span class="line">        </span><br><span class="line">    if len(text.split(&apos;:&apos;))==3 and len(text)==8:</span><br><span class="line">        time=text</span><br><span class="line">        continue</span><br><span class="line">            </span><br><span class="line">    # 處理前幾行</span><br><span class="line">    if start_flag==True:</span><br><span class="line">        if  p_count&lt;4:</span><br><span class="line">            p_count+=1</span><br><span class="line">            time=text[0:8]</span><br><span class="line">            all_data.append([location,time,text[8:]])</span><br><span class="line">        else:</span><br><span class="line">            all_data.append([location,time,text])</span><br><span class="line">       </span><br><span class="line">all_data</span><br></pre></td></tr></table></figure></p><p>整理好會變這樣<br><img src="https://ithelp.ithome.com.tw/upload/images/20181026/20107816B55Kmp8FJ5.png" alt="https://ithelp.ithome.com.tw/upload/images/20181026/20107816B55Kmp8FJ5.png"></p><h3 id="整合車站資料與路線"><a href="#整合車站資料與路線" class="headerlink" title="整合車站資料與路線"></a>整合車站資料與路線</h3><p>首先，我們把車站資料處理成GIS資料，利用pandas2geopandas的技巧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from shapely.geometry import Point</span><br><span class="line">station_pd=pd.read_json(&apos;data/Station/Station.json&apos;, &apos;r&apos;, encoding=&apos;utf-8-sig&apos;)</span><br><span class="line">station_pd=station_pd[station_pd[&apos;gps&apos;]!=&apos;&apos;]</span><br><span class="line">y = [float(row[&apos;gps&apos;].split(&apos;,&apos;)[0].replace(&apos; &apos;,&apos;&apos;)) for idx,row in station_pd.iterrows()]</span><br><span class="line">x = [float(row[&apos;gps&apos;].split(&apos;,&apos;)[1].replace(&apos; &apos;,&apos;&apos;)) for idx,row in station_pd.iterrows()]</span><br><span class="line">geom = [Point(xy) for xy in zip(x, y)]</span><br><span class="line">crs = &#123;&apos;init&apos;: &apos;epsg:4326&apos;&#125;</span><br><span class="line">station = gpd.GeoDataFrame(station_pd, crs=crs, geometry=geom)</span><br><span class="line">station[[&apos;Station_Name&apos;,&apos;geometry&apos;]].to_file(&apos;output/station.shp&apos;)</span><br><span class="line">station</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181026/20107816kroJtDUgtw.png" alt="https://ithelp.ithome.com.tw/upload/images/20181026/20107816kroJtDUgtw.png"></p><p>然後把第一天出現過的鐵路資料再拿來，並且選擇<code>臺鐵宜蘭線</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rail=gpd.read_file(&apos;data/Rail/Rail.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">rail.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; # 避免資料沒設，這邊再重新給一次</span><br><span class="line">rail=rail.to_crs(epsg=4326)</span><br><span class="line"># rail.groupby(&apos;RAILNAME&apos;).size()</span><br><span class="line">rail=rail[rail[&apos;RAILNAME&apos;]==&apos;臺鐵宜蘭線&apos;]</span><br><span class="line">rail.reset_index(inplace=True)</span><br><span class="line">rail</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181026/20107816PBY1KZVxgN.png" alt="https://ithelp.ithome.com.tw/upload/images/20181026/20107816PBY1KZVxgN.png"></p><p>先觀察一下資料，我們把他們一起畫在地圖上瀏覽：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import folium</span><br><span class="line">m = folium.Map((24.694192,121.775163),zoom_start=18)</span><br><span class="line"></span><br><span class="line">folium.GeoJson(</span><br><span class="line">    station.to_json(),</span><br><span class="line">    name=&apos;geojson&apos;</span><br><span class="line">).add_to(m)</span><br><span class="line"></span><br><span class="line">rail_geojson  = folium.GeoJson(</span><br><span class="line">    rail.to_json(),</span><br><span class="line">    name=&apos;geojson&apos;,</span><br><span class="line"> </span><br><span class="line">)</span><br><span class="line">popup = folium.Popup(&apos;Hi&apos;)</span><br><span class="line">popup.add_to(rail_geojson)</span><br><span class="line">rail_geojson.add_to(m)</span><br><span class="line"></span><br><span class="line">m</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181026/201078169VVve0jLrr.png" alt="https://ithelp.ithome.com.tw/upload/images/20181026/201078169VVve0jLrr.png"></p><p>由於車站的資料與鐵路資料有一點gap，也就是說車站的點不會在鐵路線上，這會影響到展示，<br>因此，我們試著把他投影到線上，這邊的投影我們直接使用向量內外積來處理：<br><img src="https://ithelp.ithome.com.tw/upload/images/20181026/20107816A6oajmkggD.png" alt="https://ithelp.ithome.com.tw/upload/images/20181026/20107816A6oajmkggD.png"></p><p>計算過程中，我們把每個元素的投影都算一遍，並取距離最短的點，作為車站修正後的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from shapely.geometry import Point</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i1,r1 in station.iterrows():</span><br><span class="line">    point=r1[&apos;geometry&apos;]</span><br><span class="line">    min_distance=999</span><br><span class="line">    new_point=point</span><br><span class="line">    for i2,r2 in rail.iterrows():</span><br><span class="line"></span><br><span class="line">        line = r2[&apos;geometry&apos;]</span><br><span class="line"></span><br><span class="line">        x = np.array(point.coords[0])</span><br><span class="line"></span><br><span class="line">        u = np.array(line.coords[0])</span><br><span class="line">        v = np.array(line.coords[len(line.coords)-1])</span><br><span class="line"></span><br><span class="line">        n = v - u</span><br><span class="line">        n /= np.linalg.norm(n, 2)</span><br><span class="line"></span><br><span class="line">        P = u + n*np.dot(x - u, n)</span><br><span class="line">        distance=Point(P).distance(point)</span><br><span class="line">        if distance&lt;min_distance:</span><br><span class="line">            min_distance=distance</span><br><span class="line">            new_point=Point(P)</span><br><span class="line">    station.at[i1,&apos;geometry&apos;]=new_point</span><br></pre></td></tr></table></figure></p><p>還有另外一種解法，在<code>第七天</code>的時候我們提到<code>shapely</code>的<code>project</code>與<code>interpolate</code><br>這兩個連續技，結果跟上面是一樣的<br><code>new_point = line.interpolate(line.project(point))</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for i1,r1 in station.iterrows():</span><br><span class="line">    point=r1[&apos;geometry&apos;]</span><br><span class="line">    min_distance=999</span><br><span class="line">    new_point=point</span><br><span class="line">    for i2,r2 in rail.iterrows():</span><br><span class="line"></span><br><span class="line">        line = r2[&apos;geometry&apos;]</span><br><span class="line">        temp_point = line.interpolate(line.project(point))</span><br><span class="line">        distance=temp_point.distance(point)</span><br><span class="line">        if distance&lt;min_distance:</span><br><span class="line">            min_distance=distance</span><br><span class="line">            new_point=temp_point</span><br><span class="line">    station.at[i1,&apos;geometry&apos;]=new_point</span><br></pre></td></tr></table></figure></p><p>上面的方法二選一，再用前面的code繪製一次成果，可以看到車站已經被修正在鐵路網上！<br><img src="https://ithelp.ithome.com.tw/upload/images/20181026/20107816JWxh417cbh.png" alt="https://ithelp.ithome.com.tw/upload/images/20181026/20107816JWxh417cbh.png"></p><h3 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h3><p>今天我們完成了一些前處理<br>雖然這些前處理其實有些也沒這麼必要，甚至手動畫一畫就好了，不過基於練習的精神還是明天繼續把它完成吧<br>下班時間有點晚，明天再加油！</p><blockquote><p>對今天的測試有興趣請參考<a href="https://github.com/chimin17/2019_30day/blob/master/Day11_TWNRAIL_folium_part1.ipynb" target="_blank" rel="noopener">github程式碼</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近的台鐵意外事件，看到有媒體及網友製作前端的網頁地圖呈現通話紀錄，剛好昨天使用了folium，一時興起今天也來用folium做看看，今天先來做一些前處理&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ps. 另外，也祝傷者平安及亡者安息&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
</feed>
