<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chimin&#39;s Blog</title>
  
  <subtitle>Chimin&#39;s 技術分享筆記</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chimin17.github.io/"/>
  <updated>2018-11-02T02:21:14.877Z</updated>
  <id>https://chimin17.github.io/</id>
  
  <author>
    <name>Chi-Min Chiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>鐵人賽2019 Day17 Geogig GIS版本控制</title>
    <link href="https://chimin17.github.io/2018/11/01/ironman-2019-day17/"/>
    <id>https://chimin17.github.io/2018/11/01/ironman-2019-day17/</id>
    <published>2018-11-01T13:59:49.000Z</published>
    <updated>2018-11-02T02:21:14.877Z</updated>
    
    <content type="html"><![CDATA[<p>今天的主題與Python較於無關，這陣子遇到資料版本控制的需求，有搜尋並測試了一下<code>geogig</code>這個軟體，在此稍微紀錄一下。</p><p><code>geogig</code>是個開源專案，使用JAVA開發並以BSD授權，主要目的是做GIS資料的版本控制，整個操作經驗與<code>git</code>類似，支援的GIS資料包含<code>shapefile</code>、<code>PostGIS</code>、<code>SpatiaLite</code>等，對每一次commit的GIS追蹤管理，也可對資料開分支、遠端分支等等功能。</p><p>今天就記錄一下比較基本的步驟。</p><a id="more"></a><h3 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h3><p>Geogig官網以包好exe，前往官網下載<br><a href="http://geogig.org/#install" target="_blank" rel="noopener">GeoGig by LocationTech</a></p><p>解壓縮到<code>D:\</code>後，把路徑加入<code>系統環境變數</code>中<br><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816ZpA7vOTKYw.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816ZpA7vOTKYw.png"></p><p>我們測試一下，打開cmd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816eeZKSoSSFH.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816eeZKSoSSFH.png"></p><p>設定好路徑並有反應了，我們可以開始操作Geogig了</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化一個repo，這邊的初始化跟git一樣：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig init</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816dFbuNcWgzo.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816dFbuNcWgzo.png"></p><p>我們把rail.shp加入一個commit，在這之前要先用<code>shp import</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig shp import rail.shp -d rail</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816t4swAL4Khq.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816t4swAL4Khq.png"></p><p>上面的import跟一般git比等於是多一步，import之後可以add，這個動作跟<code>git add .</code>一樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig add</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/2010781607eqR3FT2S.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/2010781607eqR3FT2S.png"></p><p>然後，就可以commit了，這邊的commit跟git也是一樣的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig commit -m &quot;init&quot;</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816SIvZ7BhaLV.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816SIvZ7BhaLV.png"></p><blockquote><p>這邊操作的時候跳了一個錯，因為第一次操作時，Geogig會要求輸入user config，跟git一樣，如果遇到就這步驟設定就好了<br><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816o0W9mwq8HQ.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816o0W9mwq8HQ.png"></p></blockquote><p>成功操作<br><img src="https://ithelp.ithome.com.tw/upload/images/20181101/201078162awtAJfyOk.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/201078162awtAJfyOk.png"></p><h4 id="如果要update資料"><a href="#如果要update資料" class="headerlink" title="如果要update資料"></a>如果要update資料</h4><p>我們進入<code>QGIS</code>給資料一些異動，<br>我們直接修改資料的屬性(修改數筆DEFINITION)<br><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816DS6120zyr4.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816DS6120zyr4.png"></p><p>要再提供一次commit 要把<code>shp import</code>跟<code>add</code> 在操作一次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig shp import rail.shp -d rail</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816Z0N6bHF8M6.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816Z0N6bHF8M6.png"></p><p>add，這邊可以看到一些異動資訊<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig add</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816CwndjHznwy.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816CwndjHznwy.png"></p><p>commit，然後第二個版本的資料就被記錄上去了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig commit -m &quot;second round&quot;</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816Mdho2Be8Ne.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816Mdho2Be8Ne.png"><br>從上可以看到版本間的異動</p><h3 id="基本資訊"><a href="#基本資訊" class="headerlink" title="基本資訊"></a>基本資訊</h3><p>接下來來看看repo與commit的資訊</p><p>觀看repo內容用<code>ls</code><br>看到目前的repo中的資料集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig ls</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/20107816gy7HGRq5Bm.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/20107816gy7HGRq5Bm.png"></p><p><code>log</code> 看版本的歷史過程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geogig log</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181101/201078161GJXrFm6mZ.png" alt="https://ithelp.ithome.com.tw/upload/images/20181101/201078161GJXrFm6mZ.png"></p><h3 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h3><p>Geogig在QGIS與Geoserver有外掛可以使用，今天先以git的觀點進行基本操作，有興趣者可操作看看！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的主題與Python較於無關，這陣子遇到資料版本控制的需求，有搜尋並測試了一下&lt;code&gt;geogig&lt;/code&gt;這個軟體，在此稍微紀錄一下。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;geogig&lt;/code&gt;是個開源專案，使用JAVA開發並以BSD授權，主要目的是做GIS資料的版本控制，整個操作經驗與&lt;code&gt;git&lt;/code&gt;類似，支援的GIS資料包含&lt;code&gt;shapefile&lt;/code&gt;、&lt;code&gt;PostGIS&lt;/code&gt;、&lt;code&gt;SpatiaLite&lt;/code&gt;等，對每一次commit的GIS追蹤管理，也可對資料開分支、遠端分支等等功能。&lt;/p&gt;
&lt;p&gt;今天就記錄一下比較基本的步驟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day16 WKT與PostGIS的運算</title>
    <link href="https://chimin17.github.io/2018/10/31/ironman-2019-day16/"/>
    <id>https://chimin17.github.io/2018/10/31/ironman-2019-day16/</id>
    <published>2018-10-31T14:02:39.000Z</published>
    <updated>2018-11-02T02:19:41.260Z</updated>
    
    <content type="html"><![CDATA[<p>在昨天的文章中，我們要把資料倒入PostGIS前，需要使用geoalchemy2把坐標資料轉成<code>WKT element</code>，今天來理解一下WKT</p><h3 id="WKT"><a href="#WKT" class="headerlink" title="WKT"></a>WKT</h3><p>WKT的全寫是(Well Known Text)，是OGC SFS（Simple Features Interface Standard）對於資料庫中GIS資料的架構定義，全文可從<a href="http://www.opengeospatial.org/standards/sfa" target="_blank" rel="noopener">連結</a>下載，另外SQL語法對於GIS處理的定義，也是在這份文件中定義，大多數GIS資料庫都有提供SFS的基本定義及功能。</p><p>有關SFS的幾何類型參考下圖：<br><img src="https://ithelp.ithome.com.tw/upload/images/20181031/20107816auFnhEeYJX.png" alt="https://ithelp.ithome.com.tw/upload/images/20181031/20107816auFnhEeYJX.png"><br>(取自<a href="http://www.opengeospatial.org/standards/sfa" target="_blank" rel="noopener">OGC</a>)</p><a id="more"></a><p>WKT是以文字方式表達幾何，以下從網站上擷取一些類型(取自<a href="https://en.wikipedia.org/wiki/Well-known_text" target="_blank" rel="noopener">WIKI</a>)<br><img src="https://ithelp.ithome.com.tw/upload/images/20181031/20107816yTOer2h25Y.png" alt="https://ithelp.ithome.com.tw/upload/images/20181031/20107816yTOer2h25Y.png"></p><h3 id="WKB"><a href="#WKB" class="headerlink" title="WKB"></a>WKB</h3><p>WKB(Well Known Binary)顧名思義就是將WKT加以binary編碼，[<a href="https://blog.csdn.net/yaoxiaochuang/article/details/53117693" target="_blank" rel="noopener">1</a>]有對於WKB位數儲存有一些說明，而WKB主要是讓WKT更加緊湊。</p><h3 id="WKT與GeoDataFrame"><a href="#WKT與GeoDataFrame" class="headerlink" title="WKT與GeoDataFrame"></a>WKT與GeoDataFrame</h3><p>PostGIS的空間屬性是根據OGC SFS，<br>前幾天有提到Geopandas的空間資料是使用shapely的定義，昨天的範例主要是透過<a href="https://geoalchemy-2.readthedocs.io/en/latest/" target="_blank" rel="noopener">geoalchemy2</a>將shapely的geometry轉為PostGIS的geometry，以方便幾何資料的ORM<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from geoalchemy2 import Geometry, WKTElement</span><br><span class="line">gdf=gpd.read_file(&apos;data/Rail/Rail.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">gdf[&apos;geom&apos;] = gdf[&apos;geometry&apos;].apply(lambda x: WKTElement(x.wkt, srid=3826))</span><br><span class="line">gdf.drop(&apos;geometry&apos;, 1, inplace=True)</span><br><span class="line">type(gdf.at[0,&apos;geom&apos;] )</span><br></pre></td></tr></table></figure></p><p>結果為<code>geoalchemy2.elements.WKTElement</code></p><p>to_sql<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy import create_engine</span><br><span class="line">engine = create_engine(&apos;postgresql://postgres:postgres@localhost:5432/public&apos;)</span><br><span class="line">gdf.to_sql(&apos;rail&apos;, engine, if_exists=&apos;replace&apos;, index=False, schema=&apos;public&apos;</span><br><span class="line">           ,dtype=&#123;&apos;geom&apos;: Geometry(&apos;LINESTRING&apos;, srid= 3826)&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="PostGIS"><a href="#PostGIS" class="headerlink" title="PostGIS"></a>PostGIS</h3><p>OGC SFS有定義幾何運算的實踐，在PostGIS可以進行操作，大致包含了<br><img src="https://ithelp.ithome.com.tw/upload/images/20181031/20107816tdHE4yn5MT.png" alt="https://ithelp.ithome.com.tw/upload/images/20181031/20107816tdHE4yn5MT.png"><br>(取自<a href="http://www.opengeospatial.org/standards/sfa" target="_blank" rel="noopener">OGC</a>)</p><p>我們把SQL語法執行並直接用GeoDataFrame接，例如我們要對每一個線段做buffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql=&apos;select ST_buffer(rail.geom,0.0001) as geometry from public.rail &apos;</span><br><span class="line">df = gpd.GeoDataFrame.from_postgis(sql, engine, geom_col=&apos;geometry&apos; )</span><br><span class="line">df</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181031/20107816kajGxaeFtb.png" alt="https://ithelp.ithome.com.tw/upload/images/20181031/20107816kajGxaeFtb.png"></p><p>而其他的幾何操作，可以參考<a href="https://postgis.net/docs/reference.html" target="_blank" rel="noopener">PostGIS Reference</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在昨天的文章中，我們要把資料倒入PostGIS前，需要使用geoalchemy2把坐標資料轉成&lt;code&gt;WKT element&lt;/code&gt;，今天來理解一下WKT&lt;/p&gt;
&lt;h3 id=&quot;WKT&quot;&gt;&lt;a href=&quot;#WKT&quot; class=&quot;headerlink&quot; title=&quot;WKT&quot;&gt;&lt;/a&gt;WKT&lt;/h3&gt;&lt;p&gt;WKT的全寫是(Well Known Text)，是OGC SFS（Simple Features Interface Standard）對於資料庫中GIS資料的架構定義，全文可從&lt;a href=&quot;http://www.opengeospatial.org/standards/sfa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;連結&lt;/a&gt;下載，另外SQL語法對於GIS處理的定義，也是在這份文件中定義，大多數GIS資料庫都有提供SFS的基本定義及功能。&lt;/p&gt;
&lt;p&gt;有關SFS的幾何類型參考下圖：&lt;br&gt;&lt;img src=&quot;https://ithelp.ithome.com.tw/upload/images/20181031/20107816auFnhEeYJX.png&quot; alt=&quot;https://ithelp.ithome.com.tw/upload/images/20181031/20107816auFnhEeYJX.png&quot;&gt;&lt;br&gt;(取自&lt;a href=&quot;http://www.opengeospatial.org/standards/sfa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OGC&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day15 PostGIS與Geopandas</title>
    <link href="https://chimin17.github.io/2018/10/30/ironman-2019-day15/"/>
    <id>https://chimin17.github.io/2018/10/30/ironman-2019-day15/</id>
    <published>2018-10-30T13:20:40.000Z</published>
    <updated>2018-11-02T02:18:25.947Z</updated>
    
    <content type="html"><![CDATA[<p>昨天安裝完了PostGIS，<br>今天我們就在GeoPandas做資料讀寫，<br>另外QGIS對於PostGIS支援度也很高，把資料匯入後，也可以使用QGIS對資料做讀寫。</p><blockquote><p>ps. 安裝完PostGIS，我們需要在DB中啟用<br>若未啟用postgis安裝完後在pgAdmin4或是psql輸入<br>postgres=# CREATE EXTENSION postgis;</p></blockquote><a id="more"></a><p>為了用PostGIS讀寫資料<br>我們使用data/Rail/Rail.shp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import geopandas as gpd</span><br><span class="line"></span><br><span class="line">rail=gpd.read_file(&apos;data/Rail/Rail.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">rail.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; </span><br><span class="line">rail=rail.to_crs(epsg=4326)</span><br><span class="line">rail.head()</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181030/20107816SLrMqcJL0F.png" alt="https://ithelp.ithome.com.tw/upload/images/20181030/20107816SLrMqcJL0F.png"><br><img src="https://ithelp.ithome.com.tw/upload/images/20181030/20107816A9eW0TsvlS.png" alt="https://ithelp.ithome.com.tw/upload/images/20181030/20107816A9eW0TsvlS.png"><br>在GeoPandas，可以使用sqlalchemy建立資料庫連線的instance，對資料庫IO</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy import create_engine</span><br><span class="line">engine = create_engine(&apos;postgresql://postgres:postgres@localhost:5432/postgres&apos;)</span><br></pre></td></tr></table></figure><p>接著，使用to_sql這個方法，其中呢必須把geometry包成wkt element，由於一般使用geom作為PostGIS的空間屬性，這邊也一並處理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from geoalchemy2 import Geometry, WKTElement</span><br><span class="line">rail[&apos;geom&apos;] = rail[&apos;geometry&apos;].apply(lambda x: WKTElement(x.wkt, srid=4326))</span><br><span class="line">rail.drop(&apos;geometry&apos;, 1, inplace=True)</span><br></pre></td></tr></table></figure></p><p>在to_sql的時候要設定連線實體、dtype(空間資料的坐標系統及幾何類型，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rail.to_sql(&apos;rail&apos;, engine, if_exists=&apos;replace&apos;, index=False, schema=&apos;public&apos;,</span><br><span class="line">           dtype=&#123;&apos;geom&apos;: Geometry(&apos;LINESTRING&apos;, srid= 4326)&#125;)</span><br></pre></td></tr></table></figure></p><p>如果是其他的型別如，Point或Polygon，記得要修改</p><p>資料進PostGIS後，可以使用QGIS瀏覽、處理資料，有時需要編輯幾何資料的時候，使用QGIS很方便，熟悉QGIS的邦友可以使用DB Manager對PostGIS做操作<br><img src="https://ithelp.ithome.com.tw/upload/images/20181030/20107816kzOS2GxW7Z.png" alt="https://ithelp.ithome.com.tw/upload/images/20181030/20107816kzOS2GxW7Z.png"><br><img src="https://ithelp.ithome.com.tw/upload/images/20181030/20107816Jna9KThbm8.png" alt="https://ithelp.ithome.com.tw/upload/images/20181030/20107816Jna9KThbm8.png"></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181030/20107816c2Kdm92utv.png" alt="https://ithelp.ithome.com.tw/upload/images/20181030/20107816c2Kdm92utv.png"></p><p>而剛剛的資料也可以在讀回Geopandas</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql=&apos;select * from public.rail &apos;</span><br><span class="line">df = gpd.GeoDataFrame.from_postgis(sql, engine, geom_col=&apos;geom&apos; )</span><br><span class="line">df</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181030/201078168t7lrmhqJZ.png" alt="https://ithelp.ithome.com.tw/upload/images/20181030/201078168t7lrmhqJZ.png"><br>使用資料庫是資料處理及資料分析不可或缺的一環，在空間資料庫中，PostGIS非常方便，建議大家使用！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天安裝完了PostGIS，&lt;br&gt;今天我們就在GeoPandas做資料讀寫，&lt;br&gt;另外QGIS對於PostGIS支援度也很高，把資料匯入後，也可以使用QGIS對資料做讀寫。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ps. 安裝完PostGIS，我們需要在DB中啟用&lt;br&gt;若未啟用postgis安裝完後在pgAdmin4或是psql輸入&lt;br&gt;postgres=# CREATE EXTENSION postgis;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day14 PostGIS的安裝</title>
    <link href="https://chimin17.github.io/2018/10/29/ironman-2019-day14/"/>
    <id>https://chimin17.github.io/2018/10/29/ironman-2019-day14/</id>
    <published>2018-10-29T15:11:22.000Z</published>
    <updated>2018-11-02T02:17:05.812Z</updated>
    
    <content type="html"><![CDATA[<p>PostGIS是<code>PostgreSQL</code>對於OpenGIS空間資料規範的擴充，</p><p>目前各大家資料庫對GIS資料都有支援及擴充</p><p>不過就以易用性來說，開源軟體<code>QGIS</code>對於PostGIS的支援度很高，而<code>Geopandas</code>對於PostGIS的支援也十分友善。</p><p>因此，十分建議常使用GIS資料的人安裝PostGIS在本機進行操作。</p><p>今天我們來執行單機版PostGIS的安裝(使用windows)</p><a id="more"></a><p>首先到<a href="https://www.enterprisedb.com/software-downloads-postgres" target="_blank" rel="noopener">EnterpriseDB Software Downloads | EnterpriseDB</a>下載PostgreSQL安裝檔<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816KOjCaGjq7C.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816KOjCaGjq7C.png"></p><p>打開安裝檔，開始安裝PostgreSQL<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816XRxLFuRfWw.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816XRxLFuRfWw.png"></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816aZv1zfyknE.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816aZv1zfyknE.png"></p><p>選擇要安裝的元件，為了安裝PostGIS，請把Stack Builder要打勾<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816IzzzxlSBjO.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816IzzzxlSBjO.png"></p><p>接下來選擇資料庫的路徑<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816RhTWuuBAmf.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816RhTWuuBAmf.png"></p><p>設定資料庫的密碼，輸入後請記得<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/201078167sSI8HXnbJ.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/201078167sSI8HXnbJ.png"></p><p>port設定(預設即可)<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816H3JdKLWvo7.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816H3JdKLWvo7.png"></p><p>地區<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816U80z5Pevzm.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816U80z5Pevzm.png"></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181029/201078169iyuKsIIsb.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/201078169iyuKsIIsb.png"></p><p>然後就開始安裝<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816BmqvmCDMR8.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816BmqvmCDMR8.png"></p><p>以上，完成了PostgreSQL 的安裝</p><p>接下來要安裝PostGIS<br>打開<code>Stack Builder</code><br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816rSDvsTRCkF.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816rSDvsTRCkF.png"></p><p>選擇已安裝的PostgreSQL 版本</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816apVBlYXz5a.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816apVBlYXz5a.png"></p><p>選擇要安裝的元件，PostGIS在spatial extension下面</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816X0rSOnwBCU.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816X0rSOnwBCU.png"></p><p>stack builder會先下載檔案，因此選擇下載的路徑</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181029/201078167iHjOUx3DU.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/201078167iHjOUx3DU.png"></p><p>下載完成，下一步開始安裝</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181029/201078162N3LQmcOqq.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/201078162N3LQmcOqq.png"></p><p>開始安裝PostGIS<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816ad4idzH8Qd.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816ad4idzH8Qd.png"></p><p>選擇PostGIS<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816rsPKOYZfgH.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816rsPKOYZfgH.png"></p><p>最後，選擇路徑與下一步完成安裝。<br><img src="https://ithelp.ithome.com.tw/upload/images/20181029/20107816WchP58rso6.png" alt="https://ithelp.ithome.com.tw/upload/images/20181029/20107816WchP58rso6.png"></p><p>按照以上步驟，完成了PostgreSQL +PostGIS資料庫的安裝，<br>接下來我們會開始資料庫的操作</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PostGIS是&lt;code&gt;PostgreSQL&lt;/code&gt;對於OpenGIS空間資料規範的擴充，&lt;/p&gt;
&lt;p&gt;目前各大家資料庫對GIS資料都有支援及擴充&lt;/p&gt;
&lt;p&gt;不過就以易用性來說，開源軟體&lt;code&gt;QGIS&lt;/code&gt;對於PostGIS的支援度很高，而&lt;code&gt;Geopandas&lt;/code&gt;對於PostGIS的支援也十分友善。&lt;/p&gt;
&lt;p&gt;因此，十分建議常使用GIS資料的人安裝PostGIS在本機進行操作。&lt;/p&gt;
&lt;p&gt;今天我們來執行單機版PostGIS的安裝(使用windows)&lt;/p&gt;
    
    </summary>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day13 台鐵意外事件與folium練習-繪圖</title>
    <link href="https://chimin17.github.io/2018/10/28/ironman-2019-day13/"/>
    <id>https://chimin17.github.io/2018/10/28/ironman-2019-day13/</id>
    <published>2018-10-28T13:10:01.000Z</published>
    <updated>2018-11-02T02:17:01.340Z</updated>
    
    <content type="html"><![CDATA[<p>昨天我們已經整合了台鐵路線與對話的資料<br>今天就把圖畫完吧！</p><p>首先，<br>再次看看昨天的成果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_lines_talk</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181028/201078166JDsBw1Y1c.png" alt="https://ithelp.ithome.com.tw/upload/images/20181028/201078166JDsBw1Y1c.png"></p><a id="more"></a><p>有了這樣的資料，可以開始畫圖了<br>第一種畫法我們使用circlemarker<br>我們以點的方式來呈現資訊</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import folium</span><br><span class="line">m = folium.Map((25.01743512170683,121.9402276726103),zoom_start=13)</span><br><span class="line">for idx,row in train_lines_talk.iterrows():</span><br><span class="line">    folium.CircleMarker(</span><br><span class="line">        location=(list(row[&apos;geometry&apos;].coords)[0][1],list(row[&apos;geometry&apos;].coords)[0][0]),</span><br><span class="line">        radius=20,</span><br><span class="line">        popup=row[&apos;text&apos;],</span><br><span class="line">        color=&apos;#3186cc&apos;,</span><br><span class="line">        fill=True,</span><br><span class="line">        fill_color=&apos;#3186cc&apos;</span><br><span class="line">    ).add_to(m)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">m</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181028/201078165DyRzjrZQN.png" alt="https://ithelp.ithome.com.tw/upload/images/20181028/201078165DyRzjrZQN.png"></p><p>為了更清楚呈現資訊，把路線的資訊加進來<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">folium.GeoJson(</span><br><span class="line">    train_lines.to_json(),</span><br><span class="line">    name=&apos;geojson&apos;).add_to(m)</span><br><span class="line">m</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181028/201078168bzIK8NICo.png" alt="https://ithelp.ithome.com.tw/upload/images/20181028/201078168bzIK8NICo.png"></p><p>最後，我們試著把時間資料加進來</p><p>並使用TimestampedGeoJson這個外掛</p><p>要先把我們的資料整合成TimestampedGeoJson<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">features = [</span><br><span class="line">    &#123;</span><br><span class="line">        &apos;type&apos;: &apos;Feature&apos;,</span><br><span class="line">        &apos;geometry&apos;: &#123;</span><br><span class="line">            &apos;type&apos;: &apos;Point&apos;,</span><br><span class="line">            &apos;coordinates&apos;:  list(row[&apos;geometry&apos;].coords)[0],</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;properties&apos;: &#123;</span><br><span class="line">            &apos;times&apos;: [&apos;2018-10-21T&apos;+row[&apos;time&apos;][0],&apos;2018-10-21T&apos;+row[&apos;time&apos;][1]],</span><br><span class="line">            &apos;talk&apos;: row[&apos;text&apos;],</span><br><span class="line">             &apos;location&apos;:row[&apos;location&apos;],</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for idx,row in train_lines_talk.iterrows()</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import folium</span><br><span class="line">m = folium.Map((25.01743512170683,121.9402276726103),zoom_start=13)</span><br><span class="line"></span><br><span class="line">folium.GeoJson(</span><br><span class="line">    train_lines.to_json(),</span><br><span class="line">    name=&apos;geojson&apos;).add_to(m)</span><br><span class="line"></span><br><span class="line">plugins.TimestampedGeoJson(&#123;</span><br><span class="line">    &apos;type&apos;: &apos;FeatureCollection&apos;,</span><br><span class="line">    &apos;features&apos;: features,</span><br><span class="line">    </span><br><span class="line">&#125;, period=&apos;PT1M&apos;, add_last_point=True).add_to(m)</span><br><span class="line"></span><br><span class="line">m</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181028/201078169ZyYVVd0VR.png" alt="https://ithelp.ithome.com.tw/upload/images/20181028/201078169ZyYVVd0VR.png"><br>完成！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天我們已經整合了台鐵路線與對話的資料&lt;br&gt;今天就把圖畫完吧！&lt;/p&gt;
&lt;p&gt;首先，&lt;br&gt;再次看看昨天的成果&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;train_lines_talk&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://ithelp.ithome.com.tw/upload/images/20181028/201078166JDsBw1Y1c.png&quot; alt=&quot;https://ithelp.ithome.com.tw/upload/images/20181028/201078166JDsBw1Y1c.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day12 台鐵意外事件與folium練習-續篇</title>
    <link href="https://chimin17.github.io/2018/10/27/ironman-2019-day12/"/>
    <id>https://chimin17.github.io/2018/10/27/ironman-2019-day12/</id>
    <published>2018-10-27T15:33:01.000Z</published>
    <updated>2018-11-02T02:16:54.383Z</updated>
    
    <content type="html"><![CDATA[<p>昨天做了一些前處理，<br>今天把昨天的處理好的資料做整合</p><p>首先是宜蘭縣鐵道(polyline)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import geopandas as gpd</span><br><span class="line">rail_yilan=gpd.read_file(&apos;output/Rail_yilan.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">rail_yilan</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>匯入車站資料，並進一步篩選通話中的車站</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">station=gpd.read_file(&apos;output/station.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">station_list=[&apos;貢寮&apos;,&apos;福隆&apos;,&apos;大里&apos;,&apos;大溪&apos;,&apos;龜山&apos;,&apos;頭城&apos;,&apos;宜蘭&apos;,&apos;二結&apos;,&apos;羅東&apos;,&apos;冬山&apos;,&apos;新馬&apos;]</span><br><span class="line">station=station[station[&apos;Station_Na&apos;].isin(station_list)]</span><br><span class="line">station=station.reset_index(drop=True)</span><br><span class="line">station</span><br></pre></td></tr></table></figure><p>最後的是對話資料<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd </span><br><span class="line">talk=pd.read_csv(&apos;output/talk.csv&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">talk[&apos;time&apos;]=[row[&apos;time&apos;][:-2]+&quot;00&quot; for idx,row in talk.iterrows()]</span><br><span class="line">talk</span><br></pre></td></tr></table></figure></p><p>接下來，我們把原始的路線資料切成通訊對話逐字稿的模式，這裡會用到graph的資訊計算，</p><ul><li>把polyline換算成graph</li><li>分別把車站設為起終點，計算路徑</li><li>例如在graph輸入宜蘭最近的node及羅東站最近的node,計算的得到這兩個站的路線<br>會採用這樣的做法是臨時決定的&gt;.&lt; 說不定改天有更好的做法<br>細節今天就先跳過，過幾天會講到，反正最終結果是要把polyline變成像是</li></ul><p><code>福隆-貢寮</code> 或是 <code>宜蘭-二結</code>的這種模式的線</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">## 這邊先手動整理對照表(對照上表)</span><br><span class="line">routes=[[9,10],</span><br><span class="line">[3,4],</span><br><span class="line">[3,3],</span><br><span class="line">[2,3],</span><br><span class="line">[6,7],</span><br><span class="line">[6,6],</span><br><span class="line">[0,2],</span><br><span class="line">[8,9] ,   </span><br><span class="line">[1,0],</span><br><span class="line">[4,5]]  </span><br><span class="line"></span><br><span class="line">from shapely.geometry import LineString,Point</span><br><span class="line">from s2g import ShapeGraph</span><br><span class="line">import networkx as nx</span><br><span class="line">sg = ShapeGraph(shapefile=&apos;output/Rail_yilan.shp&apos;, to_graph=True)</span><br><span class="line">graph = sg.to_networkx()</span><br><span class="line"></span><br><span class="line">line_gs=[]</span><br><span class="line">line_name=[]</span><br><span class="line">for route in routes:</span><br><span class="line"></span><br><span class="line">    min_distance=999</span><br><span class="line">    start_id=0</span><br><span class="line">    for num in range(sg.nodes_counter):</span><br><span class="line">        xy=sg.node_xy[num]</span><br><span class="line">        if Point(xy).distance(station.at[route[0],&apos;geometry&apos;])&lt;min_distance:</span><br><span class="line">            min_distance=Point(xy).distance(station.at[route[0],&apos;geometry&apos;])</span><br><span class="line">            start_id=num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    min_distance=999</span><br><span class="line">    end_id=0</span><br><span class="line">    for num in range(sg.nodes_counter):</span><br><span class="line">        xy=sg.node_xy[num]</span><br><span class="line">        if Point(xy).distance(station.at[route[1],&apos;geometry&apos;])&lt;min_distance:</span><br><span class="line">            min_distance=Point(xy).distance(station.at[route[1],&apos;geometry&apos;])</span><br><span class="line">            end_id=num</span><br><span class="line">            nearest_path= nx.shortest_path(graph, source=start_id, target=end_id)</span><br><span class="line">    geoms=[]</span><br><span class="line">    for item in nearest_path:</span><br><span class="line">            geoms.append(sg.node_xy[item])</span><br><span class="line">    try:</span><br><span class="line">        line_gs.append(LineString(geoms))</span><br><span class="line">        line_name.append(&quot;（地點：&quot;+station.at[route[0],&apos;Station_Na&apos;]+&quot;-&quot;+station.at[route[1],&apos;Station_Na&apos;]+&quot;)&quot;)</span><br><span class="line">    except:pass</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">train_lines = gpd.GeoDataFrame(crs= &#123;&apos;init&apos; :&apos;epsg:4326&apos;&#125;,geometry=line_gs)</span><br><span class="line">train_lines[&apos;location&apos;]=line_name</span><br><span class="line">train_lines</span><br></pre></td></tr></table></figure><p>以下是我們要的路線整合結果：<br><img src="https://ithelp.ithome.com.tw/upload/images/20181028/201078160IMKGXYicV.png" alt="https://ithelp.ithome.com.tw/upload/images/20181028/201078160IMKGXYicV.png"></p><p>最後整合對話與路線，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 初始化</span><br><span class="line">talk[&apos;geometry&apos;]=talk[&apos;location&apos;]</span><br><span class="line">for i1,r1 in talk.iterrows():</span><br><span class="line">    for i2,r2 in  train_lines.iterrows():</span><br><span class="line">        if r1[&apos;location&apos;]==r2[&apos;location&apos;]:</span><br><span class="line">            talk.at[i1,&apos;geometry&apos;]=r2[&apos;geometry&apos;]</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            talk.at[i1,&apos;geometry&apos;]=talk.at[0,&apos;geometry&apos;]</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">st=talk.at[0,&apos;time&apos;]</span><br><span class="line">temp_text=&quot;&quot;         </span><br><span class="line">geoms=[]</span><br><span class="line">temp_location=talk.at[0,&apos;location&apos;]</span><br><span class="line">for i1,r1 in talk.iterrows():</span><br><span class="line">    if temp_location!=talk.at[i1,&apos;location&apos;]:</span><br><span class="line">        geoms.append([talk.at[i1-1,&apos;geometry&apos;],[st,talk.at[i1-1,&apos;time&apos;]],talk.at[i1-1,&apos;location&apos;],temp_text])</span><br><span class="line">       </span><br><span class="line">        ##release</span><br><span class="line">        temp_location=talk.at[i1,&apos;location&apos;]</span><br><span class="line">        temp_text=&quot;&quot; </span><br><span class="line">        st=talk.at[i1,&apos;time&apos;]</span><br><span class="line">    else:</span><br><span class="line">        temp_text+=talk.at[i1,&apos;content&apos;]+&quot;;&quot;</span><br><span class="line">geoms.append([talk.at[i1,&apos;geometry&apos;],[st,talk.at[i1,&apos;time&apos;]],talk.at[i1,&apos;location&apos;],temp_text])      </span><br><span class="line">train_lines_talk= gpd.GeoDataFrame(geoms)</span><br><span class="line">train_lines_talk.columns=[&apos;geometry&apos;,&apos;time&apos;,&apos;location&apos;,&apos;text&apos;]</span><br><span class="line">train_lines_talk</span><br></pre></td></tr></table></figure></p><p>最終成果：<br><img src="https://ithelp.ithome.com.tw/upload/images/20181028/20107816JHBMzwq4Ud.png" alt="https://ithelp.ithome.com.tw/upload/images/20181028/20107816JHBMzwq4Ud.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天做了一些前處理，&lt;br&gt;今天把昨天的處理好的資料做整合&lt;/p&gt;
&lt;p&gt;首先是宜蘭縣鐵道(polyline)&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import geopandas as gpd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rail_yilan=gpd.read_file(&amp;apos;output/Rail_yilan.shp&amp;apos;,encoding=&amp;apos;utf-8&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rail_yilan&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day11 台鐵意外事件與folium練習-前處理</title>
    <link href="https://chimin17.github.io/2018/10/26/ironman-2019-day11/"/>
    <id>https://chimin17.github.io/2018/10/26/ironman-2019-day11/</id>
    <published>2018-10-26T13:39:55.000Z</published>
    <updated>2018-11-02T02:16:19.966Z</updated>
    
    <content type="html"><![CDATA[<p>最近的台鐵意外事件，看到有媒體及網友製作前端的網頁地圖呈現通話紀錄，剛好昨天使用了folium，一時興起今天也來用folium做看看，今天先來做一些前處理</p><blockquote><p>ps. 另外，也祝傷者平安及亡者安息</p></blockquote><a id="more"></a><h3 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h3><p>要呈現這樣的圖，包括了以下幾種資料：</p><ul><li><a href="https://data.gov.tw/dataset/73220" target="_blank" rel="noopener">臺灣鐵路 | 政府資料開放平臺</a></li><li><a href="https://www.railway.gov.tw/Upload/UserFiles/%E8%BB%8A%E7%AB%99%E5%9F%BA%E6%9C%AC%E8%B3%87%E6%96%99.json" target="_blank" rel="noopener">台鐵車站基本資料</a>（<a href="https://www.railway.gov.tw/tw/CP.aspx?sn=16938&amp;n=19573" target="_blank" rel="noopener">台鐵</a>）</li><li><a href="https://news.ftv.com.tw/AMP/News_Amp.aspx?id=2018A25W0003" target="_blank" rel="noopener">普悠瑪翻車前257句43分鐘對話曝光！ 司機一路求援邊開邊修-民視新聞網</a></li></ul><h3 id="逐字稿文字資料整理"><a href="#逐字稿文字資料整理" class="headerlink" title="逐字稿文字資料整理"></a>逐字稿文字資料整理</h3><p>網站上的逐字稿在上面的新聞網站可以看到<br><img src="https://ithelp.ithome.com.tw/upload/images/20181026/20107816cLUgXXES29.png" alt="https://ithelp.ithome.com.tw/upload/images/20181026/20107816cLUgXXES29.png"></p><p>我們試著把它結構化，我們使用requests去get網頁文檔，並用BeautifulSoup結構化資料<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import pandas as pd </span><br><span class="line">import geopandas as gpd</span><br><span class="line">import re</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">result=requests.get(&apos;https://news.ftv.com.tw/AMP/News_Amp.aspx?id=2018A25W0003&apos;)</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(result.text, &apos;html.parser&apos;)</span><br></pre></td></tr></table></figure></p><p>有關這些技術細節，請參考以下程式碼<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">p_count=0</span><br><span class="line">start_flag=False</span><br><span class="line">p_contents=soup.find_all(&apos;p&apos;)</span><br><span class="line">all_data=[]</span><br><span class="line">location=&quot;&quot;</span><br><span class="line">time=&quot;&quot;</span><br><span class="line">for p_item in p_contents:</span><br><span class="line">    </span><br><span class="line">    text=str(p_item.text)</span><br><span class="line">    if text ==&apos;完整通聯紀錄：&apos;:</span><br><span class="line">        start_flag=True</span><br><span class="line">        p_count+=1</span><br><span class="line">        continue</span><br><span class="line">    </span><br><span class="line">    if len(re.findall(&apos;地點&apos;,text))&gt;0:</span><br><span class="line">        location=text</span><br><span class="line">        continue</span><br><span class="line">        </span><br><span class="line">    if len(text.split(&apos;:&apos;))==3 and len(text)==8:</span><br><span class="line">        time=text</span><br><span class="line">        continue</span><br><span class="line">            </span><br><span class="line">    # 處理前幾行</span><br><span class="line">    if start_flag==True:</span><br><span class="line">        if  p_count&lt;4:</span><br><span class="line">            p_count+=1</span><br><span class="line">            time=text[0:8]</span><br><span class="line">            all_data.append([location,time,text[8:]])</span><br><span class="line">        else:</span><br><span class="line">            all_data.append([location,time,text])</span><br><span class="line">       </span><br><span class="line">all_data</span><br></pre></td></tr></table></figure></p><p>整理好會變這樣<br><img src="https://ithelp.ithome.com.tw/upload/images/20181026/20107816B55Kmp8FJ5.png" alt="https://ithelp.ithome.com.tw/upload/images/20181026/20107816B55Kmp8FJ5.png"></p><h3 id="整合車站資料與路線"><a href="#整合車站資料與路線" class="headerlink" title="整合車站資料與路線"></a>整合車站資料與路線</h3><p>首先，我們把車站資料處理成GIS資料，利用pandas2geopandas的技巧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from shapely.geometry import Point</span><br><span class="line">station_pd=pd.read_json(&apos;data/Station/Station.json&apos;, &apos;r&apos;, encoding=&apos;utf-8-sig&apos;)</span><br><span class="line">station_pd=station_pd[station_pd[&apos;gps&apos;]!=&apos;&apos;]</span><br><span class="line">y = [float(row[&apos;gps&apos;].split(&apos;,&apos;)[0].replace(&apos; &apos;,&apos;&apos;)) for idx,row in station_pd.iterrows()]</span><br><span class="line">x = [float(row[&apos;gps&apos;].split(&apos;,&apos;)[1].replace(&apos; &apos;,&apos;&apos;)) for idx,row in station_pd.iterrows()]</span><br><span class="line">geom = [Point(xy) for xy in zip(x, y)]</span><br><span class="line">crs = &#123;&apos;init&apos;: &apos;epsg:4326&apos;&#125;</span><br><span class="line">station = gpd.GeoDataFrame(station_pd, crs=crs, geometry=geom)</span><br><span class="line">station[[&apos;Station_Name&apos;,&apos;geometry&apos;]].to_file(&apos;output/station.shp&apos;)</span><br><span class="line">station</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181026/20107816kroJtDUgtw.png" alt="https://ithelp.ithome.com.tw/upload/images/20181026/20107816kroJtDUgtw.png"></p><p>然後把第一天出現過的鐵路資料再拿來，並且選擇<code>臺鐵宜蘭線</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rail=gpd.read_file(&apos;data/Rail/Rail.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">rail.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; # 避免資料沒設，這邊再重新給一次</span><br><span class="line">rail=rail.to_crs(epsg=4326)</span><br><span class="line"># rail.groupby(&apos;RAILNAME&apos;).size()</span><br><span class="line">rail=rail[rail[&apos;RAILNAME&apos;]==&apos;臺鐵宜蘭線&apos;]</span><br><span class="line">rail.reset_index(inplace=True)</span><br><span class="line">rail</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181026/20107816PBY1KZVxgN.png" alt="https://ithelp.ithome.com.tw/upload/images/20181026/20107816PBY1KZVxgN.png"></p><p>先觀察一下資料，我們把他們一起畫在地圖上瀏覽：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import folium</span><br><span class="line">m = folium.Map((24.694192,121.775163),zoom_start=18)</span><br><span class="line"></span><br><span class="line">folium.GeoJson(</span><br><span class="line">    station.to_json(),</span><br><span class="line">    name=&apos;geojson&apos;</span><br><span class="line">).add_to(m)</span><br><span class="line"></span><br><span class="line">rail_geojson  = folium.GeoJson(</span><br><span class="line">    rail.to_json(),</span><br><span class="line">    name=&apos;geojson&apos;,</span><br><span class="line"> </span><br><span class="line">)</span><br><span class="line">popup = folium.Popup(&apos;Hi&apos;)</span><br><span class="line">popup.add_to(rail_geojson)</span><br><span class="line">rail_geojson.add_to(m)</span><br><span class="line"></span><br><span class="line">m</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181026/201078169VVve0jLrr.png" alt="https://ithelp.ithome.com.tw/upload/images/20181026/201078169VVve0jLrr.png"></p><p>由於車站的資料與鐵路資料有一點gap，也就是說車站的點不會在鐵路線上，這會影響到展示，<br>因此，我們試著把他投影到線上，這邊的投影我們直接使用向量內外積來處理：<br><img src="https://ithelp.ithome.com.tw/upload/images/20181026/20107816A6oajmkggD.png" alt="https://ithelp.ithome.com.tw/upload/images/20181026/20107816A6oajmkggD.png"></p><p>計算過程中，我們把每個元素的投影都算一遍，並取距離最短的點，作為車站修正後的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from shapely.geometry import Point</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i1,r1 in station.iterrows():</span><br><span class="line">    point=r1[&apos;geometry&apos;]</span><br><span class="line">    min_distance=999</span><br><span class="line">    new_point=point</span><br><span class="line">    for i2,r2 in rail.iterrows():</span><br><span class="line"></span><br><span class="line">        line = r2[&apos;geometry&apos;]</span><br><span class="line"></span><br><span class="line">        x = np.array(point.coords[0])</span><br><span class="line"></span><br><span class="line">        u = np.array(line.coords[0])</span><br><span class="line">        v = np.array(line.coords[len(line.coords)-1])</span><br><span class="line"></span><br><span class="line">        n = v - u</span><br><span class="line">        n /= np.linalg.norm(n, 2)</span><br><span class="line"></span><br><span class="line">        P = u + n*np.dot(x - u, n)</span><br><span class="line">        distance=Point(P).distance(point)</span><br><span class="line">        if distance&lt;min_distance:</span><br><span class="line">            min_distance=distance</span><br><span class="line">            new_point=Point(P)</span><br><span class="line">    station.at[i1,&apos;geometry&apos;]=new_point</span><br></pre></td></tr></table></figure></p><p>還有另外一種解法，在<code>第七天</code>的時候我們提到<code>shapely</code>的<code>project</code>與<code>interpolate</code><br>這兩個連續技，結果跟上面是一樣的<br><code>new_point = line.interpolate(line.project(point))</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for i1,r1 in station.iterrows():</span><br><span class="line">    point=r1[&apos;geometry&apos;]</span><br><span class="line">    min_distance=999</span><br><span class="line">    new_point=point</span><br><span class="line">    for i2,r2 in rail.iterrows():</span><br><span class="line"></span><br><span class="line">        line = r2[&apos;geometry&apos;]</span><br><span class="line">        temp_point = line.interpolate(line.project(point))</span><br><span class="line">        distance=temp_point.distance(point)</span><br><span class="line">        if distance&lt;min_distance:</span><br><span class="line">            min_distance=distance</span><br><span class="line">            new_point=temp_point</span><br><span class="line">    station.at[i1,&apos;geometry&apos;]=new_point</span><br></pre></td></tr></table></figure></p><p>上面的方法二選一，再用前面的code繪製一次成果，可以看到車站已經被修正在鐵路網上！<br><img src="https://ithelp.ithome.com.tw/upload/images/20181026/20107816JWxh417cbh.png" alt="https://ithelp.ithome.com.tw/upload/images/20181026/20107816JWxh417cbh.png"></p><h3 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h3><p>今天我們完成了一些前處理<br>雖然這些前處理其實有些也沒這麼必要，甚至手動畫一畫就好了，不過基於練習的精神還是明天繼續把它完成吧<br>下班時間有點晚，明天再加油！</p><blockquote><p>對今天的測試有興趣請參考<a href="https://github.com/chimin17/2019_30day/blob/master/Day11_TWNRAIL_folium_part1.ipynb" target="_blank" rel="noopener">github程式碼</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近的台鐵意外事件，看到有媒體及網友製作前端的網頁地圖呈現通話紀錄，剛好昨天使用了folium，一時興起今天也來用folium做看看，今天先來做一些前處理&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ps. 另外，也祝傷者平安及亡者安息&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day10 地圖互動folium</title>
    <link href="https://chimin17.github.io/2018/10/25/ironman-2019-day10/"/>
    <id>https://chimin17.github.io/2018/10/25/ironman-2019-day10/</id>
    <published>2018-10-25T12:23:10.000Z</published>
    <updated>2018-11-02T02:16:21.702Z</updated>
    
    <content type="html"><![CDATA[<p><code>folium</code>是基於leaflet.js的python地圖套件，讓使用者可以很快速的使用python產生一些可互動的地圖。<br>我們可以很方便把加工後的GIS資料丟進去，並完成一個網頁地圖。</p><blockquote><p>leaflet: <a href="https://ithelp.ithome.com.tw/articles/10194830" target="_blank" rel="noopener">[Day 13] WebGIS中的向量資料-在Leaflet實作 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天</a></p></blockquote><p>以下我們就快速來試一試</p><a id="more"></a><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><blockquote><p>安裝 folium<br>conda install -c conda-forge folium </p></blockquote><p>初始化地圖<br>初始化地圖要指定地圖中心的經緯度坐標，跟比例尺(zomm_start)<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import folium</span><br><span class="line">m = folium.Map((25.0133904,121.52245),zoom_start=14)</span><br><span class="line">m</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181025/20107816JJuymkhfJt.png" alt="https://ithelp.ithome.com.tw/upload/images/20181025/20107816JJuymkhfJt.png"></p><p>folium內建一些基本的WMTS，使用<code>tiles</code>，我們把它換成使用<code>Cartodb Positron</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m = folium.Map((25.0133904,121.52245), tiles=&quot;Cartodb Positron&quot;,zoom_start=14)</span><br><span class="line">m</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181025/201078160s7ArzQK5C.png" alt="https://ithelp.ithome.com.tw/upload/images/20181025/201078160s7ArzQK5C.png"></p><p>當然，還有很多其他選擇，有需要的人可以自行參考</p><h3 id="加入向量資料"><a href="#加入向量資料" class="headerlink" title="加入向量資料"></a>加入向量資料</h3><p>folium的操作沒有很複雜，如果要加入向量資料，操作起來跟leaflet很像。</p><p>例如我們增加一個marker然後設定style及popup<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">m = folium.Map((25.0133904,121.52245),zoom_start=14)</span><br><span class="line">folium.CircleMarker(</span><br><span class="line">    location=[25.0133904,121.52245],</span><br><span class="line">    radius=20,</span><br><span class="line">    popup=&apos;永和&apos;,</span><br><span class="line">    color=&apos;#3186cc&apos;,</span><br><span class="line">    fill=True,</span><br><span class="line">    fill_color=&apos;#3186cc&apos;</span><br><span class="line">).add_to(m)</span><br><span class="line">m</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181025/20107816fEhqTioBMW.png" alt="https://ithelp.ithome.com.tw/upload/images/20181025/20107816fEhqTioBMW.png"></p><p>若要丟整份資料，folium使用的格式是geojson，如果是Geopandas處理的資料，可以使用<code>to_json()</code>這個方法將資料餵進去。</p><p>再次以新北的村里界資料為範例<br>先把資料準備好並轉好坐標系統為epsg4326<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import geopandas as gpd</span><br><span class="line">village=gpd.read_file(&apos;data/village/village.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">village=village[village.is_valid]</span><br><span class="line">village=village[village[&apos;ADMIT&apos;]==&apos;永和區&apos;]</span><br><span class="line">village.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; # 避免資料沒設，這邊再重新給一次</span><br><span class="line">village=village.to_crs(epsg=4326)</span><br><span class="line">village=village.reset_index()</span><br></pre></td></tr></table></figure></p><p>處理好的資料是GeoDataFrame丟進去，可以用to_json轉為geojson<br>並直接丟進去folium</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m = folium.Map((25.0133904,121.52245),zoom_start=14)</span><br><span class="line">folium.GeoJson(</span><br><span class="line">    village.to_json(),</span><br><span class="line">    name=&apos;geojson&apos;</span><br><span class="line">).add_to(m)</span><br><span class="line">m</span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20181025/20107816HG0BOrqSk6.png" alt="https://ithelp.ithome.com.tw/upload/images/20181025/20107816HG0BOrqSk6.png"></p><p>如果要增加圖層開關，讓瀏覽的時候比較方便，可以加入LayerControl(用法跟leaflet差不多)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">folium.LayerControl().add_to(m)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181025/20107816vvcy7RYzNX.png" alt="https://ithelp.ithome.com.tw/upload/images/20181025/20107816vvcy7RYzNX.png"></p><h3 id="做個時序地圖"><a href="#做個時序地圖" class="headerlink" title="做個時序地圖"></a>做個時序地圖</h3><p>folium有一個滿好用的套件<code>TimeSliderChoropleth</code>，<br>可以快速做一個時間序列的資料展示<br>他的基本操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = TimeSliderChoropleth(</span><br><span class="line">    village.to_json(),</span><br><span class="line">    styledict = styledict,  </span><br><span class="line">).add_to(m)</span><br></pre></td></tr></table></figure></p><p>其中，styledict定義的是時序資料的值<br>餵進去的資料需要按照要求<br>為了演示，我們針對village隨機產生時序資料<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">n_periods = 24</span><br><span class="line">n_sample = 12</span><br><span class="line">assert n_sample &lt; n_periods</span><br><span class="line">dt_index = pd.date_range(&apos;2012-1-1&apos;, periods = n_periods, freq=&apos;M&apos;).strftime(&apos;%s&apos;)</span><br><span class="line">styledata = &#123; &#125;</span><br><span class="line"></span><br><span class="line">for item in village.index: </span><br><span class="line">    df = pd.DataFrame(&#123;&apos;color&apos;: np.random.normal(size=n_periods), </span><br><span class="line">                       &apos;opacity&apos;: np.random.normal(size=n_periods)&#125;,</span><br><span class="line">                      index = dt_index)</span><br><span class="line">    df = df.cumsum()</span><br><span class="line">    df.sample(n_sample, replace=False).sort_index()</span><br><span class="line">    styledata[item] = df</span><br><span class="line"></span><br><span class="line">styledict = &#123;str(country): data.to_dict(orient=&apos;index&apos;) for </span><br><span class="line">             country, data in styledata.items()&#125;</span><br></pre></td></tr></table></figure></p><p>產生的資料結構是長這樣<br><img src="https://ithelp.ithome.com.tw/upload/images/20181025/20107816epB85W0rAc.png" alt="https://ithelp.ithome.com.tw/upload/images/20181025/20107816epB85W0rAc.png"></p><p>我們把向量圖丟進去，<br>並把上面產生的styledict也放進去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from folium.plugins import TimeSliderChoropleth</span><br><span class="line">m = folium.Map((25.0133904,121.52245), tiles=&quot;Cartodb Positron&quot;,zoom_start=14)</span><br><span class="line">g = TimeSliderChoropleth(</span><br><span class="line">    village.to_json(),</span><br><span class="line">    styledict = styledict,</span><br><span class="line">    </span><br><span class="line">).add_to(m)</span><br><span class="line"></span><br><span class="line">m</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181025/201078164mrDypE8Q3.png" alt="https://ithelp.ithome.com.tw/upload/images/20181025/201078164mrDypE8Q3.png"></p><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="http://python-visualization.github.io/folium/" target="_blank" rel="noopener">folium</a></p><h3 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h3><p>folium還很很多功能，可以講個好幾天，之後幾天有機會再多看看吧！</p><blockquote><p>今天的練習請參考<a href="https://github.com/chimin17/2019_30day/blob/master/Day10%08_folium.ipynb" target="_blank" rel="noopener">github</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;folium&lt;/code&gt;是基於leaflet.js的python地圖套件，讓使用者可以很快速的使用python產生一些可互動的地圖。&lt;br&gt;我們可以很方便把加工後的GIS資料丟進去，並完成一個網頁地圖。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;leaflet: &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10194830&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[Day 13] WebGIS中的向量資料-在Leaflet實作 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下我們就快速來試一試&lt;/p&gt;
    
    </summary>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day09 使用GeoPlot</title>
    <link href="https://chimin17.github.io/2018/10/24/ironman-2019-day09/"/>
    <id>https://chimin17.github.io/2018/10/24/ironman-2019-day09/</id>
    <published>2018-10-24T14:13:33.000Z</published>
    <updated>2018-11-02T02:16:28.787Z</updated>
    
    <content type="html"><![CDATA[<p>另外一個GIS資料畫圖的利器是Geoplot，它擴充了cartopy與matplotlib，讓GIS資料的視覺化更方便，當然，他也設計給Geopandas作為其資料的端口。</p><blockquote><p>有關geoplot的安裝，使用annaconda：<br>conda install geoplot -c conda-forge</p></blockquote><a id="more"></a><h3 id="點資料"><a href="#點資料" class="headerlink" title="點資料"></a>點資料</h3><p>首先是geoplot的pointplot模組，先來簡單plot點資料，並以顏色來區分行政區</p><p>一樣使用路燈資料，<code>轉到epsg4326</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import geopandas as gpd</span><br><span class="line">light=gpd.read_file(&apos;output/light.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">light=light[light.is_valid]</span><br><span class="line">light=light[light[&apos;district&apos;]==&apos;永和區&apos;]</span><br><span class="line">light.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; # 避免資料沒設，這邊再重新給一次</span><br><span class="line">light=light.to_crs(epsg=4326)</span><br></pre></td></tr></table></figure></p><p>geoplot對GeoDataframe有支援，所以可以直接餵進去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import geoplot as gplt</span><br><span class="line">gplt.pointplot(light, figsize=(16, 8))</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181024/201078165ZWiIcuvyI.png" alt="https://ithelp.ithome.com.tw/upload/images/20181024/201078165ZWiIcuvyI.png"><br>在geolot中，可以設定投影(import geoplot.crs)<br>另外，geoplot.點資料pointplot，可以設定視覺變數，<br>包含scale、hue都以作為視覺變數</p><p>為了測試，我們先用<code>numpy</code>隨機產生一個值year(假設是路燈的使用年數)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">light[&apos;year&apos;]=np.random.randint(low=0,high=20,size=light.shape[0])</span><br></pre></td></tr></table></figure></p><p>以hue(顏色)繪圖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gplt.pointplot(light, hue=&apos;year&apos;, figsize=(16, 8))</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181024/20107816Pru2k5G2px.png" alt="https://ithelp.ithome.com.tw/upload/images/20181024/20107816Pru2k5G2px.png"><br>geoplot中也可以改變schema與投影，也可以放上圖例，跟昨天的mapplotib類似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import geoplot.crs as gcrs</span><br><span class="line">gplt.pointplot(light, projection=gcrs.AlbersEqualArea(), hue=&apos;year&apos;, legend=True, scheme=&apos;fisher_jenks&apos;, figsize=(16, 8))</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181024/20107816uCeY3jHHAL.png" alt="https://ithelp.ithome.com.tw/upload/images/20181024/20107816uCeY3jHHAL.png"></p><p>試著以scale作為視覺變數<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gplt.pointplot(light, projection=gcrs.AlbersEqualArea(), scale=&apos;year&apos;, legend=True ,limits=(0, 8), figsize=(16, 8))</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181024/201078167D1dY7PEBP.png" alt="https://ithelp.ithome.com.tw/upload/images/20181024/201078167D1dY7PEBP.png"></p><p>如果想要混和兩種視覺變數也可以，<br>我們多產生一個<code>size</code>，跟<code>year</code>一起呈現<br>例如我們以顏色及scale來呈現資料<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">light[&apos;size&apos;]=np.random.randint(low=0,high=5,size=light.shape[0])</span><br><span class="line">gplt.pointplot(light, projection=gcrs.AlbersEqualArea(),hue=&apos;size&apos;, scale=&apos;year&apos;, legend=True ,limits=(0, 8), figsize=(40, 32))</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181024/20107816wMJhooX5XT.png" alt="https://ithelp.ithome.com.tw/upload/images/20181024/20107816wMJhooX5XT.png"></p><h3 id="面量圖"><a href="#面量圖" class="headerlink" title="面量圖"></a>面量圖</h3><p>geolpot拿來畫面量圖也是頗方便<br>我們拿村里圖來測試一下(用x上色= =’’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">village=gpd.read_file(&apos;data/village/village.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">village=village[village.is_valid]</span><br><span class="line">village=village[village[&apos;ADMIT&apos;]==&apos;永和區&apos;]</span><br><span class="line">village.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; # 避免資料沒設，這邊再重新給一次</span><br><span class="line">village=village.to_crs(epsg=4326)</span><br><span class="line">gplt.choropleth(village, hue=&apos;X&apos;, projection=gcrs.AlbersEqualArea(),</span><br><span class="line">        legend=True, edgecolor=&apos;white&apos;,   scheme=&apos;equal_interval&apos;,figsize=(16, 8))</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181024/20107816NwyqrF9RMe.png" alt="https://ithelp.ithome.com.tw/upload/images/20181024/20107816NwyqrF9RMe.png"><br>也可以畫累積圖(重現前幾天的圖~)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">result=gpd.tools.sjoin(light[[&apos;geometry&apos;,&apos;year&apos;,&apos;size&apos;]], village[[&apos;ADMIV&apos;,&apos;ADMIT&apos;,&apos;geometry&apos;]], op=&apos;within&apos;,how=&quot;right&quot;)</span><br><span class="line">result[&apos;count&apos;]=1</span><br><span class="line">result=result.dissolve(by=&apos;ADMIV&apos;, aggfunc=&apos;sum&apos;)</span><br><span class="line">result[&apos;year&apos;]=result[&apos;year&apos;]/result[&apos;count&apos;]</span><br><span class="line">result[&apos;size&apos;]=result[&apos;size&apos;]/result[&apos;count&apos;]</span><br><span class="line">gplt.choropleth(result, hue=&apos;count&apos;, projection=gcrs.AlbersEqualArea(),</span><br><span class="line">        legend=True, edgecolor=&apos;white&apos;, linewidth=0.5,  scheme=&apos;equal_interval&apos;,figsize=(16, 8))</span><br></pre></td></tr></table></figure></p><p>或者是另外一種方式呈現資訊<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax =gplt.polyplot(village,projection=gcrs.AlbersEqualArea(), figsize=(16, 8))</span><br><span class="line">gplt.pointplot(light,ax=ax,projection=gcrs.AlbersEqualArea(),  hue=&apos;year&apos;, legend=True)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181024/20107816FQb24mev1q.png" alt="https://ithelp.ithome.com.tw/upload/images/20181024/20107816FQb24mev1q.png"></p><h3 id="熱區圖"><a href="#熱區圖" class="headerlink" title="熱區圖"></a>熱區圖</h3><p>geoplot有heatmap的功能kdeplot<br>熱區圖計算的是Kernel density，計算核密度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax =gplt.polyplot(result,projection=gcrs.AlbersEqualArea(), figsize=(16, 8))</span><br><span class="line">ax=gplt.kdeplot(light,ax=ax,shade=True,projection=gcrs.AlbersEqualArea(),shade_lowest=False)</span><br></pre></td></tr></table></figure></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20181024/20107816HFa189dhZH.png" alt="https://ithelp.ithome.com.tw/upload/images/20181024/20107816HFa189dhZH.png"></p><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://residentmario.github.io/geoplot/gallery.html" target="_blank" rel="noopener">Gallery — geoplot 0.2.0 documentation</a></p><blockquote><p><a href="http://localhost:8888/notebooks/Day09_geoplot.ipynb" target="_blank" rel="noopener">今天的相關測試可以參考GitHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;另外一個GIS資料畫圖的利器是Geoplot，它擴充了cartopy與matplotlib，讓GIS資料的視覺化更方便，當然，他也設計給Geopandas作為其資料的端口。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有關geoplot的安裝，使用annaconda：&lt;br&gt;conda install geoplot -c conda-forge&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day08 GIS資料基本繪圖</title>
    <link href="https://chimin17.github.io/2018/10/23/ironman-2019-day08/"/>
    <id>https://chimin17.github.io/2018/10/23/ironman-2019-day08/</id>
    <published>2018-10-23T15:03:57.000Z</published>
    <updated>2018-11-02T02:16:26.529Z</updated>
    
    <content type="html"><![CDATA[<p>前幾天我們也有利用<code>Geopandas</code>裡面包的<code>matplotlib</code>做一些基本的繪圖<br>GIS資料很常出現在日常生活的資訊視覺化，除了在資料工程上用在<code>Data wrangling</code>外，資料視覺化扮演著資訊發布的重任，GIS或是地圖的視覺化的學習與資源非常的多，今天我們以<code>matplotlib</code>，討論一下GIS資料視覺化的一些要素。</p><a id="more"></a><h3 id="投影的選擇"><a href="#投影的選擇" class="headerlink" title="投影的選擇"></a>投影的選擇</h3><p>坐標、投影原本就是GIS資料始終圍繞的主題，<br>前面幾天提到坐標轉換，大多時候我們必須要把不同坐標系統的資料轉到同一個系統，才能一起做資料分析及處理<br>在展示地圖時，也要面臨投影的問題<br>因為地球是近似橢圓，地圖的製作實際上是將全部或局部的地球投影在面上，<br>凡是投影都會有誤差，地圖上的投影會造成幾何的扭曲</p><p>使用matplotlib的<code>basemap</code>試著說明這些，<br>首先，繪製全球海岸線的圖<br>在產生basemap時，要先設定投影projection=’merc’，<code>merc</code>就是麥卡托投影<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from mpl_toolkits.basemap import Basemap</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">plt.figure(figsize=(16,8))</span><br><span class="line">m = Basemap(projection=&apos;merc&apos;,urcrnrlat=80, llcrnrlat=-80,llcrnrlon=-180, urcrnrlon=180)  </span><br><span class="line">m.drawcoastlines(color=&apos;#0066CC&apos;)</span><br></pre></td></tr></table></figure></p><p>為了方便觀察，加入繪製經緯線<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Draw lines of latitude (parallels) and longitude (meridians)</span><br><span class="line">m.drawparallels(range(-90,91,30), color=&apos;#CCCCCC&apos;)</span><br><span class="line">m.drawmeridians(range(-180,181,60), color=&apos;#CCCCCC&apos;)</span><br></pre></td></tr></table></figure></p><p>為了理解投影的變形與誤差，我們可以在圖上繪製Tissot’s Indicatrix(底索變形橢圓)<br>圓(橢圓)的變化代表的就是投影方法在不同區域造成的變形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># draw tissot&apos;s indicatrix to show distortion.</span><br><span class="line">for y in np.linspace(m.ymax/20, 19*m.ymax/20, 9):</span><br><span class="line">    for x in np.linspace(m.xmax/20, 19*m.xmax/20, 9):</span><br><span class="line">        lon, lat = m(x,y,inverse=True)</span><br><span class="line">        poly = m.tissot(lon, lat, 1.5, 100, facecolor=&apos;#2ca25f&apos;, zorder=10, alpha=0.6);</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/23/ironman-2019-day08/834403ff.png" alt="Screen Shot 2018-10-23 at 19.47.40.png"></p><p>可以看到，在不同緯度，麥卡托投影對於全球不同地區有著不同程度的變形，<br>我們在呈現資料時，特別是大範圍的資料，變形是必須面對的，當然適度的變形也是滿美的。</p><p>關於投影，這邊提供另外一個例子，適用在南北極的極投影npstere(North-Polar Stereographic)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(16,8))</span><br><span class="line">m = Basemap(projection=&apos;npstere&apos;,boundinglat=10,lon_0=270,resolution=&apos;l&apos;)</span><br><span class="line">m.drawcoastlines()</span><br><span class="line">m.drawparallels(np.arange(-80.,81.,20.))</span><br><span class="line">m.drawmeridians(np.arange(-180.,181.,20.))</span><br><span class="line"></span><br><span class="line">for y in np.linspace(m.ymax/20,19*m.ymax/20,10):</span><br><span class="line">    for x in np.linspace(m.xmax/20,19*m.xmax/20,10):</span><br><span class="line">        lon, lat = m(x,y,inverse=True)</span><br><span class="line">        poly = m.tissot(lon,lat,2.5,100,\</span><br><span class="line">                        facecolor=&apos;#2ca25f&apos;,zorder=10,alpha=0.5)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2018/10/23/ironman-2019-day08/5953a086.png" alt="Screen Shot 2018-10-23 at 21.03.15.png"></p><p>接著是美國，以蘭伯特等方位投影(Lambert Azimuthal Equal Area)呈現<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(16,8))</span><br><span class="line">m = Basemap(width=5e6,height=3e6,projection=&apos;laea&apos;,boundinglat=10,</span><br><span class="line">        resolution=&apos;c&apos;,lat_0=39, lon_0=-96)</span><br><span class="line">m.drawcoastlines()</span><br><span class="line">m.drawcountries()</span><br><span class="line">m.drawstates()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/23/ironman-2019-day08/e16ca5ba.png" alt="Screen Shot 2018-10-23 at 21.24.01.png"><br>如果改以蘭伯特投影呈現，會有不同的效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(16,8))</span><br><span class="line">plt.figure()</span><br><span class="line">m = Basemap(</span><br><span class="line">    llcrnrlon=-119,</span><br><span class="line">    llcrnrlat=22,</span><br><span class="line">    urcrnrlon=-64,</span><br><span class="line">    urcrnrlat=49,</span><br><span class="line">    projection=&apos;lcc&apos;,</span><br><span class="line">    lat_1=39,</span><br><span class="line">    lon_0=-98</span><br><span class="line">   )</span><br><span class="line">m.drawcoastlines()</span><br><span class="line">m.drawcountries()</span><br><span class="line">m.drawstates()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/23/ironman-2019-day08/85cadf1d.png" alt="Screen Shot 2018-10-23 at 21.35.12.png"><br>另外，其他比較常用到的投影包含：</p><ul><li>merc(Mercator): 麥卡托投影</li><li>tmerc(Transverse Mercator): 橫麥卡托投影</li><li>npstere,spstere(North(South)-Polar Stereographic): 極投影</li><li>lcc(Lambert Conformal: 蘭伯特投影</li><li>robin(Robinson): 羅賓森投影<br>在matplotlib的basemap中的投影代碼請參考<a href="https://matplotlib.org/basemap/api/basemap_api.html" target="_blank" rel="noopener">matplotlib basemap toolkit — Basemap Matplotlib Toolkit 1.1.0 documentation</a></li></ul><p>由於各式投影要給的參數不同，今天只是簡單測試，關於如何選擇投影，可以參考<br><a href="https://github.com/croach/oreilly-matplotlib-course/blob/master/07%20-%20Mapping%20in%20matplotlib/0701%20-%20What%20is%20a%20Map%20Projection%3F.ipynb" target="_blank" rel="noopener">What is a Map Projection?</a>有一些說明，適度暸解投影的特性，會讓資料視覺化更成功</p><h3 id="顏色-值域的正規化"><a href="#顏色-值域的正規化" class="headerlink" title="顏色/值域的正規化"></a>顏色/值域的正規化</h3><p>資訊圖表的視覺化需考量<code>視覺變數</code>，顏色是視覺變數的其中一個項目，<br>以<a href="https://ithelp.ithome.com.tw/articles/10203720" target="_blank" rel="noopener">Day06 其它資料聚合與geohash</a>的geohash成果為例(以下代碼同第六天)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import geopandas as gpd</span><br><span class="line">light=gpd.read_file(&apos;output/light.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">light=light[light.is_valid]</span><br><span class="line">light=light[light[&apos;district&apos;]==&apos;永和區&apos;]</span><br><span class="line">light.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; # 避免資料沒設，這邊再重新給一次</span><br><span class="line">light=light.to_crs(epsg=4326)</span><br><span class="line"></span><br><span class="line">import geohash</span><br><span class="line">light[&apos;geohash&apos;]=[geohash.encode(row[&apos;geometry&apos;].y,row[&apos;geometry&apos;].x, precision=7) for idx,row in light.iterrows()]</span><br><span class="line"></span><br><span class="line">group=light.groupby(&apos;geohash&apos;)</span><br><span class="line">group=group.size().reset_index(name=&apos;counts&apos;)</span><br><span class="line"></span><br><span class="line">from shapely.geometry import Polygon</span><br><span class="line">geohashs=[]</span><br><span class="line">for idx,row in group.iterrows():</span><br><span class="line">    decoded=geohash.bbox(row[&apos;geohash&apos;])</span><br><span class="line">    geohashs.append(Polygon([(decoded[&apos;s&apos;], decoded[&apos;w&apos;]), (decoded[&apos;s&apos;],decoded[&apos;e&apos;]), (decoded[&apos;n&apos;], decoded[&apos;e&apos;]), (decoded[&apos;n&apos;],decoded[&apos;w&apos;])]))</span><br><span class="line">g = gpd.GeoSeries(geohashs)</span><br><span class="line"></span><br><span class="line">g_aggr = gpd.GeoDataFrame(group)</span><br><span class="line">g_aggr[&apos;geometry&apos;]=g</span><br></pre></td></tr></table></figure></p><p>這個資料我們想以<code>counts</code>上色，我們第六天的時候，一切設定都是default值</p><p>然而，我們其實可以控制一些繪圖的參數</p><p>第一個可以控制的是cmap顏色類型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_aggr.plot(&apos;counts&apos;,cmap=&apos;YlGn&apos;, figsize=(12, 12))</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/23/ironman-2019-day08/37232308.png" alt="Screen Shot 2018-10-23 at 22.07.33.png"></p><p>給另外一種顏色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_aggr.plot(&apos;counts&apos;,cmap=&apos;PiYG&apos;, figsize=(12, 12))</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/23/ironman-2019-day08/399a9bff.png" alt="Screen Shot 2018-10-23 at 22.09.46.png"><br><a href="https://matplotlib.org/examples/color/colormaps_reference.html" target="_blank" rel="noopener">顏色類型參考— Matplotlib 2.0.2 documentation</a></p><p>另外，還可以調整scheme，<br>包含了‘equal_interval’, ‘quantiles’ or ‘percentiles’，也就是顏色間隔的計算方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_aggr.plot(&apos;counts&apos;,cmap=&apos;PiYG&apos;, scheme = &apos;equal_interval&apos;, figsize=(12, 12))</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/23/ironman-2019-day08/6328301e.png" alt="Screen Shot 2018-10-23 at 22.15.24.png"></p><p>還有k值，給定顏色的數量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_aggr.plot(&apos;counts&apos;,cmap=&apos;PiYG&apos;, scheme = &apos;equal_interval&apos;,k=15, figsize=(12, 12))</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/23/ironman-2019-day08/ad5291ef.png" alt="Screen Shot 2018-10-23 at 22.16.15.png"></p><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://github.com/croach/oreilly-matplotlib-course/tree/master/07%20-%20Mapping%20in%20matplotlib" target="_blank" rel="noopener">oreilly-matplotlib-course/07 - Mapping in matplotlib at master · croach/oreilly-matplotlib-course · GitHub</a></p><blockquote><p><a href="https://github.com/chimin17/2019_30day/blob/master/Day08_matplotlib_basemap.ipynb" target="_blank" rel="noopener">今天的相關測試可以參考GitHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前幾天我們也有利用&lt;code&gt;Geopandas&lt;/code&gt;裡面包的&lt;code&gt;matplotlib&lt;/code&gt;做一些基本的繪圖&lt;br&gt;GIS資料很常出現在日常生活的資訊視覺化，除了在資料工程上用在&lt;code&gt;Data wrangling&lt;/code&gt;外，資料視覺化扮演著資訊發布的重任，GIS或是地圖的視覺化的學習與資源非常的多，今天我們以&lt;code&gt;matplotlib&lt;/code&gt;，討論一下GIS資料視覺化的一些要素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day07 進階幾何資料處理</title>
    <link href="https://chimin17.github.io/2018/10/22/ironman-2019-day07/"/>
    <id>https://chimin17.github.io/2018/10/22/ironman-2019-day07/</id>
    <published>2018-10-22T14:48:22.000Z</published>
    <updated>2018-10-23T15:30:37.813Z</updated>
    
    <content type="html"><![CDATA[<p>今天的主題是延續<a href="https://ithelp.ithome.com.tw/articles/10203180" target="_blank" rel="noopener">Day04 幾何資料基本運算</a>，記錄一下在GIS向量資料中，可能會碰到但比較進階的幾何處理，今天的測試主要是圍繞在<code>shapely</code>的應用，<code>shapely</code>在<code>Geopandas</code>也有依賴，因此相關操作可以互相延伸。</p><a id="more"></a><h3 id="在線資料中內插點"><a href="#在線資料中內插點" class="headerlink" title="在線資料中內插點"></a>在線資料中內插點</h3><p>shapely的interpolate滿方便的，我們知道向量資料包含了點線面，線與面是由一序列的點組成的，shapely的interpolate提供了一個方法，可以在這樣的序列資料中，沿著序列的方向內插一個點。</p><blockquote><p>有關向量資料，請參考<a href="https://ithelp.ithome.com.tw/articles/10194729" target="_blank" rel="noopener">[Day 11] WebGIS中的向量圖層-除了點資料以外的幾何</a></p></blockquote><p>為此，我們先產生兩個線做說明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import geopandas as gpd</span><br><span class="line">from shapely.geometry import LineString,Point</span><br><span class="line">line1 = LineString([(0, 0), (50, 50), (100, 100)]) </span><br><span class="line">line2 = LineString([(10, 0), (60, 50), (110, 100)]) </span><br><span class="line">lines = gpd.GeoDataFrame()</span><br><span class="line">lines[&apos;geometry&apos;] = [line1,line2]</span><br><span class="line">lines.plot()</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/22/ironman-2019-day07/92fe82d1.png" alt="Screen Shot 2018-10-22 at 21.26.07.png"><br>接著分別對資料做內插，其中<code>distance</code>是要內插的距離<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">base=lines.plot()</span><br><span class="line">points = gpd.GeoDataFrame()</span><br><span class="line">points[&apos;geometry&apos;] = [row[&apos;geometry&apos;].interpolate(50) for idx,row in df.iterrows()]</span><br><span class="line">points.plot(ax=base)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/22/ironman-2019-day07/5a52c99b.png" alt="Screen Shot 2018-10-22 at 21.27.09.png"><br>內插多個點<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">base=lines.plot()</span><br><span class="line">points = gpd.GeoDataFrame()</span><br><span class="line">intpoints=[row[&apos;geometry&apos;].interpolate(50) for idx,row in df.iterrows()]</span><br><span class="line">intpoints+=[row[&apos;geometry&apos;].interpolate(25) for idx,row in df.iterrows()]</span><br><span class="line">intpoints+=[row[&apos;geometry&apos;].interpolate(75) for idx,row in df.iterrows()]</span><br><span class="line">points[&apos;geometry&apos;] = intpoints</span><br><span class="line">points.plot(ax=base)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/22/ironman-2019-day07/12e69251.png" alt="Screen Shot 2018-10-22 at 21.32.21.png"></p><h3 id="project"><a href="#project" class="headerlink" title="project"></a>project</h3><p><code>shapely</code>的<code>project</code>這個方法會回傳線資料對與一個點的投影距離，<br>直接用案例來看:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LineString([(0, 0), (50, 50), (100, 100)]).project(Point(50,0))</span><br></pre></td></tr></table></figure></p><p>回傳值=<code>35.3553390</code></p><p>我們把圖畫出來<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lines = gpd.GeoDataFrame()</span><br><span class="line">lines[&apos;geometry&apos;] = [LineString([(0, 0), (50, 50), (100, 100)])]</span><br><span class="line">base=lines.plot()</span><br><span class="line"></span><br><span class="line">points = gpd.GeoDataFrame()</span><br><span class="line">points[&apos;geometry&apos;] = [Point(50,0)]</span><br><span class="line">points.plot(ax=base)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/22/ironman-2019-day07/234ececb.png" alt="Screen Shot 2018-10-22 at 21.49.55.png"><br>project方法提供的，是(50,0)這個點，投影在線上的點p，這個點p距離線的原點(0,0)的距離</p><p>再看一個例子，這次我們特意把點指定在線上(投影就是自己)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lines = gpd.GeoDataFrame()</span><br><span class="line">lines[&apos;geometry&apos;] = [LineString([(0, 0), (50, 50), (100, 100)])]</span><br><span class="line">base=lines.plot()</span><br><span class="line"></span><br><span class="line">points = gpd.GeoDataFrame()</span><br><span class="line">points[&apos;geometry&apos;] = [Point(50,50)]</span><br><span class="line">points.plot(ax=base)</span><br><span class="line">LineString([(0, 0), (50, 50), (100, 100)]).project(Point(50,50))</span><br></pre></td></tr></table></figure></p><p>回傳值=<code>70.710678</code></p><p><img src="/2018/10/22/ironman-2019-day07/5b982b2d.png" alt="Screen Shot 2018-10-22 at 21.51.27.png"><br>其中，<code>70.710678</code>其實就是(50,50)到這條線的原點(0,0)的距離</p><h2 id="de-9im-relationships"><a href="#de-9im-relationships" class="headerlink" title="de-9im-relationships"></a>de-9im-relationships</h2><p>de-9im全名是(Dimensionally Extended nine-Intersection Model)，是一個GIS位向關係描述的模型及標轉，這個模型描述了兩個幾何物件的關係，它把兩個幾何物件的關係以物件的I(Interior),B(Boundary),E(Exterior)，兩物件之間的幾何關係以此3*3內的關係來判斷，這個矩陣就是de-9im，以下圖為例：<br><img src="/2018/10/22/ironman-2019-day07/450497d4.png" alt="Screen Shot 2018-10-22 at 19.42.25.png"><br>[取自<a href="https://en.wikipedia.org/wiki/DE-9IM" target="_blank" rel="noopener">DE-9IM - Wikipedia</a>]</p><p>上圖範例中，a及b為兩個面，他們之間的關係按I, B, E三個觀點切入，在矩陣內的Dim()函數表示此關係的維度。如果相交部分點則為0，線則為一維，dim()=1，面則dim()=2，而不相交為dim()=-1，de-9im的讀法可以中從上往下、從左往右將數字集合起來如本案例的<code>212101212</code>，這串數字就用來表達這兩個物件的關係。</p><p>這樣的模型再把它簡化一點，我們把維度dim()簡化成相交(0,1,2維)與不相交(-1)，分別以T與F表示，配合I, B, E三個角度的判斷，這樣也可以拿來描述兩個幾何物件的關係。</p><p>另外，我們常用的幾何物件關係的描述，若以de-9im表示，<br>其實並不需要9個元素都判斷就可以判斷他們是否符合這個關係，<br>例如以上兩個面相交的例子：<br>實際上它是<br><code>TTTTTTTTT</code><br>事實上只要知道第一個T，就可以決定這種關係<br><code>T********</code></p><p>又例如兩個面分離(Disjoint)，他應符合：<br><code>FF*FF****</code><br>我們直接來測試，把第三天的資料再來拿看看<br>更多的幾何關係可以參考<a href="http://docs.safe.com/fme/html/FME_Desktop_Documentation/FME_Transformers/Transformers/spatialrelations.htm#Spatial" target="_blank" rel="noopener">Spatial Relations Defined</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p1=gpd.read_file(&apos;output/Library.shp&apos;,encoding=&apos;utf-8&apos;).head(1)</span><br><span class="line">p1.crs = &#123;&apos;init&apos; :&apos;epsg:4326&apos;&#125; # 避免資料沒設，這邊再重新給一次</span><br><span class="line">p1=p1.to_crs(epsg=3826)</span><br><span class="line">p1[&apos;geometry&apos;]=p1.buffer(30).translate(xoff=20.0, yoff=0.0)</span><br><span class="line"></span><br><span class="line">p2=gpd.read_file(&apos;output/Library.shp&apos;,encoding=&apos;utf-8&apos;).head(1)</span><br><span class="line">p2.crs = &#123;&apos;init&apos; :&apos;epsg:4326&apos;&#125; # 避免資料沒設，這邊再重新給一次</span><br><span class="line">p2=p2.to_crs(epsg=3826)</span><br><span class="line">p2[&apos;geometry&apos;]=p2.buffer(30)</span><br><span class="line">base=p1.plot(color=&apos;blue&apos;)</span><br><span class="line">p2.plot(ax=base,color=&apos;brown&apos;)</span><br></pre></td></tr></table></figure><p><img src="/2018/10/22/ironman-2019-day07/97dab248.png" alt="Screen Shot 2018-10-22 at 20.51.28.png"><br>由於Geopandas的geometry是依賴於shapely，使用<code>relate</code>這個方法<br>看看他的de-9im的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.at[0,&apos;geometry&apos;].relate(p2.at[0,&apos;geometry&apos;])</span><br></pre></td></tr></table></figure><p>回傳值=<code>212101212</code></p><blockquote><p>今天的相關測試可以參考<a href="https://github.com/chimin17/2019_30day/blob/master/Day07_shapely.ipynb" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的主題是延續&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10203180&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Day04 幾何資料基本運算&lt;/a&gt;，記錄一下在GIS向量資料中，可能會碰到但比較進階的幾何處理，今天的測試主要是圍繞在&lt;code&gt;shapely&lt;/code&gt;的應用，&lt;code&gt;shapely&lt;/code&gt;在&lt;code&gt;Geopandas&lt;/code&gt;也有依賴，因此相關操作可以互相延伸。&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day06 其它資料聚合與geohash</title>
    <link href="https://chimin17.github.io/2018/10/21/ironman-2019-day06/"/>
    <id>https://chimin17.github.io/2018/10/21/ironman-2019-day06/</id>
    <published>2018-10-21T05:48:22.000Z</published>
    <updated>2018-10-21T05:54:25.712Z</updated>
    
    <content type="html"><![CDATA[<p>前一天的資料聚合，所舉的應用例是行政區村里，實作簡單的點資料與空間單元做結合，然而事實上，聚合的單元不限於行政區村里，以台灣來說，可以使用內政部最小統計區的空間單元來做資料聚合，最小統計區與其發佈區的劃設主要是根據<code>人口</code>，有關最小統計區請參考<a href="https://data.moi.gov.tw/MoiOD/Data/DataDetail.aspx?oid=03C1D0A5-1F39-4C1F-AA2E-BB37A0405369" target="_blank" rel="noopener">最小統計區圖｜MOI Open Data</a>。</p><p>另外，也有特別針對其他用途的統計區：<a href="https://data.nat.gov.tw/dataset/5970" target="_blank" rel="noopener">經濟統計區圖資| 政府資料開放平臺</a>，或是如集水區等都可以採用前一天的方法，與點資料做整合，相關資料請自行參閱。</p><p>今天要介紹的也與昨日的資料聚合有一點關係-<code>geohash</code><br><a id="more"></a></p><h3 id="Geohash"><a href="#Geohash" class="headerlink" title="Geohash"></a>Geohash</h3><p><code>geohash</code>故名意思是一種編碼，包含了多層級的架構，將空間劃分為網格(分為1-12層)，Geohash的產生是根據Z-order curve的方式產生的，這樣的特性讓查詢上可以透過hash編碼的前綴來加快空間搜尋速度。</p><p><code>geohash</code>被很常用在GIS資料的indexing上，他有點類似R-tree或Quadtree</p><p>以示意圖來理解<code>geohash</code><br><img src="https://camo.githubusercontent.com/65c8bcb95cad5f8eaee05318c91c33c7fccbaf34/687474703a2f2f692e737461636b2e696d6775722e636f6d2f74563953372e6a7067" alt="687474703a2f2f692e737461636b2e696d6775722e636f6d2f74563953372e6a7067"><br>(取自<a href="https://github.com/stephenlb/geohash-chat-by-proximity" target="_blank" rel="noopener">GitHub - stephenlb/geohash-chat-by-proximity: Geo Hashing Chat by Proximity to connect two or more users to a group chat.</a>)</p><p>geohash的每個層級的網格的解析度<code>大致</code>如下：<br>1    5,009.4km x 4,992.6km<br>2    1,252.3km x 624.1km<br>3    156.5km x 156km<br>4    39.1km x 19.5km<br>5    4.9km x 4.9km<br>6    1.2km x 609.4m<br>7    152.9m x 152.4m<br>8    38.2m x 19m<br>9    4.8m x 4.8m<br>10    1.2m x 59.5cm<br>11    14.9cm x 14.9cm<br>12    3.7cm x 1.9cm</p><p>線上也有一些工具可以檢視及瀏覽geohash編碼<br><a href="https://www.movable-type.co.uk/scripts/geohash.html" target="_blank" rel="noopener">Geohash encoding/decoding</a></p><p>瀏覽這個網站也會對geohash更有感覺<br><a href="http://geohash.gofreerange.com/" target="_blank" rel="noopener">GeohashExplorer</a></p><h3 id="project-point-to-geohash"><a href="#project-point-to-geohash" class="headerlink" title="project point to geohash"></a>project point to geohash</h3><p>我們直接簡單從python做一些測試，geohash是透過經緯度坐標系統建構的：</p><p>以<code>路燈</code>資料為例，先轉為經緯度資料<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import geopandas as gpd</span><br><span class="line">light=gpd.read_file(&apos;output/light.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">light=light[light.is_valid]</span><br><span class="line">light=light[light[&apos;district&apos;]==&apos;永和區&apos;]</span><br><span class="line">light.crs = &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; </span><br><span class="line">light=light.to_crs(epsg=4326)</span><br><span class="line">light</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/21/ironman-2019-day06/50440629.png" alt="Screen Shot 2018-10-21 at 11.57.40.png"></p><p>接著，直接我們使用pygeohash，precision 7 代表第七層</p><blockquote><p>須先安裝，使用 <code>pip install python-geohash</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import geohash</span><br><span class="line">light[&apos;geohash&apos;]=[geohash.encode(row[&apos;geometry&apos;].y,row[&apos;geometry&apos;].x, precision=7) for idx,row in light.iterrows()]</span><br><span class="line">light</span><br></pre></td></tr></table></figure><p><img src="/2018/10/21/ironman-2019-day06/ff093595.png" alt="Screen Shot 2018-10-21 at 12.08.16.png"></p><p>接著使用groupby<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">group=light.groupby(&apos;geohash&apos;)</span><br><span class="line">group=group.size().reset_index(name=&apos;counts&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/21/ironman-2019-day06/2f884ad4.png" alt="Screen Shot 2018-10-21 at 12.12.37.png"></p><p>我們試著把geohash解碼，geohash.bbox(0)提供geohash的邊界，我們把它轉為Polygob，把它存進去一個新的array<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from shapely.geometry import Polygon</span><br><span class="line">geohashs=[]</span><br><span class="line">for idx,row in group.iterrows():</span><br><span class="line">    decoded=geohash.bbox(row[&apos;geohash&apos;])</span><br><span class="line">    geohashs.append(Polygon([(decoded[&apos;s&apos;], decoded[&apos;w&apos;]), (decoded[&apos;s&apos;],decoded[&apos;e&apos;]), (decoded[&apos;n&apos;], decoded[&apos;e&apos;]), (decoded[&apos;n&apos;],decoded[&apos;w&apos;])]))</span><br></pre></td></tr></table></figure></p><p>我們把資訊畫出來吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = gpd.GeoSeries(geohashs)        </span><br><span class="line">g_aggr = gpd.GeoDataFrame(group)</span><br><span class="line">g_aggr[&apos;geometry&apos;]=g</span><br><span class="line">g_aggr.plot(&apos;counts&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/21/ironman-2019-day06/2acd059a.png" alt="Screen Shot 2018-10-21 at 13.38.20.png"></p><h3 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h3><p>透過今天的練習，利用geohash也可以進行網格式的資料聚合以及多時期的資料分析。</p><blockquote><p>今天的相關測試可以參考<a href="https://github.com/chimin17/2019_30day/blob/master/Day06_geohash.ipynb" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一天的資料聚合，所舉的應用例是行政區村里，實作簡單的點資料與空間單元做結合，然而事實上，聚合的單元不限於行政區村里，以台灣來說，可以使用內政部最小統計區的空間單元來做資料聚合，最小統計區與其發佈區的劃設主要是根據&lt;code&gt;人口&lt;/code&gt;，有關最小統計區請參考&lt;a href=&quot;https://data.moi.gov.tw/MoiOD/Data/DataDetail.aspx?oid=03C1D0A5-1F39-4C1F-AA2E-BB37A0405369&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最小統計區圖｜MOI Open Data&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外，也有特別針對其他用途的統計區：&lt;a href=&quot;https://data.nat.gov.tw/dataset/5970&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;經濟統計區圖資| 政府資料開放平臺&lt;/a&gt;，或是如集水區等都可以採用前一天的方法，與點資料做整合，相關資料請自行參閱。&lt;/p&gt;
&lt;p&gt;今天要介紹的也與昨日的資料聚合有一點關係-&lt;code&gt;geohash&lt;/code&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day05 基本的資料聚合</title>
    <link href="https://chimin17.github.io/2018/10/20/ironman-2019-day05/"/>
    <id>https://chimin17.github.io/2018/10/20/ironman-2019-day05/</id>
    <published>2018-10-20T04:42:43.000Z</published>
    <updated>2018-10-20T04:54:26.403Z</updated>
    
    <content type="html"><![CDATA[<p>在Pandas可以使用<code>groupby</code>等方法進行資料聚合<br>例如先前第三天的路燈資料，如果想看一下不同的統計成果，除了空間上的展示外，可以用資料內的行政區欄位(district)做聚合</p><p>回顧這份資料，有district欄位表示行政區</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">light=gpd.read_file(&apos;output/light.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">light</span><br></pre></td></tr></table></figure><p><img src="/2018/10/20/ironman-2019-day05/55847807.png" alt="Screen Shot 2018-10-19 at 23.37.11.png"></p><p>我們可以很簡單的用groupy做資料的的聚合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">light.groupby(&apos;district&apos;).size()</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><img src="/2018/10/20/ironman-2019-day05/0c0802e0.png" alt="Screen Shot 2018-10-19 at 23.53.55.png"></p><p>如果資料中沒有這樣的屬性呢？(例如第三天的另一份圖書館點為資料)<br>在GIS資料中，我們可以對資料做空間聚合，聚合的單元可以是面資料。</p><blockquote><p>路燈及圖書館資料請參考及<a href="https://ithelp.ithome.com.tw/articles/10194371" target="_blank" rel="noopener">Day03 從Pandas到Geopandas的幾種方法</a></p></blockquote><h3 id="spatial-join"><a href="#spatial-join" class="headerlink" title="spatial join"></a>spatial join</h3><p>首先我們下載村里界圖<br><a href="http://data.ntpc.gov.tw/od/detail?oid=37E84742-1392-43FB-8E7C-627147903731" target="_blank" rel="noopener">新北市政府資料開放平台</a>，試著把圖書館資料與其做連結</p><p>把村里界圖讀進來，稍作觀察<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import geopandas as gpd</span><br><span class="line">village=gpd.read_file(&apos;data/Village/Village.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">village.crs= &#123;&apos;init&apos; :&apos;epsg:3826&apos;&#125; # 避免資料沒設，這邊再重新給一次</span><br><span class="line">village.head(3)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/20/ironman-2019-day05/8c89c151.png" alt="Screen Shot 2018-10-20 at 10.26.46.png"><br>可以看出來ADMIV及ADMIT是村里與行政區</p><p>把圖書館資料有讀進來<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lib=gpd.read_file(&apos;output/library.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">lib.crs= &#123;&apos;init&apos; :&apos;epsg:4326&apos;&#125; # 避免資料沒設，這邊再重新給一次</span><br><span class="line">lib=lib.to_crs(epsg=3826)</span><br><span class="line">lib.head(3)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/20/ironman-2019-day05/387be716.png" alt="Screen Shot 2018-10-20 at 10.26.52.png"><br>從上面可以看到，這份圖書館沒有行政區的資訊，無法直接產出如前面的統計表，但是由於我們有村里的GIS資料，可利用資料間的空間關係整合，在此特別在提醒，請記得轉換空間坐標，讓兩者系統一致喔。</p><blockquote><p>坐標轉換請參考前一天的文章： <a href="https://ithelp.ithome.com.tw/articles/10203180" target="_blank" rel="noopener">Day04 幾何資料基本運算</a></p></blockquote><p>先把他們套疊<br>(ps.為了方便顯示，只選擇<code>中和區</code>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base=village[village[&apos;ADMIT&apos;]==&apos;中和區&apos;].plot(color=&apos;yellow&apos;)</span><br><span class="line">lib[lib[&apos;address&apos;].str.contains(&apos;中和區&apos;)].plot(ax=base)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/20/ironman-2019-day05/57d99597.png" alt="Screen Shot 2018-10-20 at 10.35.02.png"></p><p>從上得知，我們應該可以從空間關係取得我們要的東西，使用的是spatial join(sjoin)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = gpd.tools.sjoin(lib, village[[&apos;ADMIV&apos;,&apos;ADMIT&apos;,&apos;geometry&apos;]], how=&quot;left&quot;)</span><br><span class="line">result</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/20/ironman-2019-day05/41a60bad.png" alt="Screen Shot 2018-10-20 at 10.38.35.png"></p><p>其中，<code>how</code>是選擇要left join或是right, inner join，op則是空間關聯的方法，有<code>contains</code>, <code>within</code>, <code>intersects</code>可以選擇，我們選within，因為我們想計算點被包含在哪些村里界中</p><p>spatial join完成後，我們就可以做groupy，達到前面的效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">group=result.groupby([&apos;ADMIT&apos;,&apos;ADMIV&apos;])</span><br><span class="line">group.size().reset_index(name=&apos;counts&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/20/ironman-2019-day05/e9188f7f.png" alt="Screen Shot 2018-10-20 at 12.12.01.png"></p><p>除了表格的展示，可以展點在圖上，並以行政區做上色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.plot(&apos;ADMIT&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/20/ironman-2019-day05/aba6a944.png" alt="Screen Shot 2018-10-20 at 12.12.15.png"></p><p>然而，如果要以地圖展示的話，可能不夠清楚，把村里的圖也納進來一起顯示吧！</p><h3 id="aggregation"><a href="#aggregation" class="headerlink" title="aggregation"></a>aggregation</h3><p>為了產生這樣的資訊，可以先計算<code>village</code>圖層涵蓋到的點數量，這之中會參考到昨天的幾何基本運算，這邊使用<code>intersects</code>，計算<code>counts</code>，也就是包含的點數量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">counts=[np.sum(row[&apos;geometry&apos;].intersects(lib.unary_union)) for idx, row in village.iterrows()]</span><br><span class="line">village[&apos;count&apos;]=counts</span><br><span class="line">aggre_v=village[[&apos;ADMIV&apos;,&apos;ADMIT&apos;,&apos;count&apos;,&apos;geometry&apos;]]</span><br><span class="line">aggre_v[aggre_v[&apos;count&apos;]&gt;0]</span><br></pre></td></tr></table></figure><p><img src="/2018/10/20/ironman-2019-day05/f45ab621.png" alt="Screen Shot 2018-10-20 at 12.18.19.png"></p><p>展示一下，並以count上色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aggre_v.plot(&apos;count&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/20/ironman-2019-day05/0a8157c4.png" alt="Screen Shot 2018-10-20 at 12.19.37.png"></p><h3 id="dissolve"><a href="#dissolve" class="headerlink" title="dissolve"></a>dissolve</h3><p>試著再把資料做一次聚合，使用行政區上色，會用到<code>dissolve</code>，其中第一個參數是要dissolve的欄位，aggfunc則是欄位中被合併的資料呈現的方式，我們這邊的聚合方式當然是<code>sum</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dis=aggre_v.dissolve(&apos;ADMIT&apos;,aggfunc=&apos;sum&apos;)</span><br><span class="line">dis</span><br></pre></td></tr></table></figure><p><img src="/2018/10/20/ironman-2019-day05/8f84b00b.png" alt="Screen Shot 2018-10-20 at 12.22.27.png"></p><p>最後，展示成果<br><img src="/2018/10/20/ironman-2019-day05/53d7ba06.png" alt="Screen Shot 2018-10-20 at 12.23.01.png"></p><h3 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h3><p>今天的練習在QGIS等軟體都可以很方便做到，在Geopandas中，也是透過幾行程式碼就可以操作到這些效果，並且更具彈性。</p><blockquote><p>今天的相關測試可以參考<a href="https://github.com/chimin17/2019_30day/blob/master/Day05_aggregation_and_dissolve.ipynb" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Pandas可以使用&lt;code&gt;groupby&lt;/code&gt;等方法進行資料聚合&lt;br&gt;例如先前第三天的路燈資料，如果想看一下不同的統計成果，除了空間上的展示外，可以用資料內的行政區欄位(district)做聚合&lt;/p&gt;
&lt;p&gt;回顧這份資料，有district欄位表示行政區&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;light=gpd.read_file(&amp;apos;output/light.shp&amp;apos;,encoding=&amp;apos;utf-8&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;light&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;/2018/10/20/ironman-2019-day05/55847807.png&quot; alt=&quot;Screen Shot 2018-10-19 at 23.37.11.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;我們可以很簡單的用groupy做資料的的聚合&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;light.groupby(&amp;apos;district&amp;apos;).size()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day04 幾何資料基本運算</title>
    <link href="https://chimin17.github.io/2018/10/19/ironman-2019-day04/"/>
    <id>https://chimin17.github.io/2018/10/19/ironman-2019-day04/</id>
    <published>2018-10-19T12:21:22.000Z</published>
    <updated>2018-10-20T04:46:35.141Z</updated>
    
    <content type="html"><![CDATA[<p>GeoDataFrame使操作GIS資料分析時更有彈性<br>我們可以很快對GIS的屬性資料的分析與過濾</p><p>當然，也包括一些幾何空間的運算</p><h2 id="坐標轉換"><a href="#坐標轉換" class="headerlink" title="坐標轉換"></a>坐標轉換</h2><p>坐標轉換幾乎是GIS第一門課，可以參考<a href="https://ithelp.ithome.com.tw/articles/10194371" target="_blank" rel="noopener">[Day10] 坐標系統及WebGIS常用的坐標轉換</a>有大致的說明。</p><a id="more"></a><p>Geopandas依賴pyrpoj，坐標轉換操作也很簡單<br>我們以昨天的圖書館資料為例，它是epsg4326，試著轉成TWD97(epsg3826)<br>在同一坐標系統的資料才能一起操作</p><blockquote><p>有關圖書館資料，請參考<a href="https://ithelp.ithome.com.tw/articles/10202839" target="_blank" rel="noopener">Day03 從Pandas到Geopandas的幾種方法</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import geopandas as gpd</span><br><span class="line">gdf_Lib=gpd.read_file(&apos;output/Library.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">gdf_Lib.crs = &#123;&apos;init&apos; :&apos;epsg:4326&apos;&#125; # 避免資料沒設，這邊再重新給一次</span><br><span class="line">gdf_Lib=gdf_Lib.to_crs(epsg=3826)</span><br><span class="line">gdf_Lib</span><br></pre></td></tr></table></figure><p><img src="/2018/10/19/ironman-2019-day04/a3f51b10.png" alt=""></p><p>可以看到坐標系統已經成果轉換(4326–&gt;3826)</p><h2 id="幾何操作"><a href="#幾何操作" class="headerlink" title="幾何操作"></a>幾何操作</h2><p>接下來來進行基本的幾何運算，<br>Geopandas的幾何操作主要是來自shaply套件，以下來試看看在GIS軟體常用的功能</p><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>buffer在GIS中常用來分析點線面的影響範圍，<br>這邊採用上面圖書館的資料<br>採用buffer這個方法，參數為環域距離<br>由於坐標系統已經轉為TWD97，因此距離的設定的單位為公尺</p><p>而為了做比較，我們只取資料的第一筆做buffer，並把原始的點也放上去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">base=gdf_Lib.head(1).buffer(100).plot()</span><br><span class="line"></span><br><span class="line">gdf_Lib.head(1).plot(ax=base, marker=&apos;o&apos;, color=&apos;red&apos;, markersize=30);</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/19/ironman-2019-day04/3820e1d2.png" alt=""></p><h3 id="area"><a href="#area" class="headerlink" title="area"></a>area</h3><p>area是GeoDataFrame所有每一筆資料的面積<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buffer=gdf_Lib.head(1).buffer(100)</span><br><span class="line">area=buffer.area</span><br><span class="line">print(area[0])</span><br><span class="line"></span><br><span class="line">### # 0 31365.4849055</span><br></pre></td></tr></table></figure></p><h3 id="envelope"><a href="#envelope" class="headerlink" title="envelope"></a>envelope</h3><p>envelope是整個GeoDataFrame每一筆資料包覆的長方形範圍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">envelope=buffer.envelope</span><br><span class="line">print(envelope)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 0    POLYGON ((295824.3464126067 2765944.031022599,...</span><br></pre></td></tr></table></figure></p><h3 id="convex-hull"><a href="#convex-hull" class="headerlink" title="convex_hull"></a>convex_hull</h3><p>convex hull則是包住每一個資料的多邊形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">convexhull=buffer.convex_hull</span><br><span class="line">print(convexhull)</span><br><span class="line"></span><br><span class="line">### 0    POLYGON ((295924.3464126067 2765944.031022599,...</span><br></pre></td></tr></table></figure></p><p>可以Plot一下convex hull與envelope，連同點的buffer一起套疊<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">base=envelope.plot()</span><br><span class="line">convexhull.plot(ax=base,color=&apos;brown&apos;)</span><br><span class="line">gdf_Lib.head(1).plot(ax=base,  color=&apos;red&apos;);</span><br></pre></td></tr></table></figure></p><p>可以發現convex hull與envelope的差異，並且convex hull與buffer的結果一樣(因為包住圓的convex hull 也是圓..不好意思這個例子舉不太好)<br><img src="/2018/10/19/ironman-2019-day04/2f1835c5.png" alt=""></p><h3 id="幾何轉換"><a href="#幾何轉換" class="headerlink" title="幾何轉換"></a>幾何轉換</h3><p>可以進行幾何的投影轉換，可以對資料進行仿射轉換(Affine Transform)，包含了兩個平移、兩個尺度、一個剪力以及一個旋轉</p><p>這邊只舉尺度轉換的例子，分別在x方向10倍及y方向5倍的投影，並與原本的buffer做比較。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base=buffer.scale(10,5).plot(color=&apos;yellow&apos;)</span><br><span class="line">buffer.plot(ax=base,color=&apos;brown&apos;)</span><br></pre></td></tr></table></figure></p><p>其餘的一些操作在Shapely的官方文件有滿多說明的，特別是對幾何資料的一些檢查，建議有需要時瀏覽一遍Shapely的參考文件<br><a href="http://toblerity.org/shapely/manual.html" target="_blank" rel="noopener">The Shapely User Manual — Shapely 1.2 and 1.3 documentation</a></p><h2 id="空間運算子"><a href="#空間運算子" class="headerlink" title="空間運算子"></a>空間運算子</h2><p>前半部說明的主要為資料內部的計算，在此空間運算子是屬於資料與資料之間的運算與分析</p><p>常見的GIS運算包含了幾項運算子，如<br><img src="/2018/10/19/ironman-2019-day04/cd202466.png" alt="取自GeoPandas">[取自Geopandas官方]</p><p>為了方便說明，我們把前面buffer的成果做一些處理，<br>p1是把buffer成果做一些平移，p2則是原本buffer的結果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p1=gpd.read_file(&apos;output/Library.shp&apos;,encoding=&apos;utf-8&apos;).head(1)</span><br><span class="line">p1.crs = &#123;&apos;init&apos; :&apos;epsg:4326&apos;&#125; # 避免資料沒設，這邊再重新給一次</span><br><span class="line">p1=p1.to_crs(epsg=3826)</span><br><span class="line">p1[&apos;geometry&apos;]=p1.buffer(30).translate(xoff=20.0, yoff=0.0)</span><br><span class="line"></span><br><span class="line">p2=gpd.read_file(&apos;output/Library.shp&apos;,encoding=&apos;utf-8&apos;).head(1)</span><br><span class="line">p2.crs = &#123;&apos;init&apos; :&apos;epsg:4326&apos;&#125; # 避免資料沒設，這邊再重新給一次</span><br><span class="line">p2=p2.to_crs(epsg=3826)</span><br><span class="line">p2[&apos;geometry&apos;]=p2.buffer(30)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/19/ironman-2019-day04/97e3e9a9.png" alt=""></p><h3 id="intersection"><a href="#intersection" class="headerlink" title="intersection"></a>intersection</h3><p>intersection是交集，我們分別使用不同的顏色，交集的部分是黃色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intersection = gpd.overlay(p1,p2,  how=&apos;intersection&apos;)</span><br><span class="line">base=p1.plot(color=&apos;blue&apos;)</span><br><span class="line">p2.plot(ax=base,color=&apos;brown&apos;)</span><br><span class="line">intersection.plot(ax=base,color=&apos;yellow&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/19/ironman-2019-day04/4af333a6.png" alt=""></p><h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p>聯集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union = gpd.overlay(p1,p2,  how=&apos;union&apos;)</span><br><span class="line">base=p1.plot(color=&apos;blue&apos;)</span><br><span class="line">p2.plot(ax=base,color=&apos;brown&apos;)</span><br><span class="line">union.plot(ax=base,color=&apos;yellow&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/19/ironman-2019-day04/bd276c9e.png" alt=""></p><h3 id="difference"><a href="#difference" class="headerlink" title="difference"></a>difference</h3><p>算出兩個幾何的差異，一樣以黃色表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">difference = gpd.overlay(p1,p2,  how=&apos;difference&apos;)</span><br><span class="line">base=p1.plot(color=&apos;blue&apos;)</span><br><span class="line">p2.plot(ax=base,color=&apos;brown&apos;)</span><br><span class="line">difference.plot(ax=base,color=&apos;yellow&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/19/ironman-2019-day04/9efb6e0e.png" alt=""></p><p>以上就簡單測試一些幾何運算子，未來幾天有機會會在應用到這些方法</p><blockquote><p>今天的相關測試可以參考<a href="https://github.com/chimin17/2019_30day/blob/master/Day04_geometric_analysis.ipynb" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GeoDataFrame使操作GIS資料分析時更有彈性&lt;br&gt;我們可以很快對GIS的屬性資料的分析與過濾&lt;/p&gt;
&lt;p&gt;當然，也包括一些幾何空間的運算&lt;/p&gt;
&lt;h2 id=&quot;坐標轉換&quot;&gt;&lt;a href=&quot;#坐標轉換&quot; class=&quot;headerlink&quot; title=&quot;坐標轉換&quot;&gt;&lt;/a&gt;坐標轉換&lt;/h2&gt;&lt;p&gt;坐標轉換幾乎是GIS第一門課，可以參考&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10194371&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[Day10] 坐標系統及WebGIS常用的坐標轉換&lt;/a&gt;有大致的說明。&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day03 從Pandas到Geopandas的幾種方法</title>
    <link href="https://chimin17.github.io/2018/10/18/ironman-2019-day03/"/>
    <id>https://chimin17.github.io/2018/10/18/ironman-2019-day03/</id>
    <published>2018-10-18T13:23:01.000Z</published>
    <updated>2018-10-19T13:00:20.974Z</updated>
    
    <content type="html"><![CDATA[<p>Geopandas可以讀取各GIS格式進行空間運算，<br>然而實際上我們可能拿到的資料不見得是GIS的格式</p><p>不是GIS格式，但它可能是有坐標資訊的資料</p><p>比較常見的會是一個csv,Excel含有經緯度或xy的資料，對於這樣的資料，我們可以把它轉為<code>Geopandas</code>的<code>GeoDataFrame</code>。</p><a id="more"></a><h2 id="用Pandas讀取csv或Excel"><a href="#用Pandas讀取csv或Excel" class="headerlink" title="用Pandas讀取csv或Excel"></a>用Pandas讀取csv或Excel</h2><p>為了今天的範例，我們下載[<a href="https://data.gov.tw/dataset/26689" target="_blank" rel="noopener">新北市路燈資料</a>]，下載該數據的csv檔，命名為Light.csv<br>第一步先使用Pandas讀取csv為DataFrame<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd </span><br><span class="line">df=pd.read_csv(&apos;data/Light/Light.csv&apos;,encoding=&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/18/ironman-2019-day03/73455e36.png" alt=""></p><blockquote><p>ps.如果沒有pandas請記得安裝<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pandas</span><br></pre></td></tr></table></figure></p></blockquote><p>瀏覽一下這份資料可以看到這份資料具有TWD97X, TWD97Y坐標欄位。<br>接下來，我們試著把X,Y轉換成GeoDataFrame</p><h2 id="DataFrame轉為Geodataframe"><a href="#DataFrame轉為Geodataframe" class="headerlink" title="DataFrame轉為Geodataframe"></a>DataFrame轉為Geodataframe</h2><p>前一天提到GeoDataFrame包含geometry的屬性，<br>因此，要產生GeoDataFrame，需要產生<code>geometry</code><br>這時候需要用shapely套件中的geometry<br>我們使用之中的Point類型，並把TWD97X, TWD97Y包成geom<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from shapely.geometry import Point</span><br><span class="line">import geopandas as gpd</span><br><span class="line">geom = [Point(xy) for xy in zip(df.TWD97X, df.TWD97Y)]</span><br></pre></td></tr></table></figure></p><p>有了<code>geom</code>，我們可以用來產生<code>GeoDataFrame</code>，<br>其中，需要指定crs，由於TWD97X, TWD97Y的坐標是TWD97，為epsg:3826</p><blockquote><p><a href="https://ithelp.ithome.com.tw/articles/10194371" target="_blank" rel="noopener">[Day10] 坐標系統及WebGIS常用的坐標轉換</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crs = &#123;&apos;init&apos;: &apos;epsg:3826&apos;&#125;</span><br><span class="line">gdf = gpd.GeoDataFrame(df, crs=crs, geometry=geom)</span><br><span class="line">gdf</span><br></pre></td></tr></table></figure></p></blockquote><p><img src="/2018/10/18/ironman-2019-day03/61ef1ed0.png" alt=""></p><p>就這樣，我們成功把csv轉成了GeoDataFrame，<br>然後我們就可以做GeoDataFrame能做的事<br>把永和區的資料畫圖來，並以<code>address</code>為color code繪圖，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdf[gdf[&apos;district&apos;]==&apos;永和區&apos;].plot(column=&apos;address&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/18/ironman-2019-day03/6f3ecaf0.png" alt="Screen Shot 2018-10-17 at 21.07.31.png"></p><h2 id="Geocoding"><a href="#Geocoding" class="headerlink" title="Geocoding"></a>Geocoding</h2><p>像是今天的資料集[<a href="https://data.gov.tw/dataset/26689" target="_blank" rel="noopener">新北市路燈資料</a>]是一個具有XY的資料，<br>如果今天資料中沒有XY，我們還是可以透過一些Geocoding方法取得坐標<br>在<a href="https://ithelp.ithome.com.tw/articles/10194193" target="_blank" rel="noopener">[Day 9] 自己產製資料-地址定位part2</a>提到可以使用TGOS來進行門牌地址的Geocoding。</p><p>為了一次性的完成Geocoding，接下來以<a href="https://developer.tomtom.com/online-search/online-search-documentation-geocoding/geocode" target="_blank" rel="noopener">TomTom Developer Portal Geocode</a>的Geocoding為例(個人經驗是會有較好的成果)</p><p>首先，必須要取得一個api key，方法很簡單，按照官網方法操作就好<a href="https://developer.tomtom.com/user/login" target="_blank" rel="noopener">User account | TomTom Developer Portal</a></p><p>假設以順利取得api的key，我們現在以<a href="https://data.gov.tw/dataset/26601" target="_blank" rel="noopener">新北市各圖書館地址電話表</a>為範例，下載csv使用</p><p>首先，跟上面一樣，用Pandas讀取csv<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd </span><br><span class="line">df=pd.read_csv(&apos;data/Library/Library.csv&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">df</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/18/ironman-2019-day03/059467f1.png" alt=""></p><p>接著我們寫一個函式處理Geocoding，呼叫的方法及回應的格式直接參考<a href="https://developer.tomtom.com/online-search/online-search-documentation-geocoding/geocode" target="_blank" rel="noopener">TomTom Developer Portal Geocode</a>的說明</p><p>其中，<code>YOUR_KEY</code>必須填入你的api key!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import requests,json</span><br><span class="line">def rest(address):</span><br><span class="line"></span><br><span class="line">    url = &apos;https://api.tomtom.com/search/2/geocode/&#123;&#125;.json?&amp;key=YOUR_KEY&amp;countrySet=TWN&amp;language=zh-TW&amp;limit=1&apos;.format(</span><br><span class="line">        address)</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    data = response.text</span><br><span class="line">    js = json.loads(str(data))</span><br><span class="line">    return js[&apos;results&apos;][0][&apos;position&apos;]</span><br></pre></td></tr></table></figure></p><blockquote><p>ps. requests需要安裝，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install requests</span><br></pre></td></tr></table></figure></p></blockquote><p>然後使用這個rest函式，產生geometry(命名為geom)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 這邊使用df.head()只取前五筆測試</span><br><span class="line">geom=[Point(rest(row.address)) for idx, row in df.head().iterrows()]</span><br></pre></td></tr></table></figure><p>有了geom就可以產生GeoDataFrame了，要注意的是，<br>這邊的坐標是WGS84，也就是epsg:4326<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crs = &#123;&apos;init&apos;: &apos;epsg:4326&apos;&#125;</span><br><span class="line">gdf = gpd.GeoDataFrame(df.head(), crs=crs, geometry=geom)</span><br><span class="line">gdf</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/18/ironman-2019-day03/28d89d47.png" alt=""></p><p>一樣，看看成果吧</p><p><img src="/2018/10/18/ironman-2019-day03/49526754.png" alt=""></p><p>GeoDataFrame可以輸出成GIS格式，用以在其他平台檢視與處理，包含常用的shp或是geojson<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdf.to_file(driver = &apos;ESRI Shapefile&apos;, filename = &apos;output/Light.shp&apos;)</span><br></pre></td></tr></table></figure></p><blockquote><p>今天的相關測試可以參考<a href="https://github.com/chimin17/2019_30day/blob/master/Day03_Pandas2GeoPandas.ipynb" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Geopandas可以讀取各GIS格式進行空間運算，&lt;br&gt;然而實際上我們可能拿到的資料不見得是GIS的格式&lt;/p&gt;
&lt;p&gt;不是GIS格式，但它可能是有坐標資訊的資料&lt;/p&gt;
&lt;p&gt;比較常見的會是一個csv,Excel含有經緯度或xy的資料，對於這樣的資料，我們可以把它轉為&lt;code&gt;Geopandas&lt;/code&gt;的&lt;code&gt;GeoDataFrame&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day02 Geopandas初探</title>
    <link href="https://chimin17.github.io/2018/10/17/ironman-2019-day02/"/>
    <id>https://chimin17.github.io/2018/10/17/ironman-2019-day02/</id>
    <published>2018-10-17T12:15:01.000Z</published>
    <updated>2018-10-19T12:54:49.041Z</updated>
    
    <content type="html"><![CDATA[<p><code>Pandas</code>是資料分析熱門且好用的工具，相信熟悉資料分析的各路英雄好漢都不陌生<br>在Python中，與GIS相關的套件滿坑滿谷，這邊我們選定<code>Geopandas</code>作為資料操作的基礎<br>它與Pandas有很接近的操作體驗，並且依賴了許多GIS常用的Python套件。</p><h2 id="Geopandas介紹"><a href="#Geopandas介紹" class="headerlink" title="Geopandas介紹"></a>Geopandas介紹</h2><p>在Python上處理空間資料有許多套件們，這些套件都有不同的使用場景，例如<code>shapely</code>用在向量資料的處理、<code>fiona</code>則是幫助使用Python上操作<code>OGR</code>(支援超多格式的資料轉換)，<code>pyproj</code>做坐標投影的轉換等等。</p><a id="more"></a><p>還好，<code>Geopandas</code>的出現，讓這些事情變得比較好上手，也讓分析資料時感受很像Pandas，<br>他主要依賴了以下Python空間資料處理的套件介面：</p><ul><li>shapely</li><li>fiona</li><li>descartes</li><li>matplotlib</li><li>pyproj</li><li>numpy<br>..more</li></ul><hr><p>使用者可以跟Pandas操作DataFrame一般，在Geopandas操作GeoDataFrame，並且擁有許多空間資料處理的功能。<br>在Python環境中使用GeoPandas，依照官方文件的說明，安裝方法有兩種，第一種是使用Conda(請設定Python3.6環境)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c conda-forge geopandas</span><br></pre></td></tr></table></figure><p>或是直接透過Geopandas Repo以pip安裝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install git+git://github.com/geopandas/geopandas.git</span><br></pre></td></tr></table></figure><h2 id="讀寫GIS資料"><a href="#讀寫GIS資料" class="headerlink" title="讀寫GIS資料"></a>讀寫GIS資料</h2><p>今天所使用的GIS資料為<code>向量</code>資料<br>其中shp為空間資料中最為常見的一種向量資料的格式，<br>它可以紀錄點、線、面等幾何</p><blockquote><p>有關向量資料及格式的暸解，可以參考<br><a href="https://ithelp.ithome.com.tw/articles/10193701" target="_blank" rel="noopener">[Day 6] 常見的GIS資料格式 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天</a></p></blockquote><p>我們可以利用GeoPandas讀取shp資料，以進行我們想要的各種處理或分析，以[<a href="https://data.gov.tw/dataset/73220" target="_blank" rel="noopener">臺灣鐵路 | 政府資料開放平臺</a>]這個資料集為例，我們將其下載到本機，使用GeoPandas讀取為GeoDataFrame</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import geopandas as gpd</span><br><span class="line">gdf_Rail=gpd.read_file(&apos;data/Rail/Rail.shp&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">gdf_Rail</span><br></pre></td></tr></table></figure><p><img src="/2018/10/17/ironman-2019-day02/e58211a8.png" alt=""></p><p>GeoPandas也支援常用的格式</p><h2 id="GeoDataFrame"><a href="#GeoDataFrame" class="headerlink" title="GeoDataFrame"></a>GeoDataFrame</h2><p>GeoDataFrame與DataFrame類似，在[<a href="http://geopandas.org/data_structures.html" target="_blank" rel="noopener">官方文件</a>]中對於DataFrame的基本類型有一些說明。</p><blockquote><p>簡單來說，與dataframe相對，GeoPandas多了一個geometry的欄位。</p></blockquote><hr><h2 id="Like-a-DataFrame"><a href="#Like-a-DataFrame" class="headerlink" title="Like a DataFrame"></a>Like a DataFrame</h2><p>GeoDataFrame的許多基本操作與Pandas的DataFrame很<br>我們試著做一些Pandas上可以做的事情，</p><p>選擇欄位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subset=gdf_Rail[&apos;RAILNAME&apos;]</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/17/ironman-2019-day02/a478244e.png" alt=""><br>subset again<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subset=gdf_Rail.iloc[:3]</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/17/ironman-2019-day02/ca9cb4ab.png" alt=""><br>排序資料<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sample=gdf_Rail.sort_values(by=&apos;MDATE&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/17/ironman-2019-day02/34a71488.png" alt=""></p><p>另外，GeoDataFrame對於地理資料有基本的繪圖功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sample.plot()</span><br></pre></td></tr></table></figure><p><img src="/2018/10/17/ironman-2019-day02/84d97c63.png" alt=""><br>其採用matplotlib繪圖引擎，例如可以依照欄位來繪圖(下面案例是以鐵道支線名稱分色)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sample.plot(column=&apos;RAILNAME&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/17/ironman-2019-day02/1eaa9264.png" alt=" "><br>GeoDataFrame讓GIS資料處理更方便，他與DataFrame操作體驗接近，今天也初探了一些簡單的功能</p><p>對於DataFrame或者GeoDataFrame的操作，可以參考<a href="https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf" target="_blank" rel="noopener">Data wrangling with Pandas</a>的圖表，<br>對於Pandas的功能有一些快速指南，大部分也都通用於Geopandas。</p><blockquote><p>今天的相關測試可以參考<a href="https://github.com/chimin17/2019_30day/blob/master/Day02_Geopandas.ipynb" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Pandas&lt;/code&gt;是資料分析熱門且好用的工具，相信熟悉資料分析的各路英雄好漢都不陌生&lt;br&gt;在Python中，與GIS相關的套件滿坑滿谷，這邊我們選定&lt;code&gt;Geopandas&lt;/code&gt;作為資料操作的基礎&lt;br&gt;它與Pandas有很接近的操作體驗，並且依賴了許多GIS常用的Python套件。&lt;/p&gt;
&lt;h2 id=&quot;Geopandas介紹&quot;&gt;&lt;a href=&quot;#Geopandas介紹&quot; class=&quot;headerlink&quot; title=&quot;Geopandas介紹&quot;&gt;&lt;/a&gt;Geopandas介紹&lt;/h2&gt;&lt;p&gt;在Python上處理空間資料有許多套件們，這些套件都有不同的使用場景，例如&lt;code&gt;shapely&lt;/code&gt;用在向量資料的處理、&lt;code&gt;fiona&lt;/code&gt;則是幫助使用Python上操作&lt;code&gt;OGR&lt;/code&gt;(支援超多格式的資料轉換)，&lt;code&gt;pyproj&lt;/code&gt;做坐標投影的轉換等等。&lt;/p&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽2019 Day01 前言</title>
    <link href="https://chimin17.github.io/2018/10/16/ironman-2019-day01/"/>
    <id>https://chimin17.github.io/2018/10/16/ironman-2019-day01/</id>
    <published>2018-10-16T12:12:33.000Z</published>
    <updated>2018-10-17T12:23:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>地理空間資料或簡稱GIS資料，無論是學術研究、資料科學、商業分析、或是各種資料採集等，或多或少都需要與空間資料相處。</p><p>或許各路GIS相關的工作者，常會覺得明明<code>空間資料</code>與<code>非空間資料</code>差異只在於有無坐標資料，但實際處理起來卻常常遇到各種坑苦。</p><p>有感於此，希望藉由這次<code>鐵人賽</code>的砥礪，攻略實務上處理GIS資料時<code>更進階</code>及更<code>自動化</code>的工具與技巧。</p><blockquote><p>這次30天的任務，主要以<code>Python</code>為主軸，配合<code>QGIS</code>及<code>空間資料庫</code>，熟悉GIS工作的<code>自動化</code>流程，解決空間資料分析或是資料工程上的問題。</p></blockquote><a id="more"></a><hr><p>雖然QGIS及ArcGIS中，也支援Python程式的包裝PyQGIS與ArcPy，使用者可以撰寫程式、拉Model或是Macro等，在許多情境下，已經可以解決大多數問題。</p><p>然而GIS資料常是眾多資料流的一部分，以軟體架構角度如果資料流必須跳到另外一個軟體或環境執行，總是覺得不太順遂。因此這30天挑戰的目標將是以Coding方式處理GIS資料，主要是利用Python作為資料分析的語言，當然也會加入一些軟體的輔助。</p><blockquote><p>GIS軟體儘管好用，但若GIS資料是一個資料流的一部分，不允許中斷另以其它軟體做處理，此時，動手寫程式處理GIS資料是必須的，有些時候，撰寫程式會比操作軟體還要方便一些！</p></blockquote><h2 id="目標架構"><a href="#目標架構" class="headerlink" title="目標架構"></a>目標架構</h2><p>在起始階段，原本先構想先規劃一下30天中每一天的目標，但仔細想想，常常寫到一半會發現新多東西或挑戰，很難一次定義清楚每日目標，但整個範疇應該會包含：</p><ul><li>Python 基本GIS資料處理</li><li>資料視覺化</li><li>空間資料庫</li><li>結合各種資料集</li><li>GIS資料採集</li><li>GIS資料分析</li></ul><h2 id="開發環境"><a href="#開發環境" class="headerlink" title="開發環境"></a>開發環境</h2><p>這30天的挑戰會有一些程式碼案例，如果對提供的案例有興趣，歡迎自行測試，測試的環境為Python3，若沒有Python環境建置相關經驗，建議使用Annaconda建置Python3環境，使用Jupyter Notebbook作測試，詳細過程可以參考：<br><a href="https://ithelp.ithome.com.tw/articles/10184561" target="_blank" rel="noopener">[第 01 天] 建立開發環境與計算機應用 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;地理空間資料或簡稱GIS資料，無論是學術研究、資料科學、商業分析、或是各種資料採集等，或多或少都需要與空間資料相處。&lt;/p&gt;
&lt;p&gt;或許各路GIS相關的工作者，常會覺得明明&lt;code&gt;空間資料&lt;/code&gt;與&lt;code&gt;非空間資料&lt;/code&gt;差異只在於有無坐標資料，但實際處理起來卻常常遇到各種坑苦。&lt;/p&gt;
&lt;p&gt;有感於此，希望藉由這次&lt;code&gt;鐵人賽&lt;/code&gt;的砥礪，攻略實務上處理GIS資料時&lt;code&gt;更進階&lt;/code&gt;及更&lt;code&gt;自動化&lt;/code&gt;的工具與技巧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這次30天的任務，主要以&lt;code&gt;Python&lt;/code&gt;為主軸，配合&lt;code&gt;QGIS&lt;/code&gt;及&lt;code&gt;空間資料庫&lt;/code&gt;，熟悉GIS工作的&lt;code&gt;自動化&lt;/code&gt;流程，解決空間資料分析或是資料工程上的問題。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="data analysis" scheme="https://chimin17.github.io/categories/data-analysis/"/>
    
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="2019鐵人賽-30天精通GIS資料分析-使用Python" scheme="https://chimin17.github.io/tags/2019%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E7%B2%BE%E9%80%9AGIS%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽Day 30- 最重要的回顧</title>
    <link href="https://chimin17.github.io/2018/01/19/ironman-2018-day30/"/>
    <id>https://chimin17.github.io/2018/01/19/ironman-2018-day30/</id>
    <published>2018-01-19T12:12:33.000Z</published>
    <updated>2018-10-16T13:33:17.473Z</updated>
    
    <content type="html"><![CDATA[<p>第30天了，來回顧一下並發表心得吧！</p><blockquote><p>本文是參加鐵人賽的文章，同步發表於 <a href="https://ithelp.ithome.com.tw/users/20107816/ironman/1541" target="_blank" rel="noopener">“2018鐵人賽-30天打造我的WebGIS系列”</a></p></blockquote><h2 id="30天的發文大綱"><a href="#30天的發文大綱" class="headerlink" title="30天的發文大綱"></a>30天的發文大綱</h2><p>這30天的大綱可以切為6塊，分述如下：<br><a id="more"></a></p><h3 id="第1天到第5天-起步"><a href="#第1天到第5天-起步" class="headerlink" title="第1天到第5天:起步"></a>第1天到第5天:起步</h3><blockquote><p>一開始撰寫這幾篇文章的目標主要在加深WebGIS的觀念，雖然地圖應用在d3.js資料視覺化與Google Maps的發展下，已經讓很多人認識網頁與地圖，但因為過去學的是測量及地理空間資訊，撰寫鐵人賽本意是再把一些資源及觀念整理，所以這幾天從WebGIS元素到互操作性，並透過CartoDB視覺化GIS資料，希望能讓看的人看到WebGIS這個topic。</p></blockquote><p><img src="/images/post/ironman-2018/iron-3001.png" alt=""></p><h3 id="第6天到第10天-動手做資料"><a href="#第6天到第10天-動手做資料" class="headerlink" title="第6天到第10天: 動手做資料"></a>第6天到第10天: 動手做資料</h3><blockquote><p>這幾天的課題是資料的產製，主要是針對POI資料的自製，如果手邊有一份資料要做成POI，要使用什麼格式、要怎麼地址定位、坐標系統跟坐標轉換會是開發者遇到重要的課題，因此，這幾天介紹了一些概念及方便的工具以方便Web開發者參考。</p></blockquote><p><img src="/images/post/ironman-2018/iron-3002.png" alt=""></p><h3 id="第11天到第15天-了解資料型態及使用資源"><a href="#第11天到第15天-了解資料型態及使用資源" class="headerlink" title="第11天到第15天: 了解資料型態及使用資源"></a>第11天到第15天: 了解資料型態及使用資源</h3><blockquote><p>有了自己的資料以後，接下來是該怎麼把資料放到WebGIS，再者，如何運用其他外部資源也是這幾天想整理的，林林總總講了向量資料、網格資料及網路上的WMS資源都有所觸及。</p></blockquote><p><img src="/images/post/ironman-2018/iron-3003.png" alt=""></p><h3 id="第16天到第21天-實作"><a href="#第16天到第21天-實作" class="headerlink" title="第16天到第21天: 實作"></a>第16天到第21天: 實作</h3><blockquote><p>透過Leaflet實作WebGIS，最重要的是掌握GIS資料處理的一些精華，包含了基本展示、比較核心的內插、空間運算函式庫及方法介紹，大致掌握了在前端程式內插、TIN、Voronoi、熱區圖與風場圖等。</p></blockquote><p><img src="/images/post/ironman-2018/iron-3004.png" alt=""><br><img src="/images/post/ironman-2018/iron-3005.png" alt=""></p><h3 id="第22到第27天-擴充"><a href="#第22到第27天-擴充" class="headerlink" title="第22到第27天: 擴充"></a>第22到第27天: 擴充</h3><blockquote><p>已經是後半段了，所以介紹一些對WebGIS中算是外掛元素，包含導航功能、街景、圖表互動等等，另外也非常簡短介紹了空間資料庫，資料庫對WebGIS或GIS來說是另一個非常重要的核心。</p></blockquote><p><img src="/images/post/ironman-2018/iron-3006.png" alt=""></p><h3 id="第28到30天-收尾"><a href="#第28到30天-收尾" class="headerlink" title="第28到30天: 收尾"></a>第28到30天: 收尾</h3><blockquote><p>最後這幾天已經到了收尾階段，帶過一些3D GIS的想法及有趣的WebGIS的案例，最後就是今天的回顧。</p></blockquote><p><img src="/images/post/ironman-2018/iron-3007.png" alt=""></p><h2 id="小結："><a href="#小結：" class="headerlink" title="小結："></a>小結：</h2><p>這30天把一些資訊做了整理，其實都是WebGIS應用會遇到的環節，WebGIS雖然說是Web，在GIS資料面及應用上總是容易入門卻難以深入的，藉由鐵人賽也加強了自己對WebGIS的暸解。</p><h3 id="Good"><a href="#Good" class="headerlink" title="Good"></a>Good</h3><p>這次呈現的主題觸及項目跟當初規劃的差不多，特別是在資料面的問題，在WebGIS案例上多加一些比較GIS的部分，重要的是都有在時間內完成，專案執行的很滿意XD，而這次鐵人賽除了文章上面呈現的，其實更重要的是幕後資料的整理，看了很多開源的專案，也動手特別針對某些議題實作，無論最重有無寫出來，能在短時間內有主題性的去瀏覽或深入這些專案，儘管可能還沒整理好po出來，在開發生涯中也是難得經驗。</p><h3 id="Bad"><a href="#Bad" class="headerlink" title="Bad"></a>Bad</h3><p>有些環節有些可惜，要如何在短時間有限的篇幅濃縮內容，真的很難；而在程式面上，因擔心credit及主題發散問題code是寫在一起沒有架構的XD；另外例如PostGIS資料庫及MongoDB的應用在有限章節中無法實踐太多案例，每日與這些資料庫相處卻有種短時間無法說的簡單並清楚的窘態。</p><h3 id="Acknowledgment"><a href="#Acknowledgment" class="headerlink" title="Acknowledgment"></a>Acknowledgment</h3><p>最後一天必需感謝老婆的支持，晚上不睡覺搞這個真的有點肖，過程中所有幫忙及討論的前團隊同事也謝謝你們。</p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>下次見，身為GIS人，也會持續分享GIS的一切並放在github上。<br>也希望可以多跟有興趣的朋友多交流!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第30天了，來回顧一下並發表心得吧！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文是參加鐵人賽的文章，同步發表於 &lt;a href=&quot;https://ithelp.ithome.com.tw/users/20107816/ironman/1541&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;“2018鐵人賽-30天打造我的WebGIS系列”&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;30天的發文大綱&quot;&gt;&lt;a href=&quot;#30天的發文大綱&quot; class=&quot;headerlink&quot; title=&quot;30天的發文大綱&quot;&gt;&lt;/a&gt;30天的發文大綱&lt;/h2&gt;&lt;p&gt;這30天的大綱可以切為6塊，分述如下：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="https://chimin17.github.io/categories/web/"/>
    
    
      <category term="2018鐵人賽-30天打造我的WebGIS系列" scheme="https://chimin17.github.io/tags/2018%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E6%89%93%E9%80%A0%E6%88%91%E7%9A%84WebGIS%E7%B3%BB%E5%88%97/"/>
    
      <category term="web" scheme="https://chimin17.github.io/tags/web/"/>
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽Day 29- WebGIS大觀園</title>
    <link href="https://chimin17.github.io/2018/01/18/ironman-2018-day29/"/>
    <id>https://chimin17.github.io/2018/01/18/ironman-2018-day29/</id>
    <published>2018-01-18T14:02:33.000Z</published>
    <updated>2018-10-16T13:33:11.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>到了第29天，想講的東西很多，但能寫的時間不多XD，所以決定在倒數第二天來看一些有趣的WebGIS。<br><a id="more"></a></p><blockquote><p>本文是參加鐵人賽的文章，同步發表於 <a href="https://ithelp.ithome.com.tw/users/20107816/ironman/1541" target="_blank" rel="noopener">“2018鐵人賽-30天打造我的WebGIS系列”</a></p></blockquote><h2 id="Story-Map-The-Bare-Earth"><a href="#Story-Map-The-Bare-Earth" class="headerlink" title="Story Map -The Bare Earth"></a>Story Map -The Bare Earth</h2><p><a href="https://wadnr.maps.arcgis.com/apps/Cascade/index.html?appid=36b4887370d141fcbb35392f996c82d9" target="_blank" rel="noopener">The Bare Earth</a>這個網站利用<a href="http://atlefren.github.io/storymap/" target="_blank" rel="noopener">Story Map</a>的概念，以說故事的方式展示了許多GIS在地質上的應用及名詞解釋，除了資料處理上用了各種GIS內插、視覺化、空間運算等技術外，Web上也使用了大量的swipe雙視窗的功能。<br><img src="/images/post/ironman-2018/iron-2901.png" alt=""></p><h2 id="3D-Bar-Chart-3D-Feinstaub-Berlin"><a href="#3D-Bar-Chart-3D-Feinstaub-Berlin" class="headerlink" title="3D Bar Chart- 3D Feinstaub Berlin"></a>3D Bar Chart- 3D Feinstaub Berlin</h2><p><a href="http://projekte.geo3.eu/feinstaub/#13.54/52.5400/13.4034/52/55" target="_blank" rel="noopener">3D-Feinstaub Berlin</a>網站是在<a href="http://googlemapsmania.blogspot.tw/2018/01/berlin-pollution-mapped.html" target="_blank" rel="noopener">Maps Mania</a>上看到的，以3D視角加上bar chart做視覺展示，所展示的資料是污染物測站的觀測量，並有一個heatmap的開關可供結合，在3D GIS當紅的時代，這種3D GIS視覺化的應用越來越多。<br><img src="/images/post/ironman-2018/iron-2902.png" alt=""></p><h2 id="Indoor-Map"><a href="#Indoor-Map" class="headerlink" title="Indoor Map"></a>Indoor Map</h2><p>室內GIS應該是未來幾年GIS的發展方向，包含OSM Indoor Mapping也越來越多貢獻者，隨著室內定位技術逐漸提升，無論在資料生產維護或是應用開發的部分，會有越來越多室內GIS應用的產品出現，在WebGIS方面應該也會有所變化，這是從esri網站上看到的案例<a href="http://coolmaps.esri.com/IndoorMaps/ParisMall/" target="_blank" rel="noopener">IndoorMaps ParisMall</a>，Leaflet上也有類似的<a href="https://www.cbaines.net/projects/osm/leaflet-indoor/examples/" target="_blank" rel="noopener">發表</a>。<br><img src="/images/post/ironman-2018/iron-2903.png" alt=""></p><h2 id="FlowMap、百度Echarts3與Pixi-js的應用"><a href="#FlowMap、百度Echarts3與Pixi-js的應用" class="headerlink" title="FlowMap、百度Echarts3與Pixi.js的應用"></a>FlowMap、百度Echarts3與Pixi.js的應用</h2><p>WebGIS與人類生活做息息相關的就是交通，也隨著各種交通數據的整合及應用相關視覺化的表現越來越豐富，例如Leaflet上的案例<a href="https://jwasilgeo.github.io/Leaflet.Canvas-Flowmap-Layer/docs/main/" target="_blank" rel="noopener">Flowmap</a>及赫赫有名的<a href="http://wandergis.com/leaflet-echarts3/examples/index.html" target="_blank" rel="noopener">百度Echarts3</a>，另外各種WebGL(e.g. <a href="https://github.com/manubb/Leaflet.PixiOverlay" target="_blank" rel="noopener">Pixi with Leaflet</a>)在地圖上的結合也是越來越常見到。<br><img src="/images/post/ironman-2018/iron-2904.png" alt=""></p><p><img src="/images/post/ironman-2018/iron-2905.png" alt=""></p><p><img src="/images/post/ironman-2018/iron-2906.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;到了第29天，想講的東西很多，但能寫的時間不多XD，所以決定在倒數第二天來看一些有趣的WebGIS。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="https://chimin17.github.io/categories/web/"/>
    
    
      <category term="2018鐵人賽-30天打造我的WebGIS系列" scheme="https://chimin17.github.io/tags/2018%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E6%89%93%E9%80%A0%E6%88%91%E7%9A%84WebGIS%E7%B3%BB%E5%88%97/"/>
    
      <category term="web" scheme="https://chimin17.github.io/tags/web/"/>
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="Leaflet" scheme="https://chimin17.github.io/tags/Leaflet/"/>
    
  </entry>
  
  <entry>
    <title>鐵人賽Day 28- WebGL與3D GIS概觀</title>
    <link href="https://chimin17.github.io/2018/01/17/ironman-2018-day28/"/>
    <id>https://chimin17.github.io/2018/01/17/ironman-2018-day28/</id>
    <published>2018-01-17T00:02:33.000Z</published>
    <updated>2018-10-16T13:33:07.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3D-GIS"><a href="#3D-GIS" class="headerlink" title="3D GIS"></a>3D GIS</h2><p>WebGIS已經逐步走向3D GIS時代，雖然說3D GIS已經發展很多年了，也有Google Earth這樣的產品，不過真的3D GIS在這幾年才比較有大進展，突破原因除了資料獲取的技術提升以外，主要還是跟Web技術息息相關，其中WebGL佔了重要角色。</p><p>3D GIS雖然過去有Google Earth這種霸王級產品，但是其應用有限，而要說這幾年3D GIS發展及前進的速度可說是過去的好幾倍，這與WebGL發展有關，目前3D GIS仍是百家爭鳴階段，連互操作相關議題才剛有幾家大型龍頭爭奪完畢好讓自己的格式成為OGC標準(ESRI I3S勝出)，姑且不論很早起就已ready for use的3D空間分析演算法(與2D差異甚多)，3D GIS在格式、資料方面都與2D截然不同，所以，既然如此，今天就不討論那些，來瀏覽看看一些WebGL for 3D GIS的範例。<br><a id="more"></a></p><blockquote><p>本文是參加鐵人賽的文章，同步發表於 <a href="https://ithelp.ithome.com.tw/users/20107816/ironman/1541" target="_blank" rel="noopener">“2018鐵人賽-30天打造我的WebGIS系列”</a></p></blockquote><h2 id="OSM-Buildong"><a href="#OSM-Buildong" class="headerlink" title="OSM Buildong"></a>OSM Buildong</h2><p><a href="https://osmbuildings.org/?lat=52.51986&amp;lon=13.41535&amp;zoom=16&amp;tilt=30" target="_blank" rel="noopener">OSM building</a>是透過Open Street Map(OSM)上建物的資訊，Render出來的3D地圖展示，主要是根據建築物的footprint與該物件的屬性，包含了樓高、材質、屋頂等等。</p><h2 id="Building-height-Mapbox-GL"><a href="#Building-height-Mapbox-GL" class="headerlink" title="Building height: Mapbox-GL"></a>Building height: Mapbox-GL</h2><p><a href="https://www.mapbox.com/mapbox-gl-js/example/3d-buildings/" target="_blank" rel="noopener">Mapbox-GL</a>也有3D建物的功能，也是利用樓高的方式進行render，看起來效果很好。<br><img src="https://ppt.cc/fmbp9x@.png" alt=""></p><h2 id="地形"><a href="#地形" class="headerlink" title="地形"></a>地形</h2><p>前面兩者的案例是利用平面的街廓線，配合屬性資訊產生3D建物的效果(或是說2.5D)，在3D GIS中，地形也是很重要的元素，例如<a href="http://meetar.github.io/heightmap-demos/scale.html" target="_blank" rel="noopener">heightmap</a>及<a href="http://giscience.github.io/GIScene.js/examples/dem_srtm30" target="_blank" rel="noopener">GIScene.js</a>就是利用SRTM 30米空間解析度全球地形資料庫做的3D地形展示(SRTM全稱是<a href="https://www2.jpl.nasa.gov/srtm/" target="_blank" rel="noopener">Shuttle Radar Topography Mission</a>，是NASA JPL發展多年的計畫)，將SRTM從2D Raster利用WebGL(three.js的)做3D的呈現。<br><img src="https://ppt.cc/fzEAgx@.png" alt=""></p><p><img src="https://ppt.cc/f3L3Jx@.png" alt=""></p><h2 id="3D-mesh場景"><a href="#3D-mesh場景" class="headerlink" title="3D mesh場景"></a>3D mesh場景</h2><p>為了呈現更多細節，目前的3D 的WebGIS以走向3D mesh方向發展，透過電腦視覺及攝影測量技術重建3D場景模型，這些模型是以三角網方式組成，可以呈現非常完整的細節(包含形狀及紋理等)，也因為要呈現細節，所以在瀏覽器效能及API串流的技術上就顯得格外重要，相關案例如<a href="http://www.arcgis.com/home/item.html?id=1f97ba887fd4436c8b17a14d83584611" target="_blank" rel="noopener">ESRI 3D mesh scene layer</a>。<br><img src="https://ppt.cc/fViO9x@.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;3D-GIS&quot;&gt;&lt;a href=&quot;#3D-GIS&quot; class=&quot;headerlink&quot; title=&quot;3D GIS&quot;&gt;&lt;/a&gt;3D GIS&lt;/h2&gt;&lt;p&gt;WebGIS已經逐步走向3D GIS時代，雖然說3D GIS已經發展很多年了，也有Google Earth這樣的產品，不過真的3D GIS在這幾年才比較有大進展，突破原因除了資料獲取的技術提升以外，主要還是跟Web技術息息相關，其中WebGL佔了重要角色。&lt;/p&gt;
&lt;p&gt;3D GIS雖然過去有Google Earth這種霸王級產品，但是其應用有限，而要說這幾年3D GIS發展及前進的速度可說是過去的好幾倍，這與WebGL發展有關，目前3D GIS仍是百家爭鳴階段，連互操作相關議題才剛有幾家大型龍頭爭奪完畢好讓自己的格式成為OGC標準(ESRI I3S勝出)，姑且不論很早起就已ready for use的3D空間分析演算法(與2D差異甚多)，3D GIS在格式、資料方面都與2D截然不同，所以，既然如此，今天就不討論那些，來瀏覽看看一些WebGL for 3D GIS的範例。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="https://chimin17.github.io/categories/web/"/>
    
    
      <category term="2018鐵人賽-30天打造我的WebGIS系列" scheme="https://chimin17.github.io/tags/2018%E9%90%B5%E4%BA%BA%E8%B3%BD-30%E5%A4%A9%E6%89%93%E9%80%A0%E6%88%91%E7%9A%84WebGIS%E7%B3%BB%E5%88%97/"/>
    
      <category term="web" scheme="https://chimin17.github.io/tags/web/"/>
    
      <category term="GIS" scheme="https://chimin17.github.io/tags/GIS/"/>
    
      <category term="WebGL" scheme="https://chimin17.github.io/tags/WebGL/"/>
    
  </entry>
  
</feed>
